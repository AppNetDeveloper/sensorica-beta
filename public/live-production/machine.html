<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Kanban - Ocupación y Botones</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <style>
        /* --- Fuentes y Body --- */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior-y: contain;
        }
        /* --- Estilos Círculo de Progreso Dinámico (OEE) --- */
        /* --- Estilos Círculo de Progreso Dinámico (OEE) --- */
        .progress-circle {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            background: conic-gradient(
            #4ade80 calc(var(--progress-percent, 0) * 1%),
            #e5e7eb 0
            );
            position: relative;
            font-size: 2.2rem;
            font-weight: bold;
            color: #16a34a;
            transition: background 0.3s ease;
            margin-right: 20%    /* <--- aquí aumentas el espacio desde el borde  anterior 8rem;*/
        }

        .progress-circle::before {
            content: ""; position: absolute; border-radius: 50%; inset: 12px; background: #fff; z-index: 1;
        }
        .progress-circle > span {
             z-index: 2; position: relative;
        }

        /* --- Estilos Tarjeta Kanban Refactorizados --- */
        .kanban-card {
            padding: 0.75rem; border-radius: 0.375rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            border-width: 1px; margin-bottom: 0.75rem; cursor: grab;
            font-size: 0.875rem; line-height: 1.25rem; border-style: solid;
            touch-action: manipulation; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
        }
        #col-pendiente .kanban-card { background-color: #fefce8; border-color: #fde68a; }
        #col-en-curso .kanban-card { background-color: #eff6ff; border-color: #bfdbfe; }
        #col-finalizadas .kanban-card { background-color: #f9fafb; border-color: #e5e7eb; }
        #col-incidencias .kanban-card { background-color: #fef2f2; border-color: #fecaca; }

        /* --- Estilos Etiquetas OPE --- */
         .ope-tag {
            display: inline-block; padding-left: 0.5rem; padding-right: 0.5rem;
            padding-top: 0.125rem; padding-bottom: 0.125rem; border-radius: 0.25rem;
            font-size: 0.75rem; font-weight: 500; margin-right: 0.25rem; margin-bottom: 0.25rem;
            line-height: 1;
        }
        .ope-pendiente { background-color: #fef08a; color: #a16207; }
        .ope-en-curso { background-color: #bfdbfe; color: #1e40af; }
        .ope-finalizada { background-color: #bbf7d0; color: #166534; }
        .ope-incidencia { background-color: #fecaca; color: #991b1b; }
        .ope-default { background-color: #e5e7eb; color: #374151; }

        /* --- Otros estilos --- */
        .kanban-column {
            background-color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            min-height: 200px;
            max-height: 30rem;
            overflow-y: auto;
        }
        .kanban-title { font-weight: 600; color: #374151; margin-bottom: 1rem; text-align: center; }
        .gu-mirror {
            padding: 0.75rem; border-radius: 0.375rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); border-width: 1px; font-size: 0.875rem; line-height: 1.25rem; border-style: solid;
            opacity: 0.8 !important; position: fixed !important; cursor: grabbing !important; z-index: 9999 !important; touch-action: none; margin-bottom: 0;
        }
        #col-pendiente .gu-mirror { background-color: #fefce8; border-color: #fde68a; }
        #col-en-curso .gu-mirror { background-color: #eff6ff; border-color: #bfdbfe; }
        #col-finalizadas .gu-mirror { background-color: #f9fafb; border-color: #e5e7eb; }
        #col-incidencias .gu-mirror { background-color: #fef2f2; border-color: #fecaca; }
        .gu-transit { opacity: 0.5; }
        .long-press-ready {
             outline: 2px dashed #fbbf24;
             outline-offset: 2px;
        }
        .select2-container--default .select2-selection--single { border: 1px solid #d1d5db; border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); height: 2.5rem; }
        .select2-container--default .select2-selection--single .select2-selection__rendered { line-height: 2.5rem; padding-left: 0.75rem; }
        .select2-container--default .select2-selection--single .select2-selection__arrow { height: calc(2.5rem - 2px); }
        .select2-dropdown { border: 1px solid #d1d5db; border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
        .select2-search--dropdown .select2-search__field { border: 1px solid #d1d5db; border-radius: 0.375rem; margin: 0.25rem; }
        .hidden { display: none; }

        /* Estilo base para los iconos de acción */
        #action-buttons-container .action-icon {
           font-size: 3rem;
           line-height: 1;
           transition: color 0.15s ease-in-out, opacity 0.15s ease-in-out;
           opacity: 0.6;
        }
        .action-button {
            width: 64px; height: 64px; display: flex; align-items: center; justify-content: center;
            border-radius: 0.375rem; background-color: transparent; box-shadow: none;
            transition: background-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        #start-shift-button .action-icon,
        #resume-button .action-icon { color: #22c55e; }
        #start-pause-button .action-icon { color: #eab308; }
        #end-shift-button .action-icon,
        #end-pause-button .action-icon { color: #ef4444; }
        .action-button:hover {
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        #start-shift-button:hover .action-icon,
        #resume-button:hover .action-icon,
        #start-pause-button:hover .action-icon,
        #end-shift-button:hover .action-icon,
        #end-pause-button:hover .action-icon {
            color: white !important;
            opacity: 1 !important;
        }
        #start-shift-button:hover, #resume-button:hover { background-color: #22c55e; }
        #start-pause-button:hover { background-color: #eab308; }
        #end-shift-button:hover, #end-pause-button:hover { background-color: #ef4444; }

        #shift-select-container { margin-top: 1rem; }
        #shift-select {
             padding: 0.5rem 0.75rem; border: 1px solid #d1d5db;
             border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
             background-color: white; font-size: 0.875rem; line-height: 1.25rem;
        }
        .progress-bar-segment {
            transition: width 0.5s ease-in-out;
            height: 100%;
        }
        /* === Estilos para Paneles Flotantes === */
        .floating-panel {
            position: fixed;
            background-color: white;
            border: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.15), 0 4px 8px -4px rgba(0, 0, 0, 0.1); /* Sombra más pronunciada */
            transition: opacity 0.3s ease-in-out;
            min-height: 100px; /* Altura mínima para que la cabecera sea visible */
        }
        .floating-panel-header {
            padding: 0.75rem 1rem; /* p-3 px-4 */
            background-color: #f3f4f6; /* Tailwind gray-100 */
            border-bottom: 1px solid #d1d5db; /* Tailwind gray-300 */
            cursor: move;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .floating-panel-header h3 {
            font-weight: 600; /* font-semibold */
            color: #374151; /* text-gray-700 */
        }
        .floating-panel-content {
            padding: 1.5rem; /* p-6 */
        }
        #floating-operator-panel {
            top: 36%; /* Posición inicial ajustada */
            right: 20px;
            width: 320px; /* Ancho del panel de operario */
            z-index: 1000;
        }
        #floating-actions-panel {
            top: 36%; /* Posición inicial ajustada */
            left: 20px;
            width: 320px; /* Ancho fijo igual al panel de operario */
            z-index: 990; /* Ligeramente por debajo del panel de operario */
        }
        #floating-actions-panel .floating-panel-content { /* Para centrar los botones */
            display: flex;
            justify-content: center; /* Centra el contenedor de botones si es más estrecho que el panel */
        }
        #action-buttons-container { /* Asegurar que los botones se distribuyan bien */
            display: flex;
            flex-wrap: wrap; /* Permitir que los botones pasen a la siguiente línea si no caben */
            justify-content: center; /* Centrar los botones */
            gap: 0.5rem; /* Espacio entre botones */
        }
        .select2-container--default .select2-dropdown {
            z-index: 1050 !important; /* Asegurar que el dropdown de Select2 esté sobre otros elementos del panel */
        }
        /* === Estilo para alinear valores de datos === */
        .data-value {
            min-width: 80px; /* Ajustar según sea necesario para "00:00:00" */
            text-align: right;
            display: inline-block; /* Para que min-width funcione correctamente */
        }
        /* ========================================== */

    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      @font-face { font-family: 'LucideIcons'; src: url('https://cdn.jsdelivr.net/npm/lucide-static@latest/font/lucide.ttf') format('truetype'); }
      .lucide { font-family: 'LucideIcons'; font-style: normal; font-weight: normal; font-variant: normal; text-rendering: auto; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; display: inline-block; vertical-align: middle; }
    </style>
</head>
<body class="bg-gray-200 p-8">
    <div class="container mx-auto bg-white p-6 rounded-lg shadow-md">

        <div id="kanban-board" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-6 mb-6">
            <div id="col-pendiente" data-column-name="PENDIENTE" class="kanban-column">
                <h2 class="kanban-title">PENDIENTE</h2>
                <div class="kanban-card" data-card-id="card-1">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003552-02</span>
                        <span class="text-gray-600">CLIENTE 062</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-pendiente">OPE-01</span>
                        <span class="ope-tag ope-pendiente">OPE-02</span>
                        <span class="ope-tag ope-pendiente">OPE-03</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>05/03/2025</span>
                        <span>MATERIAL A0015</span>
                        <span class="font-medium text-gray-700">411 Uds</span>
                    </div>
                </div>
                 <div class="kanban-card" data-card-id="card-2">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-002252-01</span>
                        <span class="text-gray-600">CLIENTE 019</span>
                    </div>
                    <div class="mb-2 flex items-center">
                        <span class="ope-tag ope-pendiente">OPE-01</span>
                        <span class="ope-tag ope-pendiente">OPE-02</span>
                        <span class="ope-tag ope-pendiente">OPE-03</span>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-8 h-8 text-red-500 ml-1 inline-block align-middle">
                            <path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
                            <path d="M12 9v4"/>
                            <path d="M12 17h.01"/>
                        </svg>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>04/03/2025</span>
                        <span>MATERIAL A0013</span>
                        <span class="font-medium text-gray-700">244 Uds</span>
                    </div>
                </div>
                 <div class="kanban-card" data-card-id="card-3">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">OTRA-TAREA-01</span>
                        <span class="text-gray-600">CLIENTE XYZ</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-pendiente">OPE-04</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>14/04/2025</span>
                        <span>MATERIAL B0001</span>
                        <span class="font-medium text-gray-700">50 Uds</span>
                    </div>
                </div>
                <div class="kanban-card" data-card-id="card-8">
                    <div class="flex justify-between items-center mb-2"> <span class="font-semibold text-gray-800">TAREA-EXTRA-1</span> <span class="text-gray-600">CLIENTE A</span> </div>
                    <div class="mb-2"> <span class="ope-tag ope-pendiente">OPE-05</span> </div>
                    <div class="flex justify-between items-center text-gray-500"> <span>17/04/2025</span> <span>MATERIAL C001</span> <span class="font-medium text-gray-700">100 Uds</span> </div>
                </div>
                 <div class="kanban-card" data-card-id="card-9">
                    <div class="flex justify-between items-center mb-2"> <span class="font-semibold text-gray-800">TAREA-EXTRA-2</span> <span class="text-gray-600">CLIENTE B</span> </div>
                    <div class="mb-2"> <span class="ope-tag ope-pendiente">OPE-06</span> </div>
                    <div class="flex justify-between items-center text-gray-500"> <span>18/04/2025</span> <span>MATERIAL D002</span> <span class="font-medium text-gray-700">200 Uds</span> </div>
                </div>
            </div>
            <div id="col-en-curso" data-column-name="EN CURSO" class="kanban-column">
                <h2 class="kanban-title">EN CURSO</h2>
                 <div class="kanban-card" data-card-id="card-4">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003516-02</span>
                        <span class="text-gray-600">CLIENTE 033</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-en-curso">OPE-01</span>
                        <span class="ope-tag ope-en-curso">OPE-02</span>
                        <span class="ope-tag ope-default">OPE-03</span> </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>05/03/2025</span>
                        <span>MATERIAL A00223</span>
                        <span class="font-medium text-gray-700">105 Uds</span>
                    </div>
                </div>
            </div>
            <div id="col-finalizadas" data-column-name="FINALIZADAS" class="kanban-column">
                <h2 class="kanban-title">FINALIZADAS</h2>
                 <div class="kanban-card" data-card-id="card-5">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003552-02</span>
                        <span class="text-gray-600">CLIENTE 0221</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-finalizada">OPE-01</span>
                        <span class="ope-tag ope-default">OPE-02</span>
                        <span class="ope-tag ope-default">OPE-03</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>04/03/2025</span>
                        <span>MATERIAL A0015</span>
                        <span class="font-medium text-gray-700">71 Uds</span>
                    </div>
                </div>
                 <div class="kanban-card" data-card-id="card-6">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003552-02</span>
                        <span class="text-gray-600">CLIENTE 087</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-finalizada">OPE-01</span>
                        <span class="ope-tag ope-default">OPE-02</span>
                        <span class="ope-tag ope-default">OPE-03</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>03/03/2025</span>
                        <span>MATERIAL A0054</span>
                        <span class="font-medium text-gray-700">121 Uds</span>
                    </div>
                </div>
            </div>
            <div id="col-incidencias" data-column-name="INCIDENCIAS" class="kanban-column">
                <h2 class="kanban-title">INCIDENCIAS</h2>
                 <div class="kanban-card" data-card-id="card-7">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003552-02</span>
                        <span class="text-gray-600">CLIENTE 091</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-incidencia">OPE-01</span>
                        <span class="ope-tag ope-incidencia">OPE-02</span>
                        <span class="ope-tag ope-incidencia">OPE-03</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>05/03/2025</span>
                        <span>MATERIAL A0025</span>
                        <span class="font-medium text-gray-700">41 Uds</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="pause-notification" class="container mx-auto mt-4 hidden">
            <div class="bg-yellow-100 border border-yellow-300 text-yellow-800 px-4 py-3 rounded relative">
                <center>
                    <span class="block sm:inline font-semibold">
                        Estás en pausa. Vuelve a reanudar cuando estés listo.
                    </span>
                </center>
            </div>
        </div>

        <div class="flex flex-wrap justify-between items-start border-t border-gray-200 pt-6 pb-6">
            <div class="w-full md:w-2/3 px-4 mb-4 md:mb-0"> <div class="max-w-md mx-auto md:mx-0">
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">TIEMPO EN PARADA / Orden</span>
                         <span id="tiempo-parada-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span> </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">TIEMPO LENTO / Orden</span>
                         <span id="tiempo-lento-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span> </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">TIEMPO PREPARACION / Orden</span>
                         <span id="tiempo-preparacion-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span> </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">Unidades Hechas / Orden</span>
                         <span id="unidades-hechas-val" class="font-mono font-medium text-gray-800 data-value">0</span>
                     </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">Unidades Pendientes / Orden</span>
                         <span id="unidades-pendientes-val" class="font-mono font-medium text-gray-800 data-value">0</span>
                     </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">Unidades Retrasadas / Orden</span>
                         <span id="unidades-retrasadas-val" class="font-mono font-medium text-gray-800 data-value">0</span>
                     </div>
                 </div>
             </div>

            <div class="w-full md:w-1/3 px-4 flex flex-col items-center md:items-end">
                 <div id="progress-indicator" class="progress-circle">
                     <span id="progress-value">0</span>
                 </div>
            </div>
        </div>
        <div class="flex flex-wrap justify-between items-start border-t border-gray-200 pt-6 pb-6">
            <div class="w-full md:w-2/3 px-4 mb-4 md:mb-0"> <div class="text-sm max-w-md mx-auto md:mx-0">
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">TIEMPO EN PARADA / Maquina</span>
                         <span class="font-mono font-medium text-gray-800 data-value">3</span>
                     </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">TIEMPO LENTO / Maquina</span>
                         <span class="font-mono font-medium text-gray-800 data-value">3</span>
                     </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">TIEMPO ATRASADO / Maquina</span>
                         <span class="font-mono font-medium text-gray-800 data-value">3</span>
                     </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">Campo Ficticio 4 / Maquina</span>
                         <span class="font-mono font-medium text-gray-800 data-value">3</span>
                     </div>
                     <div class="flex justify-between py-1">
                         <span class="text-gray-600">Campo Ficticio 5 / Maquina</span>
                         <span class="font-mono font-medium text-gray-800 data-value">4</span>
                     </div>
                 </div>
            </div>

            <div class="flex flex-col items-center w-full md:w-1/3 px-4 md:items-end"> 
                 <div id="oee-maquina-indicator" class="progress-circle">
                     <span id="oee-maquina-value">0</span>
                 </div>
            </div>
        </div>
        <div class="border-t border-gray-200 pt-6">
            <div class="flex justify-between text-sm text-gray-500 mb-1">
                <span id="shift-start-time-label">HORA INICIO</span> <span id="shift-end-time-label">HORA FIN</span>
            </div>
            <div id="progress-bar-container" class="w-full bg-gray-200 rounded-full h-4 overflow-hidden flex">
                 <div id="shift-delay-bar" class="progress-bar-segment bg-red-500" style="width: 0%;"></div>
                 <div id="shift-pause-bar" class="progress-bar-segment bg-yellow-500" style="width: 0%;"></div>
                 <div id="shift-button-pause-bar" class="progress-bar-segment bg-yellow-200" style="width: 0%;"></div>
                 <div id="shift-slow-bar" class="progress-bar-segment bg-yellow-400" style="width: 0%;"></div>
                 <div id="shift-late-bar" class="progress-bar-segment bg-yellow-300" style="width: 0%;"></div>
                 <div id="shift-progress-bar" class="progress-bar-segment bg-green-500" style="width: 0%;"></div>
            </div>
            <div class="flex justify-between text-sm mt-1">
                <div class="flex justify-start space-x-2">
                     <span class="text-gray-600">TIEMPO PAUSA:</span>
                     <span id="tiempo-pausa-val" class="font-mono font-medium text-gray-800">00:00:00</span>
                </div>
                <span id="shift-info-text" class="text-gray-500">SIN DATOS</span>
            </div>
        </div>

    </div> <div id="floating-actions-panel" class="floating-panel">
        <div id="floating-actions-header">
            <h3>Acciones</h3>
        </div>
        <div class="floating-panel-content">
            <div id="action-buttons-container" class="flex items-center justify-center space-x-2">
                <button id="start-shift-button" class="action-button hidden" data-action-type="start-shift" title="Iniciar Turno/Tarea">
                    <i class="fa fa-play action-icon" aria-hidden="true"></i>
                </button>
                <button id="start-pause-button" class="action-button hidden" data-action-type="start-pause" title="Iniciar Parada">
                    <i class="fa fa-pause action-icon" aria-hidden="true"></i>
                </button>
                <button id="resume-button" class="action-button hidden" data-action-type="resume-pause" title="Reanudar">
                    <i class="fa fa-play action-icon" aria-hidden="true"></i>
                </button>
                <button id="end-shift-button" class="action-button hidden" data-action-type="end-shift" title="Finalizar Turno/Tarea">
                    <i class="fa fa-stop action-icon" aria-hidden="true"></i>
                </button>
                <button id="end-pause-button" class="action-button hidden" data-action-type="end-pause" title="Finalizar Parada">
                    <i class="fa fa-stop action-icon" aria-hidden="true"></i>
                </button>
            </div>
        </div>
    </div>
    <div id="floating-operator-panel" class="floating-panel">
        <div id="floating-panel-header">
            <h3>Operario / Turno</h3>
            </div>
        <div id="floating-panel-content" class="space-y-4">
            <div class="w-full text-center">
                <label id="worker-label" for="worker-select" class="block text-sm font-medium text-gray-700 mb-1">OPERARIO</label>
                <div id="select-container">
                     <select id="worker-select" style="width: 90%; margin: 0 auto;"> <option value="">Cargando operarios...</option> </select>
                </div>
                <div id="display-container" class="hidden mt-2 flex items-center justify-center space-x-3">
                    <span id="selected-worker-info" class="text-lg text-gray-800 font-medium"></span>
                    <button id="logout-button" title="Cambiar operario" class="text-red-500 hover:text-red-700 focus:outline-none p-1 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="m15 9-6 6"/>
                            <path d="m9 9 6 6"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="shift-select-container" class="w-full text-center hidden">
                <label for="shift-select" class="block text-sm font-medium text-gray-700 mb-1">TURNO</label>
                <select id="shift-select" style="width: 90%; margin: 0 auto;"> <option value="">Selecciona un turno...</option>
                    </select>
            </div>
        </div>
    </div>
    <button id="refresh-button" title="Refrescar Datos" class="fixed bottom-4 right-4 bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-full shadow-lg z-50 transition-colors duration-150">
        <i class="fas fa-sync-alt"></i>
    </button>


    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11" defer onerror="console.error('Error loading SweetAlert2 script:', event)"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" defer onerror="console.error('Error loading Dragula script:', event)"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Configuración ---
            const API_BASE_URL = window.location.origin;
            const REFRESH_INTERVAL_MS = 1000;
            const API_DELAY_MS = 500;
            console.log(`API Base URL set dynamically to: ${API_BASE_URL}`);

            // Verificar librerías principales
            if (typeof $ === 'undefined' || typeof $.fn.select2 === 'undefined') { console.error("Error Crítico: jQuery o Select2 no cargados."); return; }
            if (typeof dragula !== 'function') { console.error("Error Crítico: Dragula no cargado."); return; }
            if (typeof Swal !== 'function') { console.warn("Advertencia: SweetAlert2 (Swal) no cargado."); }

            // --- Elementos del DOM ---
            const workerLabel = $('#worker-label'); // Dentro del panel flotante
            const workerSelect = $('#worker-select'); // Dentro del panel flotante
            const selectContainer = $('#select-container'); // Dentro del panel flotante
            const displayContainer = $('#display-container'); // Dentro del panel flotante
            const selectedWorkerInfo = $('#selected-worker-info'); // Dentro del panel flotante
            const logoutButton = $('#logout-button'); // Dentro del panel flotante
            const shiftSelectContainer = $('#shift-select-container'); // Dentro del panel flotante
            const shiftSelect = $('#shift-select'); // Dentro del panel flotante

            const actionButtonsContainer = document.getElementById('action-buttons-container'); // Ahora dentro de su panel
            // Círculo OEE Orden
            const progressIndicator = document.getElementById('progress-indicator');
            const progressValue = document.getElementById('progress-value');
            // Círculo OEE Máquina (NUEVO)
            const oeeMaquinaIndicator = document.getElementById('oee-maquina-indicator');
            const oeeMaquinaValue = document.getElementById('oee-maquina-value');

            // Selectores y barra de progreso inferior
            const shiftStartTimeLabel = $('#shift-start-time-label');
            const shiftEndTimeLabel = $('#shift-end-time-label');
            const progressBarContainer = $('#progress-bar-container');
            const shiftDelayBar = $('#shift-delay-bar');
            const shiftPauseBar = $('#shift-pause-bar');
            const shiftButtonPauseBar = $('#shift-button-pause-bar');
            const shiftSlowBar = $('#shift-slow-bar');
            const shiftLateBar = $('#shift-late-bar');
            const shiftProgressBar = $('#shift-progress-bar');
            const shiftInfoText = $('#shift-info-text');
            // Spans de tiempos y unidades
            const tiempoParadaVal = $('#tiempo-parada-val');
            const tiempoLentoVal = $('#tiempo-lento-val');
            const tiempoPreparacionVal = $('#tiempo-preparacion-val');
            const unidadesHechasVal = $('#unidades-hechas-val');
            const unidadesPendientesVal = $('#unidades-pendientes-val');
            const unidadesRetrasadasVal = $('#unidades-retrasadas-val');
            const tiempoPausaVal = $('#tiempo-pausa-val');
            // Botón de refresco
            const refreshButton = document.getElementById('refresh-button');
            // Paneles Flotantes
            const floatingOperatorPanel = document.getElementById('floating-operator-panel');
            const operatorPanelHeader = document.getElementById('floating-panel-header'); // Cabecera del panel de operario
            const floatingActionsPanel = document.getElementById('floating-actions-panel');
            const actionsPanelHeader = document.getElementById('floating-actions-header');


            // --- Variables de Estado ---
            let currentWorker = null;
            let currentShiftState = { type: null, action: null };
            let selectedShiftId = null;
            let potentialNewWorker = null;
            let shiftHistoryTimeoutId = null;
            let orderStatsTimeoutId = null;
            let productionLineToken = null;
            let isSelectOpen = false;
            let isProcessingLogin = false;
            // Variables para arrastrar paneles
            let isDraggingOperatorPanel = false;
            let operatorPanelOffsetX, operatorPanelOffsetY;
            let isDraggingActionsPanel = false;
            let actionsPanelOffsetX, actionsPanelOffsetY;


            // --- Lógica para arrastrar el panel flotante de OPERARIO ---
            if (operatorPanelHeader && floatingOperatorPanel) {
                operatorPanelHeader.addEventListener('mousedown', function(e) {
                    isDraggingOperatorPanel = true;
                    operatorPanelOffsetX = e.clientX - floatingOperatorPanel.offsetLeft;
                    operatorPanelOffsetY = e.clientY - floatingOperatorPanel.offsetTop;
                    floatingOperatorPanel.style.cursor = 'grabbing';
                    e.preventDefault();
                });
            } else {
                console.error("Panel flotante de operario o su cabecera no encontrados.");
            }

            // --- Lógica para arrastrar el panel flotante de ACCIONES ---
            if (actionsPanelHeader && floatingActionsPanel) {
                actionsPanelHeader.addEventListener('mousedown', function(e) {
                    isDraggingActionsPanel = true;
                    actionsPanelOffsetX = e.clientX - floatingActionsPanel.offsetLeft;
                    actionsPanelOffsetY = e.clientY - floatingActionsPanel.offsetTop;
                    floatingActionsPanel.style.cursor = 'grabbing';
                    e.preventDefault();
                });
            } else {
                console.error("Panel flotante de acciones o su cabecera no encontrados.");
            }

            document.addEventListener('mousemove', function(e) {
                if (isDraggingOperatorPanel && floatingOperatorPanel) {
                    let newLeft = e.clientX - operatorPanelOffsetX;
                    let newTop = e.clientY - operatorPanelOffsetY;
                    const maxLeft = window.innerWidth - floatingOperatorPanel.offsetWidth;
                    const maxTop = window.innerHeight - floatingOperatorPanel.offsetHeight;
                    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                    newTop = Math.max(0, Math.min(newTop, maxTop));
                    floatingOperatorPanel.style.left = newLeft + 'px';
                    floatingOperatorPanel.style.top = newTop + 'px';
                }
                if (isDraggingActionsPanel && floatingActionsPanel) {
                    let newLeft = e.clientX - actionsPanelOffsetX;
                    let newTop = e.clientY - actionsPanelOffsetY;
                    const maxLeft = window.innerWidth - floatingActionsPanel.offsetWidth;
                    const maxTop = window.innerHeight - floatingActionsPanel.offsetHeight;
                    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                    newTop = Math.max(0, Math.min(newTop, maxTop));
                    floatingActionsPanel.style.left = newLeft + 'px';
                    floatingActionsPanel.style.top = newTop + 'px';
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDraggingOperatorPanel) {
                    isDraggingOperatorPanel = false;
                    if(floatingOperatorPanel) floatingOperatorPanel.style.cursor = 'move';
                }
                if (isDraggingActionsPanel) {
                    isDraggingActionsPanel = false;
                    if(floatingActionsPanel) floatingActionsPanel.style.cursor = 'move';
                }
            });


            // --- Función de utilidad para Delay ---
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

            // --- Función para formatear hora (HH:MM) ---
            function formatTime(dateTimeString) {
                if (!dateTimeString) return '--:--';
                try {
                    const date = new Date(dateTimeString);
                    if (!isNaN(date)) {
                        const hours = date.getHours().toString().padStart(2, '0');
                        const minutes = date.getMinutes().toString().padStart(2, '0');
                        return `${hours}:${minutes}`;
                    }
                    if (typeof dateTimeString === 'string' && dateTimeString.includes(':')) {
                        return dateTimeString.substring(0, 5);
                    }
                } catch (e) { console.error("Error formatting time:", dateTimeString, e); }
                return '--:--';
            }

            // --- Función para formatear duración (HH:MM:SS) ---
            function formatDuration(ms) {
                if (isNaN(ms) || ms < 0) ms = 0;
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const paddedHours = hours.toString().padStart(2, '0');
                const paddedMinutes = minutes.toString().padStart(2, '0');
                const paddedSeconds = seconds.toString().padStart(2, '0');
                return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
            }

            // --- Función para parsear duración "HH:MM:SS" a ms ---
            function parseDuration(timeString) {
                if (!timeString || typeof timeString !== 'string' || !timeString.includes(':')) return 0;
                try {
                    const parts = timeString.split(':').map(Number);
                    if (parts.length === 3 && parts.every(num => !isNaN(num))) {
                        const [hours, minutes, seconds] = parts;
                        return (hours * 3600 + minutes * 60 + seconds) * 1000;
                    }
                } catch (e) {
                    console.error("Error parsing duration string:", timeString, e);
                }
                return 0;
            }

            // --- Función para mostrar alerta de operario/turno requerido ---
            function showWorkerRequiredAlert() {
                 if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Acción no permitida', text: 'Por favor, selecciona un operario primero.', confirmButtonColor: '#3085d6' }); }
                 else { alert('Por favor, selecciona un operario primero.'); }
            }
            function showShiftRequiredAlert() {
                 if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Acción no permitida', text: 'Por favor, selecciona un turno primero.', confirmButtonColor: '#3085d6' }); }
                 else { alert('Por favor, selecciona un turno primero.'); }
            }

             // --- Función para mostrar confirmación genérica ---
             function showActionConfirmation(actionDescription, callback) {
                 const isLogoutAction = actionDescription.includes("finalizar el turno/tarea");
                 if (!isLogoutAction && !currentWorker) { showWorkerRequiredAlert(); return; }

                 if (typeof Swal === 'function') {
                     Swal.fire({
                         title: 'Confirmar Acción', text: `Estás a punto de ${actionDescription}. ¿Estás seguro?`,
                         icon: 'question', showCancelButton: true, confirmButtonColor: '#3085d6',
                         cancelButtonColor: '#d33', confirmButtonText: 'Sí', cancelButtonText: 'Cancelar'
                     }).then((result) => {
                         if (result.isConfirmed) {
                             if (!isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' confirmada por ${currentWorker.name}`); }
                             else if (isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada por ${currentWorker.name}`); }
                             else if (isLogoutAction && !currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada sin operario activo.`); }
                             callback();
                         } else {
                             console.log(`Acción '${actionDescription}' cancelada.`);
                             if (!isLogoutAction) {
                                 resetShiftSelection();
                             }
                         }
                     });
                 } else {
                      if (confirm(`Estás a punto de ${actionDescription}. ¿Estás seguro?`)) {
                          if (!isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' confirmada por ${currentWorker.name}`); }
                          else if (isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada por ${currentWorker.name}`); }
                          else if (isLogoutAction && !currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada sin operario activo.`); }
                          callback();
                      } else {
                          console.log(`Acción '${actionDescription}' cancelada.`);
                          if (!isLogoutAction) {
                              resetShiftSelection();
                          }
                      }
                 }
             }

            // --- Función para enviar evento de turno a la API ---
            function postShiftEvent(eventName) {
                // ... (Validaciones de operario y turno como antes) ...
                if (eventName !== 'final_trabajo' && (!productionLineToken || !currentWorker || !currentWorker.id)) {
                    console.error("Falta token o ID de operario para enviar evento:", eventName);
                    showWorkerRequiredAlert();
                    return Promise.reject("Faltan datos para enviar evento");
                }
                if (eventName === 'inicio_trabajo' && !selectedShiftId) {
                    console.error("Falta ID de turno para enviar evento inicio_trabajo");
                    showShiftRequiredAlert();
                    return Promise.reject("Falta ID de turno");
                }

                const payload = { production_line_token: productionLineToken, event: eventName };
                if (currentWorker && currentWorker.id) {
                    payload.operator_id = currentWorker.id;
                }
                // <<< MODIFICADO: Enviar null si el valor es "especial" >>>
                if (eventName === 'inicio_trabajo' && selectedShiftId) {
                    payload.shift_id = (selectedShiftId === "especial") ? null : selectedShiftId;
                }

                const eventEndpoint = '/api/shift-event';
                const eventApiUrl = `${API_BASE_URL}${eventEndpoint}`;
                console.log(`Posting shift event: ${eventName} to ${eventApiUrl}`, payload);

                return fetch(eventApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify(payload) })
                .then(response => {
                    if (!response.ok) { return response.json().catch(() => null).then(errorBody => { console.error(`Error en API ${eventName}: ${response.status}`, errorBody); throw new Error(`Error ${response.status} al ${eventName}`); }); }
                    return response.text().then(text => text ? JSON.parse(text) : {});
                })
                .then(data => {
                    console.log(`Evento ${eventName} enviado con éxito. Respuesta:`, data);
                    // NO resetear tiempoPausaVal aquí, se actualizará desde shift-history
                    return data;
                })
                .catch(error => {
                    console.error(`Fallo al enviar evento ${eventName}:`, error);
                    if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo ${eventName}. ${error.message || ''}`, 'error'); }
                    else { alert(`Error al ${eventName}.`); }
                    throw error;
                });
            }

            // --- Función para actualizar UN círculo de progreso específico ---
            function updateProgress(indicatorElement, valueElement, percent) {
                // Asegurarse de que el porcentaje es un número válido entre 0 y 100
                const numericPercent = parseFloat(percent);
                const clampedPercent = isNaN(numericPercent) ? 0 : Math.max(0, Math.min(100, numericPercent));

                if (indicatorElement && valueElement) {
                    indicatorElement.style.setProperty('--progress-percent', clampedPercent);
                    valueElement.textContent = Math.round(clampedPercent); // Mostrar número redondeado
                } else {
                    // Ser más específico sobre qué elemento falta
                    if (!indicatorElement) console.error("Elemento indicador del círculo de progreso no encontrado.");
                    if (!valueElement) console.error("Elemento de valor del círculo de progreso no encontrado.");
                }
            }

            // --- ELIMINADA: Función fetchProgressData ---

            // --- Inicializar Select2 ---
            workerSelect.select2({ placeholder: "Selecciona un operario...", allowClear: true, language: "es" });

            // --- Función para cargar operarios ---
            function loadWorkers() {
                // ... (Sin cambios) ...
                const workersEndpoint = '/api/workers/list-all2';
                const apiUrl = `${API_BASE_URL}${workersEndpoint}`;
                console.log("Fetching workers...");
                fetch(apiUrl)
                    .then(response => response.ok ? response.json() : Promise.reject(`HTTP error! status: ${response.status}`))
                    .then(data => {
                        workerSelect.empty();
                        workerSelect.append(new Option("Selecciona un operario...", "", true, true));
                        if (data && Array.isArray(data.operators) && data.operators.length > 0) {
                            data.operators.forEach(worker => { if (worker && typeof worker.id !== 'undefined' && typeof worker.name !== 'undefined') { workerSelect.append(new Option(worker.name, worker.id)); } });
                        } else { workerSelect.append(new Option("No se encontraron operarios", "", false, true)); }
                        if (currentWorker) { workerSelect.val(currentWorker.id).trigger('change.select2'); }
                        else { workerSelect.val(null).trigger('change'); }
                        console.log("Worker list reloaded.");
                    })
                    .catch(error => { console.error('Error fetching workers:', error); workerSelect.empty().append(new Option("Error al cargar operarios", "", true, true)); if (typeof Swal === 'function') Swal.fire('Error', 'No se pudo cargar la lista de operarios.', 'error'); });
            }

            // --- Función para cargar y mostrar turnos ---
            async function loadAndShowShifts() {
                if (!productionLineToken) {
                    console.error("No hay token para cargar turnos.");
                    return Promise.reject("No hay token");
                }
                const shiftsEndpoint = `/api/shift-lists?token=${productionLineToken}`;
                const shiftsApiUrl = `${API_BASE_URL}${shiftsEndpoint}`;
                console.log("Fetching shifts from:", shiftsApiUrl);

                try {
                    const response = await fetch(shiftsApiUrl);
                    if (!response.ok) {
                        throw new Error(`Error ${response.status} al cargar turnos`);
                    }
                    const shifts = await response.json();

                    shiftSelect.empty();
                    shiftSelect.append(new Option("Selecciona un turno...", "", true, true));

                    if (shifts && Array.isArray(shifts) && shifts.length > 0) {
                        shifts.forEach(shift => {
                            if (shift && typeof shift.id !== 'undefined' && shift.start && shift.end) {
                                const startTime = shift.start.substring(0, 5);
                                const endTime = shift.end.substring(0, 5);
                                const optionText = `Turno ${startTime} - ${endTime}`;
                                shiftSelect.append(new Option(optionText, shift.id));
                            }
                        });
                    } else {
                        console.warn("No se encontraron turnos o la respuesta no es válida.");
                        shiftSelect.append(new Option("No hay turnos disponibles", "", false, true));
                    }

                    // <<< MODIFICADO: Añadir la opción "Especial" con valor "especial" >>>
                    shiftSelect.append(new Option("Especial", "especial"));
                    console.log("Added 'Especial' shift option with value 'especial'.");

                    shiftSelectContainer.removeClass('hidden');
                    return true; // Indicar que se cargaron turnos (aunque sea solo el especial)

                } catch (error) {
                    console.error('Error fetching shifts:', error);
                    if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo cargar la lista de turnos. ${error.message || ''}`, 'error'); }
                    else { alert('Error al cargar turnos.'); }
                    shiftSelectContainer.addClass('hidden');
                    return Promise.reject(error);
                }
            }


            // --- Función para resetear selección de turno ---
            function resetShiftSelection() {
                // ... (Sin cambios) ...
                selectedShiftId = null;
                potentialNewWorker = null;
                shiftSelect.val("");
                if (!shiftSelectContainer.hasClass('hidden')) {
                    shiftSelectContainer.addClass('hidden');
                    console.log("Shift selection reset and hidden.");
                } else {
                    console.log("Shift selection reset.");
                }
            }

            // --- Función para resetear la barra de progreso inferior ---
            function resetShiftProgressBar() {
                 // ... (Sin cambios, ya incluía el reset de shiftButtonPauseBar) ...
                 shiftStartTimeLabel.text("HORA INICIO");
                 shiftEndTimeLabel.text("HORA FIN");
                 shiftInfoText.text("SIN DATOS");
                 shiftDelayBar.css('width', '0%').attr('title', '');
                 shiftPauseBar.css('width', '0%').attr('title', '');
                 shiftButtonPauseBar.css('width', '0%').attr('title', '');
                 shiftSlowBar.css('width', '0%').attr('title', '');
                 shiftLateBar.css('width', '0%').attr('title', '');
                 shiftProgressBar.css('width', '0%').attr('title', '');
                 progressBarContainer.attr('title', '');
                 console.log("Shift progress bar reset.");
            }

            // --- Pausar/Reanudar polling al abrir/cerrar Select2 de Operarios ---
            workerSelect.on('select2:opening', function (e) {
                isSelectOpen = true;
                // Detener ambos timers
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; console.log('Shift history refresh PAUSED (worker select open).'); }
                if (orderStatsTimeoutId) { clearTimeout(orderStatsTimeoutId); orderStatsTimeoutId = null; console.log('Order stats refresh PAUSED (worker select open).'); }
            });
             workerSelect.on('select2:close', function (e) {
                 isSelectOpen = false;
                 console.log('Worker Select2 closed, attempting to restart refreshes.');
                 // Reanudar ambos timers si es apropiado
                 if (productionLineToken && !isProcessingLogin) {
                     if (!shiftHistoryTimeoutId) {
                         console.log('Restarting shift history refresh after worker select close.');
                         fetchLastShiftHistory(productionLineToken);
                     }
                     if (!orderStatsTimeoutId) {
                         console.log('Restarting order stats refresh after worker select close.');
                         fetchOrderStats(productionLineToken);
                     }
                 } else {
                     console.log(`Refresh restart skipped (processing: ${isProcessingLogin})`);
                 }
             });

              // --- Función para actualizar botones de acción ---
              function updateActionButtons(type, action) {
                  // ... (Sin cambios) ...
                  console.log("Updating buttons for state:", type, action);
                  const buttons = actionButtonsContainer.querySelectorAll('button.action-button');
                  buttons.forEach(btn => btn.classList.add('hidden'));

                  if (type === 'shift' && action === 'start') {
                      $('#start-pause-button').removeClass('hidden');
                      $('#end-shift-button').removeClass('hidden');
                      $('#pause-notification').addClass('hidden');
                      console.log("Buttons: Start Pause, End Shift");
                  } else if (type === 'stop' && action === 'start') {
                      $('#resume-button').removeClass('hidden');
                      $('#end-pause-button').removeClass('hidden');
                      $('#pause-notification').removeClass('hidden');
                       console.log("Buttons: Resume, End Pause");
                  } else if (type === 'shift' && action === 'end') {
                      $('#start-shift-button').removeClass('hidden');
                      $('#pause-notification').addClass('hidden');
                       console.log("Buttons: Start Shift");
                  } else if (type === 'stop' && action === 'end') {
                      $('#start-pause-button').removeClass('hidden');
                      $('#end-shift-button').removeClass('hidden');
                      $('#pause-notification').addClass('hidden');
                       console.log("Buttons: Start Pause, End Shift (after pause end)");
                  } else {
                      $('#start-shift-button').removeClass('hidden');
                      $('#pause-notification').addClass('hidden');
                       console.log("Buttons: Start Shift (Default/Unknown)");
                  }
              }

               // --- Añadir listeners genéricos a los botones de acción ---
               actionButtonsContainer.addEventListener('click', function(event) {
                   // ... (Lógica interna sin cambios, pero el finally ahora reinicia ambos fetch) ...
                   const button = event.target.closest('button.action-button');
                   if (!button) return;
                   const actionType = button.dataset.actionType;
                   let actionDescription = "realizar esta acción";
                   let eventName = null;

                   if (actionType === 'start-shift') {
                       // Lógica especial para start-shift manejada en los 'change' de los selects
                       console.log("Start shift button clicked, initiating worker/shift selection process.");
                       if (!currentWorker && selectContainer.is(':visible')) {
                            if (typeof Swal === 'function') { Swal.fire({ icon: 'info', title: 'Selecciona Operario', text: 'Por favor, selecciona tu nombre en la lista para iniciar el turno.', confirmButtonColor: '#3085d6' }); }
                            else { alert('Por favor, selecciona tu nombre en la lista para iniciar el turno.'); }
                       } else if (currentWorker) {
                            if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Turno ya iniciado', text: `El turno ya está iniciado para ${currentWorker.name}. Finaliza el turno actual si quieres empezar uno nuevo.`, confirmButtonColor: '#3085d6' }); }
                            else { alert(`El turno ya está iniciado para ${currentWorker.name}.`); }
                       }
                       return;
                   }

                   switch (actionType) {
                       case 'start-pause': actionDescription = "iniciar una parada"; eventName = "inicio_pausa"; break;
                       case 'resume-pause': actionDescription = "reanudar la tarea"; eventName = "final_pausa"; break;
                       case 'end-shift': actionDescription = "finalizar el turno/tarea"; eventName = "final_trabajo"; break;
                       case 'end-pause': actionDescription = "finalizar la parada"; eventName = "final_pausa"; break;
                   }
                   if (!eventName) { console.error("Tipo de acción desconocida:", actionType); return; }
                   if (actionType !== 'end-shift' && !currentWorker) { showWorkerRequiredAlert(); return; }

                   showActionConfirmation(actionDescription, () => {
                        // Detener ambos timers antes de la acción
                        if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                        if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                        isProcessingLogin = true;
                        console.log(`DEBUG: Processing ${eventName} START, refreshes blocked.`);

                        postShiftEvent(eventName)
                           .catch(err => { console.error(`Error en la acción ${actionType} (API):`, err); })
                           .finally(() => {
                               isProcessingLogin = false;
                               console.log(`DEBUG: Processing ${eventName} END, refreshes unblocked.`);
                               // Reanudar ambos timers
                               if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                               if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                               fetchLastShiftHistory(productionLineToken);
                               fetchOrderStats(productionLineToken);
                           });
                   });
               });

               // --- Función para procesar datos del historial de turno (API shift-history) ---
               function processShiftData(shiftData) {
                   // ... (Actualiza estado botones, operario, y barra de progreso) ...
                   let operator = null; let type = null; let action = null;
                   let shiftList = null; let eventCreatedAt = null;
                   let totalPauseDurationSeconds = 0;

                   let previousState = {...currentShiftState};
                   if (shiftData && shiftData.data) {
                       operator = shiftData.data.operator; type = shiftData.data.type; action = shiftData.data.action;
                       shiftList = shiftData.data.shift_list; eventCreatedAt = shiftData.shift_start_date;
                       totalPauseDurationSeconds = shiftData.total_pause_duration_seconds || 0;
                   }
                   else if (shiftData === null) { type = 'shift'; action = 'end'; console.log("No shift data received (or 404), assuming shift ended."); }

                   // Actualizar el span de Tiempo Pausa con el valor de ESTA API (shift-history)
                   const totalPauseMs = totalPauseDurationSeconds * 1000;
                   const formattedPause = formatDuration(totalPauseMs);
                   tiempoPausaVal.text(formattedPause); // Actualizar UI con valor de shift-history

                   const isShiftEnded = (type === 'shift' && action === 'end');
                   const isShiftActive = (type === 'shift' && action === 'start') || (type === 'stop' && action === 'end');
                   const isPaused = (type === 'stop' && action === 'start');

                   // Actualizar botones
                   if (!previousState.type || previousState.type !== type || previousState.action !== action) {
                       currentShiftState = { type, action }; console.log("Processing shift data. New state:", currentShiftState); updateActionButtons(type, action);
                   } else { console.log("Shift state unchanged:", currentShiftState); updateActionButtons(currentShiftState.type, currentShiftState.action); }

                   // Actualizar UI Operario/Selectores
                   // ... (lógica de visibilidad de selectores sin cambios) ...
                    if (isShiftEnded || (!operator && currentWorker) || (operator && !currentWorker) || (!operator && !currentWorker)) {
                       if (!isProcessingLogin) { resetShiftSelection(); }
                   }
                   if (isShiftEnded && !isProcessingLogin) {
                       if (currentWorker) { console.log("Shift ended, logging out current worker:", currentWorker.name); currentWorker = null; }
                       displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden'); workerSelect.val(null).trigger('change.select2');
                   } else if (operator && !isProcessingLogin) {
                       if (!currentWorker || currentWorker.id != operator.id) { console.log("Operator found in API. Auto-displaying/updating:", operator.name); currentWorker = { id: operator.id, name: operator.name }; selectedWorkerInfo.text(currentWorker.name); workerSelect.val(currentWorker.id).trigger('change.select2'); }
                       workerLabel.addClass('hidden'); selectContainer.addClass('hidden'); displayContainer.removeClass('hidden');
                   } else if (!operator && currentWorker && !isProcessingLogin) {
                       console.warn("No operator in API, but worker logged in locally. Forcing local logout."); currentWorker = null;
                       displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden'); workerSelect.val(null).trigger('change.select2');
                   } else if (!operator && !currentWorker && !isProcessingLogin) {
                       if (selectContainer.hasClass('hidden')) { console.log("No worker manually logged in and no operator in API. Ensuring selector is visible."); displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden'); workerSelect.val(null).trigger('change.select2'); }
                   }


                   // --- Actualizar Barra de Progreso Inferior ---
                   // Esta parte AHORA usa los valores de los SPANs, que son actualizados
                   // por processShiftData (para tiempoPausaVal) y processOrderStats (para los otros)
                   if ((isShiftActive || isPaused) && eventCreatedAt && shiftList && shiftList.start && shiftList.end) {
                       // ... (cálculo de horas y duración total del turno sin cambios) ...
                        const eventStartTimeStr = formatTime(eventCreatedAt);
                       const shiftStartTimeStr = formatTime(shiftList.start);
                       const shiftEndTimeStr = formatTime(shiftList.end);
                       shiftStartTimeLabel.text(`INICIO: ${eventStartTimeStr}`);
                       shiftEndTimeLabel.text(`FIN TURNO: ${shiftEndTimeStr}`);
                       shiftInfoText.text(`TURNO: ${shiftStartTimeStr} - ${shiftEndTimeStr}`);

                       try {
                           // LEER los valores ACTUALES de los spans (que fueron actualizados por las APIs)
                           const pauseTimeMs = parseDuration(tiempoParadaVal.text()); // 'Tiempo en Parada' (Actualizado por order-stats)
                           const slowTimeMs = parseDuration(tiempoLentoVal.text());   // 'Tiempo Lento' (Actualizado por order-stats)
                           const prepTimeMs = parseDuration(tiempoPreparacionVal.text()); // 'Tiempo Preparacion' (Actualizado por order-stats) <<< NUEVO
                           const buttonPauseTimeMs = parseDuration(tiempoPausaVal.text()); // 'Tiempo Pausa Botones' (Actualizado por shift-history)

                           console.log(`Progress Bar Calc using (ms) - Pause: ${pauseTimeMs}, Button Pause: ${buttonPauseTimeMs}, Slow: ${slowTimeMs}, Prep: ${prepTimeMs}`);

                           // ... (resto del cálculo de la barra de progreso sin cambios lógicos,
                           //      simplemente usará los nuevos valores leídos de los spans) ...
                            const now = new Date(); const eventStartDateTime = new Date(eventCreatedAt);
                           const [startHours, startMinutes] = shiftStartTimeStr.split(':').map(Number); const [endHours, endMinutes] = shiftEndTimeStr.split(':').map(Number);
                           let shiftStartDateTime = new Date(eventStartDateTime); shiftStartDateTime.setHours(startHours, startMinutes, 0, 0);
                           let shiftEndDateTime = new Date(eventStartDateTime); shiftEndDateTime.setHours(endHours, endMinutes, 0, 0);
                           if (shiftEndDateTime <= shiftStartDateTime) { shiftEndDateTime.setDate(shiftEndDateTime.getDate() + 1); }
                           if (eventStartDateTime > shiftEndDateTime) { shiftStartDateTime.setDate(shiftStartDateTime.getDate() -1); shiftEndDateTime.setDate(shiftEndDateTime.getDate() -1); }

                           const totalShiftDurationMs = shiftEndDateTime.getTime() - shiftStartDateTime.getTime();
                           let actualStartDelayMs = eventStartDateTime.getTime() - shiftStartDateTime.getTime();
                           let elapsedSinceActualStartMs = now.getTime() - eventStartDateTime.getTime();
                           let remainingMs = shiftEndDateTime.getTime() - now.getTime();

                           actualStartDelayMs = Math.max(0, actualStartDelayMs); elapsedSinceActualStartMs = Math.max(0, elapsedSinceActualStartMs);
                           remainingMs = Math.max(0, remainingMs);

                           let delayPercentage = 0;
                           let pausePercentage = 0; // Para 'Tiempo en Parada' (leído de span)
                           let buttonPausePercentage = 0; // Para 'Tiempo Pausa' (leído de span)
                           let slowPercentage = 0; // Para 'Tiempo Lento' (leído de span)
                           let prepPercentage = 0; // Para 'Tiempo Preparacion' (leído de span) <<< NUEVO
                           let productivePercentage = 0;

                           let formattedDelay = '';
                           let formattedPause = formatDuration(pauseTimeMs);
                           let formattedButtonPause = formatDuration(buttonPauseTimeMs);
                           let formattedSlow = formatDuration(slowTimeMs);
                           let formattedPrep = formatDuration(prepTimeMs); // <<< NUEVO
                           let formattedProductive = '';
                           let formattedRemaining = formatDuration(remainingMs);

                           if (totalShiftDurationMs > 0) {
                               if (actualStartDelayMs > 0) { delayPercentage = (actualStartDelayMs / totalShiftDurationMs) * 100; formattedDelay = formatDuration(actualStartDelayMs); }
                               pausePercentage = (pauseTimeMs / totalShiftDurationMs) * 100;
                               buttonPausePercentage = (buttonPauseTimeMs / totalShiftDurationMs) * 100;
                               slowPercentage = (slowTimeMs / totalShiftDurationMs) * 100;
                               prepPercentage = (prepTimeMs / totalShiftDurationMs) * 100; // <<< NUEVO

                               // Tiempo productivo: Tiempo total transcurrido MENOS todas las pausas/retrasos leídos
                               // <<< MODIFICADO: Restar también prepTimeMs >>>
                               let productiveElapsedMs = elapsedSinceActualStartMs - pauseTimeMs - buttonPauseTimeMs - slowTimeMs - prepTimeMs;
                               productiveElapsedMs = Math.max(0, productiveElapsedMs);
                               formattedProductive = formatDuration(productiveElapsedMs);
                               productivePercentage = (productiveElapsedMs / totalShiftDurationMs) * 100;

                               // Clamping para asegurar que no exceda 100%
                               // <<< MODIFICADO: Incluir prepPercentage >>>
                               delayPercentage = Math.max(0, Math.min(100, delayPercentage));
                               pausePercentage = Math.max(0, Math.min(100 - delayPercentage, pausePercentage));
                               buttonPausePercentage = Math.max(0, Math.min(100 - delayPercentage - pausePercentage, buttonPausePercentage));
                               slowPercentage = Math.max(0, Math.min(100 - delayPercentage - pausePercentage - buttonPausePercentage, slowPercentage));
                               prepPercentage = Math.max(0, Math.min(100 - delayPercentage - pausePercentage - buttonPausePercentage - slowPercentage, prepPercentage));
                               productivePercentage = Math.max(0, Math.min(100 - delayPercentage - pausePercentage - buttonPausePercentage - slowPercentage - prepPercentage, productivePercentage));

                               console.log(`Percentages - Delay: ${delayPercentage.toFixed(2)}%, Pause: ${pausePercentage.toFixed(2)}%, Button Pause: ${buttonPausePercentage.toFixed(2)}%, Slow: ${slowPercentage.toFixed(2)}%, Prep: ${prepPercentage.toFixed(2)}%, Productive: ${productivePercentage.toFixed(2)}%`);

                               // Actualizar los anchos de las barras
                               // <<< MODIFICADO: Cambiar late por prep >>>
                               shiftDelayBar.css('width', `${delayPercentage}%`).attr('title', delayPercentage > 0 ? `Retraso inicio turno: ${formattedDelay}` : '');
                               shiftPauseBar.css('width', `${pausePercentage}%`).attr('title', `Tiempo Parada: ${formattedPause}`);
                               shiftButtonPauseBar.css('width', `${buttonPausePercentage}%`).attr('title', `Tiempo Pausa (Botón): ${formattedButtonPause}`);
                               shiftSlowBar.css('width', `${slowPercentage}%`).attr('title', `Tiempo Lento: ${formattedSlow}`);
                               shiftLateBar.css('width', `${prepPercentage}%`).attr('title', `Tiempo Preparación: ${formattedPrep}`); // Usamos la barra 'late' para 'prep'
                               shiftProgressBar.css('width', `${productivePercentage}%`).attr('title', `Tiempo Productivo: ${formattedProductive}`);
                               progressBarContainer.attr('title', `Faltante: ${formattedRemaining}`);

                           } else { console.warn("Total shift duration is zero or negative."); resetShiftProgressBar(); }
                       } catch(e) { console.error("Error calculating progress:", e); resetShiftProgressBar(); }
                   } else { resetShiftProgressBar(); }
               } // Fin de processShiftData

            // --- Función para obtener el último historial de turno (API shift-history) ---
            function fetchLastShiftHistory(token) {
                if (isSelectOpen || isProcessingLogin) {
                    console.log(`Shift history refresh SKIPPED (Select open: ${isSelectOpen}, Processing login: ${isProcessingLogin})`);
                    // Reintentar después del intervalo si el timer no está activo
                    if (!shiftHistoryTimeoutId) { shiftHistoryTimeoutId = setTimeout(() => fetchLastShiftHistory(token), REFRESH_INTERVAL_MS); }
                    return;
                }
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; } // Limpiar timer anterior
                if (!token) { console.error("Token no encontrado para shift-history."); processShiftData(null); return; } // No continuar si no hay token

                const historyEndpoint = `/api/shift-history/production-line/${token}/last`;
                const historyApiUrl = `${API_BASE_URL}${historyEndpoint}`;

                fetch(historyApiUrl)
                    .then(response => { if (!response.ok) { if (response.status === 404) { console.log("No shift history found (404). Treating as 'shift ended'."); return null; } throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); })
                    .then(data => { processShiftData(data); }) // Procesar los datos recibidos
                    .catch(error => { console.error('Error fetching shift history:', error); processShiftData(null); }) // Procesar como turno finalizado en caso de error
                    .finally(() => {
                        // Volver a programar la próxima llamada solo si no estamos bloqueados
                        if (token && !isSelectOpen && !isProcessingLogin) {
                            shiftHistoryTimeoutId = setTimeout(() => fetchLastShiftHistory(token), REFRESH_INTERVAL_MS);
                        } else {
                            console.log("Shift history refresh loop paused.");
                        }
                    });
            }

            // <<< ============================================================= >>>
            // <<< NUEVA SECCIÓN: Funciones para API /api/order-stats           >>>
            // <<< ============================================================= >>>

            // --- Función para procesar datos de estadísticas de orden (API order-stats) ---
            function processOrderStats(statsData) {
                let oeeOrdenValue = 0; // Valor por defecto para OEE Orden

                if (!statsData) {
                    console.warn("No order stats data received. Resetting stats and OEEs.");
                    // Si no hay datos de orden, resetear los valores asociados
                    tiempoParadaVal.text('00:00:00');
                    tiempoLentoVal.text('00:00:00');
                    tiempoPreparacionVal.text('00:00:00');
                    unidadesHechasVal.text('0');
                    unidadesPendientesVal.text('0');
                    unidadesRetrasadasVal.text('0');
                    // Resetear OEE Orden y OEE Máquina a 0
                    updateProgress(progressIndicator, progressValue, 0); // Círculo 1 (OEE Orden)
                    updateProgress(oeeMaquinaIndicator, oeeMaquinaValue, 0); // Círculo 2 (OEE Máquina)
                    return;
                }

                try {
                    // Calcular Tiempo en Parada Total (down_time + production_stops_time)
                    const downTimeSec = parseFloat(statsData.down_time) || 0;
                    const prodStopTimeSec = parseFloat(statsData.production_stops_time) || 0;
                    const totalStopTimeSec = downTimeSec + prodStopTimeSec;
                    const totalStopTimeMs = totalStopTimeSec * 1000;
                    tiempoParadaVal.text(formatDuration(totalStopTimeMs));

                    // Obtener Tiempo Lento
                    const slowTimeSec = parseFloat(statsData.slow_time) || 0;
                    const slowTimeMs = slowTimeSec * 1000;
                    tiempoLentoVal.text(formatDuration(slowTimeMs));

                    // --- Obtener Tiempo Preparación ---
                    const prepTimeSec = parseFloat(statsData.prepair_time) || 0;
                    const prepTimeMs = prepTimeSec * 1000;
                    tiempoPreparacionVal.text(formatDuration(prepTimeMs));

                    // --- Obtener Unidades ---
                    unidadesHechasVal.text(statsData.units_made !== null ? statsData.units_made : '0');
                    unidadesPendientesVal.text(statsData.units_pending !== null ? statsData.units_pending : '0');
                    unidadesRetrasadasVal.text(statsData.units_delayed !== null ? statsData.units_delayed : '0');


                    // --- Procesar OEE Orden (Círculo 1) ---
                    if (statsData.oee !== null && statsData.oee !== undefined) {
                        const parsedOee = parseFloat(statsData.oee);
                        if (!isNaN(parsedOee)) {
                            oeeOrdenValue = parsedOee;
                        } else {
                            console.warn(`Invalid OEE Orden value received: ${statsData.oee}. Using 0.`);
                        }
                    } else {
                         console.warn("OEE Orden value is null or undefined. Using 0.");
                    }
                    updateProgress(progressIndicator, progressValue, oeeOrdenValue); // Actualizar Círculo 1

                    // --- OEE Máquina (Círculo 2) - Fijado a 0 por ahora ---
                    updateProgress(oeeMaquinaIndicator, oeeMaquinaValue, 0); // <<< FIJADO A 0
                    // --- FIN Procesamiento OEEs ---

                } catch (error) {
                    console.error("Error processing order stats data:", error, statsData);
                    // Resetear valores en caso de error de procesamiento
                    tiempoParadaVal.text('00:00:00');
                    tiempoLentoVal.text('00:00:00');
                    tiempoPreparacionVal.text('00:00:00');
                    unidadesHechasVal.text('0');
                    unidadesPendientesVal.text('0');
                    unidadesRetrasadasVal.text('0');
                    updateProgress(progressIndicator, progressValue, 0); // Resetear Círculo 1
                    updateProgress(oeeMaquinaIndicator, oeeMaquinaValue, 0); // Resetear Círculo 2
                }
            }

            // --- Función para obtener estadísticas de la orden (API order-stats) ---
            function fetchOrderStats(token) {
                if (isSelectOpen || isProcessingLogin) {
                    console.log(`Order stats refresh SKIPPED (Select open: ${isSelectOpen}, Processing login: ${isProcessingLogin})`);
                    // Reintentar después del intervalo si el timer no está activo
                    if (!orderStatsTimeoutId) { orderStatsTimeoutId = setTimeout(() => fetchOrderStats(token), REFRESH_INTERVAL_MS); }
                    return;
                }
                 if (orderStatsTimeoutId) { clearTimeout(orderStatsTimeoutId); orderStatsTimeoutId = null; } // Limpiar timer anterior
                if (!token) {
                    console.warn("Token no encontrado para order-stats. Resetting stats.");
                    processOrderStats(null); // Resetear stats si no hay token
                    return;
                } // No hacer nada si no hay token

                const statsEndpoint = `/api/order-stats?token=${token}`;
                const statsApiUrl = `${API_BASE_URL}${statsEndpoint}`;

                fetch(statsApiUrl)
                    .then(response => {
                        if (!response.ok) {
                             // Si no se encuentra (404), no es necesariamente un error grave, puede que no haya orden activa
                             if (response.status === 404) {
                                 console.log("No active order stats found (404). Resetting stats.");
                                 return null; // Devolver null para indicar que no hay datos
                             }
                             throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        processOrderStats(data); // Procesar los datos (o null si fue 404)
                    })
                    .catch(error => {
                        console.error('Error fetching order stats:', error);
                        // En caso de error, resetear los valores que actualiza esta API
                        processOrderStats(null); // Llamar a processOrderStats con null para resetear
                    })
                    .finally(() => {
                        // Volver a programar la próxima llamada solo si no estamos bloqueados
                        if (token && !isSelectOpen && !isProcessingLogin) {
                            orderStatsTimeoutId = setTimeout(() => fetchOrderStats(token), REFRESH_INTERVAL_MS);
                        } else {
                            console.log("Order stats refresh loop paused.");
                        }
                    });
            }
            // <<< ============================================================= >>>
            // <<< FIN NUEVA SECCIÓN                                             >>>
            // <<< ============================================================= >>>


            // --- Función para obtener token de URL ---
            function getTokenFromUrl() {
                const params = new URLSearchParams(window.location.search);
                return params.get('token');
            }

            // --- Flujo Inicial ---
            productionLineToken = getTokenFromUrl();
            loadWorkers();
            fetchLastShiftHistory(productionLineToken); // Iniciar polling estado turno
            fetchOrderStats(productionLineToken);       // Iniciar polling stats orden
            // ELIMINADO: fetchProgressData();

            // --- Manejar selección manual de operario ---
            workerSelect.on('change', async function(e) {
                // ... (Lógica sin cambios, pero el finally ahora reinicia ambos fetch) ...
                console.log("DEBUG: Worker Select 'change' event fired!");
                const selectedId = $(this).val();
                resetShiftSelection();
                if (!selectedId || selectedId === "") {
                    // Si se deselecciona el operario, PARAR los timers y resetear estado
                    potentialNewWorker = null;
                    isProcessingLogin = false; // Asegurar que no esté bloqueado
                    if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null;
                    if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId); orderStatsTimeoutId = null;
                    console.log("DEBUG: Worker deselected. Refreshes stopped.");
                    // Podríamos incluso forzar un fetch del estado sin operario si fuera necesario
                    // fetchLastShiftHistory(productionLineToken);
                    // fetchOrderStats(productionLineToken);
                    return;
                }
                const selectedName = $(this).find('option:selected').text();
                if (currentWorker && currentWorker.id != selectedId) {
                    // ... (Mostrar alerta de cambio de operario) ...
                    if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Cambio de Operario', text: `Para iniciar sesión como ${selectedName}, primero debes finalizar el turno del operario actual (${currentWorker.name}). Usa el botón (X) o el botón 'Finalizar Turno'.`, confirmButtonColor: '#3085d6' }); } else { alert(`Para iniciar sesión como ${selectedName}, primero debes finalizar el turno del operario actual (${currentWorker.name}). Usa el botón (X) o el botón 'Finalizar Turno'.`); }
                    workerSelect.val(currentWorker.id).trigger('change.select2');
                    return;
                }
                if (currentWorker && currentWorker.id == selectedId) { return; }

                potentialNewWorker = { id: selectedId, name: selectedName };
                console.log("DEBUG: Potential worker selected:", potentialNewWorker.name);

                // Bloquear ambos refrescos
                isProcessingLogin = true;
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; }
                if (orderStatsTimeoutId) { clearTimeout(orderStatsTimeoutId); orderStatsTimeoutId = null; }
                console.log("DEBUG: Processing login START, refreshes blocked.");

                try {
                    const shiftsLoaded = await loadAndShowShifts();
                    if (!shiftsLoaded) {
                        // ... (resetear selección) ...
                        workerSelect.val(null).trigger('change.select2'); potentialNewWorker = null;
                        isProcessingLogin = false;
                        console.log("DEBUG: Processing login END (no shifts), refreshes unblocked.");
                        // Reanudar ambos timers
                        if (!shiftHistoryTimeoutId) fetchLastShiftHistory(productionLineToken);
                        if (!orderStatsTimeoutId) fetchOrderStats(productionLineToken);
                    } else {
                        console.log("Shifts loaded, waiting for shift selection. Refreshes remain blocked.");
                    }
                } catch (error) {
                    // ... (resetear selección) ...
                     workerSelect.val(null).trigger('change.select2'); potentialNewWorker = null;
                    isProcessingLogin = false;
                    console.log("DEBUG: Processing login END (shift load error), refreshes unblocked.");
                    // Reanudar ambos timers
                    if (!shiftHistoryTimeoutId) fetchLastShiftHistory(productionLineToken);
                    if (!orderStatsTimeoutId) fetchOrderStats(productionLineToken);
                }
            });

            // --- Manejar selección de turno ---
            shiftSelect.on('change', async function(e) {
                 // ... (Lógica sin cambios internos, pero el finally ahora reinicia ambos fetch) ...
                console.log("DEBUG: Shift Select 'change' event fired!");
                selectedShiftId = $(this).val();
                if (!selectedShiftId || selectedShiftId === "") {
                    console.log("DEBUG: Shift selection cleared or placeholder selected.");
                    selectedShiftId = null;
                    return; // No hacer nada más, esperar a que elija un turno válido
                }
                if (!potentialNewWorker) {
                    console.error("Error: Shift selected but no potential worker stored.");
                    workerSelect.val(null).trigger('change.select2'); resetShiftSelection();
                    isProcessingLogin = false;
                    if (!shiftHistoryTimeoutId) fetchLastShiftHistory(productionLineToken);
                    if (!orderStatsTimeoutId) fetchOrderStats(productionLineToken);
                    return;
                }

                const selectedShiftText = $(this).find('option:selected').text();
                let confirmed = false;

                if (typeof Swal === 'function') {
                    const swalResult = await Swal.fire({
                        title: 'Confirmar Inicio de Turno',
                        html: `Vas a iniciar sesión como <b>${potentialNewWorker.name}</b> en el <b>${selectedShiftText}</b>.<br>¿Estás seguro?`,
                        icon: 'question', showCancelButton: true, confirmButtonColor: '#3085d6',
                        cancelButtonColor: '#d33', confirmButtonText: 'Confirmar', cancelButtonText: 'Cancelar' });
                    confirmed = swalResult.isConfirmed;
                } else {
                    confirmed = confirm(`Vas a iniciar sesión como ${potentialNewWorker.name} en el ${selectedShiftText}. ¿Estás seguro?`);
                }

                try {
                    if (confirmed) {
                         console.log("DEBUG: Start shift CONFIRMED.");
                        currentWorker = potentialNewWorker;
                        potentialNewWorker = null;
                        selectedWorkerInfo.text(currentWorker.name);
                        workerLabel.addClass('hidden'); selectContainer.addClass('hidden'); displayContainer.removeClass('hidden');
                        if (typeof Swal === 'function') { Swal.fire({ title: 'Procesando...', allowOutsideClick: false, didOpen: () => Swal.showLoading() }); } else { alert('Procesando...'); }

                        try {
                            await postShiftEvent("inicio_trabajo");
                            if (typeof Swal === 'function' && Swal.isLoading()) { Swal.close(); }
                            resetShiftSelection(); // Ocultar selector turno
                            if (typeof Swal === 'function') { Swal.fire({ title: '¡Éxito!', text: `Turno iniciado untuk ${currentWorker.name}.`, icon: 'success', timer: 2500, timerProgressBar: true }); } else { alert('¡Éxito!'); }
                        } catch (error) {
                            console.error("DEBUG: Error during start shift API call:", error);
                            if (typeof Swal === 'function' && Swal.isLoading()) { Swal.close(); }
                            if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo iniciar el turno. ${error.message || ''}`, 'error'); } else { alert(`Error al iniciar turno. ${error.message || ''}`); }
                            // Revertir
                            currentWorker = null; selectedShiftId = null;
                            displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden');
                            workerSelect.val(null).trigger('change.select2');
                            resetShiftSelection();
                        }
                    } else {
                         console.log("DEBUG: Start shift CANCELLED by user.");
                        shiftSelect.val(""); selectedShiftId = null; // Resetear solo la selección de turno
                    }
                } finally {
                    // Desbloquear y reanudar timers SOLO si se confirmó (haya ido bien o mal la API)
                    if (confirmed) {
                        isProcessingLogin = false;
                        console.log("DEBUG: Processing login END (Shift selected/processed), refreshes unblocked.");
                        if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                        if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                        fetchLastShiftHistory(productionLineToken);
                        fetchOrderStats(productionLineToken);
                    } else {
                        // Si canceló, isProcessingLogin sigue true, timers parados
                        console.log("DEBUG: Shift selection cancelled, refreshes remain blocked until worker selection changes.");
                    }
                }
            });


               // --- Manejar clic en botón Logout (X) ---
               logoutButton.on('click', function() {
                   // ... (Lógica sin cambios, pero el finally ahora reinicia ambos fetch) ...
                   const logoutDescription = "finalizar el turno/tarea actual";
                   const eventName = "final_trabajo";
                   if (!currentWorker) {
                        console.log("Logout button clicked, but no worker seems active locally. Attempting API call anyway.");
                       if (typeof Swal === 'function') { Swal.fire({ icon: 'info', title: 'Finalizar Turno', text: 'Intentando finalizar cualquier turno activo...', confirmButtonColor: '#3085d6' }); } else { alert('Intentando finalizar...'); }
                    }

                   showActionConfirmation(logoutDescription, () => {
                       // Detener ambos timers
                       if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                       if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                       isProcessingLogin = true;
                       console.log("DEBUG: Processing final_trabajo START, refreshes blocked.");

                       postShiftEvent(eventName)
                           .then(() => { console.log("Logout API call successful."); })
                           .catch(err => { console.error("Logout failed during API call:", err); })
                           .finally(() => {
                               isProcessingLogin = false;
                               console.log("DEBUG: Processing final_trabajo END, refreshes unblocked.");
                               // Reanudar ambos timers
                               if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                               if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                               fetchLastShiftHistory(productionLineToken);
                               fetchOrderStats(productionLineToken);
                           });
                   });
               });

            // --- NUEVO: Manejar clic en botón Refrescar ---
            if (refreshButton) {
                refreshButton.addEventListener('click', function() {
                    console.log("Manual refresh triggered.");
                    if (typeof Swal === 'function') {
                        Swal.fire({ title: 'Refrescando...', timer: 500, didOpen: () => Swal.showLoading(), showConfirmButton: false });
                    } else {
                        alert("Refrescando datos...");
                    }
                    // Detener timers actuales para evitar llamadas duplicadas
                    if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                    if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                    // Forzar la ejecución inmediata de las funciones de fetch
                    fetchLastShiftHistory(productionLineToken);
                    fetchOrderStats(productionLineToken);
                });
            } else {
                console.error("Refresh button not found!");
            }

            // --- Lógica Kanban (Dragula) ---
            const columns = Array.from(document.querySelectorAll('.kanban-column'));
            if (columns.length === 0) { console.error("Error: No se encontraron columnas Kanban."); return; }
            let longPressTimer = null; let isTouchInteraction = false; let longPressTriggered = false; const longPressDelay = 500; let startX, startY; let currentCard = null;
            document.addEventListener('touchstart', handleTouchStart, { passive: false }); document.addEventListener('touchmove', handleTouchMove, { passive: false }); document.addEventListener('touchend', handleTouchEnd); document.addEventListener('touchcancel', handleTouchEnd);

            function handleTouchStart(e) {
                const card = e.target.closest('.kanban-card');
                if (!card) { isTouchInteraction = false; return; }
                currentCard = card;
                isTouchInteraction = true;
                longPressTriggered = false;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                clearTimeout(longPressTimer); // Limpiar timer anterior si existiera
                longPressTimer = setTimeout(() => {
                    if (!isTouchInteraction || !currentCard) return; // Verificar si aún es válido
                    console.log("Long press triggered!");
                    longPressTriggered = true;
                    currentCard.classList.add('long-press-ready');
                    if (navigator.vibrate) { navigator.vibrate(50); } // Vibración suave como feedback
                }, longPressDelay);
            }

            function handleTouchMove(e) {
                if (!isTouchInteraction || !currentCard) return;
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const deltaX = Math.abs(currentX - startX);
                const deltaY = Math.abs(currentY - startY);
                const moveThreshold = 10; // Píxeles de tolerancia antes de cancelar long press

                // Si no se ha disparado el long press y el dedo se mueve significativamente
                if (!longPressTriggered && (deltaX > moveThreshold || deltaY > moveThreshold)) {
                    console.log("Movement detected before long press, cancelling timer.");
                    clearTimeout(longPressTimer);
                    if(currentCard) currentCard.classList.remove('long-press-ready');
                    // No establecemos isTouchInteraction a false aquí, podría ser scroll
                }
            }

            function handleTouchEnd(e) {
                clearTimeout(longPressTimer); // Siempre limpiar el timer al levantar/cancelar
                if (currentCard) {
                    currentCard.classList.remove('long-press-ready'); // Quitar feedback visual
                }
                // Resetear variables de estado táctil
                // isTouchInteraction se maneja en Dragula para diferenciar click/drag
                // longPressTriggered se resetea en drop/cancel/dragend de Dragula
                currentCard = null;
            }

            const drake = dragula(columns, {
                moves: function (el, source, handle, sibling) {
                     // Permitir mover siempre con ratón
                     if (!isTouchInteraction) { return true; }
                     // En táctil, solo permitir si se activó el long press
                     return longPressTriggered;
                 },
                accepts: function (el, target, source, sibling) {
                     if (target.id === 'col-en-curso') {
                         // Permitir mover DENTRO de la columna "En Curso"
                         if (source.id === 'col-en-curso') return true;
                         // Si viene de otra columna y ya hay una tarjeta, no permitir
                         const cardsInTarget = target.querySelectorAll('.kanban-card:not(.gu-transit)').length; // Excluir la que se está moviendo
                         if (cardsInTarget > 0) {
                              if (typeof Swal === 'function') {
                                  Swal.fire({
                                      icon: 'warning', title: 'Movimiento no permitido',
                                      text: 'Solo puede haber una tarea en la columna "En Curso".',
                                      toast: true, position: 'top-end', showConfirmButton: false,
                                      timer: 3000, timerProgressBar: true
                                  });
                              } else {
                                   alert('Solo puede haber una tarea en la columna "En Curso".');
                              }
                              console.log("Drop rejected: 'En Curso' column already has a card.");
                              return false; // No permitir soltar
                         }
                     }
                     return true; // Permitir soltar por defecto en otras columnas
                 }
            });

            if (!drake) { console.error("Error: Falló la inicialización de Dragula."); return; }

            drake.on('drag', (el, source) => {
                console.log("Dragula event: drag (started)");
                // Validar si hay operario seleccionado ANTES de permitir el drag
                if (!currentWorker) {
                    console.log("Drag cancelled: No worker selected.");
                    drake.cancel(true); // Cancelar el drag
                    showWorkerRequiredAlert();
                    return;
                }
                if (el) el.classList.remove('long-press-ready'); // Quitar estilo long-press al empezar a arrastrar
                isTouchInteraction = false; // Resetear flag táctil al iniciar drag real
            });

            drake.on('drop', (el, target, source, sibling) => {
                console.log("Dragula event: drop");
                const sourceColumnName = source.dataset.columnName || source.id;
                const targetColumnName = target.dataset.columnName || target.id;
                const cardId = el.dataset.cardId;
                const cardTitleElement = el.querySelector('.font-semibold');
                const cardTitle = cardTitleElement ? cardTitleElement.innerText : `Tarjeta ${cardId}`;
                const message = `Moviste la tarjeta "${cardTitle}" de "${sourceColumnName}" a "${targetColumnName}".`;

                // TODO: Implementar la llamada a la API para registrar el movimiento Kanban
                console.log("TODO: Llamar API para registrar movimiento Kanban", {
                    card_id: cardId,
                    target_column: targetColumnName,
                    source_column: sourceColumnName,
                    operator_id: currentWorker ? currentWorker.id : null // Asegurarse de que currentWorker existe
                });

                // Mostrar notificación (simulada)
                if (typeof Swal === 'function') {
                    Swal.fire({ title: 'Movimiento Registrado (Simulado)', text: message, icon: 'success', timer: 2000, timerProgressBar: true, toast: true, position: 'top-end', showConfirmButton: false });
                } else {
                    alert(message);
                }
                longPressTriggered = false; // Resetear estado long-press
            });

            drake.on('cancel', (el, container, source) => {
                console.log("Dragula event: cancel");
                longPressTriggered = false;
                if (el) el.classList.remove('long-press-ready');
                 // Resetear estilos visuales de columnas si los hubiera
                 columns.forEach(col => col.classList.remove('bg-gray-300'));
            });

            drake.on('dragend', (el) => {
                console.log("Dragula event: dragend (finished, dropped or cancelled)");
                longPressTriggered = false;
                if (el) el.classList.remove('long-press-ready');
                 // Resetear estilos visuales de columnas si los hubiera
                 columns.forEach(col => col.classList.remove('bg-gray-300'));
                 isTouchInteraction = false; // Asegurar reset del flag táctil
            });

            drake.on('over', function (el, container) {
                container.classList.add('bg-gray-300'); // Resaltar columna destino
            });

            drake.on('out', function (el, container) {
                container.classList.remove('bg-gray-300'); // Quitar resaltado
            });

        // *** Fin de DOMContentLoaded ***
        });
    </script>

</body>
</html>
