<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Kanban - Ocupación y Botones</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <style>
        /* --- Fuentes y Body --- */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overscroll-behavior-y: contain;
            background-color: #f8fafc;
            color: #1e293b;
            line-height: 1.5;
        }
        /* --- Animación para el tiempo hasta finalización --- */
        @keyframes tiempoPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .tiempo-warning {
            animation: tiempoPulse 1.5s infinite;
            color: #f59e0b !important; /* Amber-500 */
        }
        
        .tiempo-danger {
            color: #dc2626 !important; /* Red-600 */
            font-weight: bold;
        }
        
        .panel-danger {
            background-color: rgba(254, 226, 226, 0.8) !important; /* Red-100 with opacity */
            border: 1px solid #f87171 !important; /* Red-400 */
        }
        
        /* --- Estilos Círculo de Progreso Dinámico (OEE) --- */
        .progress-circle {
            width: 160px;
            height: 160px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            background: conic-gradient(
                #4ade80 calc(var(--progress-percent, 0) * 1%),
                #e5e7eb 0
            );
            position: relative;
            font-size: 2.5rem;
            font-weight: 700;
            color: #16a34a;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            margin: 0 auto;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }

        .progress-circle::before {
            content: "";
            position: absolute;
            border-radius: 50%;
            inset: 10px;
            background: #fff;
            z-index: 1;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
        }
        .progress-circle > span {
             z-index: 2; position: relative;
        }

        /* --- Estilos Tarjeta Kanban Refactorizados --- */
        .container {
            max-width: 100%;
            padding: 0 1.5rem;
            margin: 0 auto;
        }
        
        @media (min-width: 1280px) {
            .container {
                max-width: 1280px;
            }
        }
        .kanban-card {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 0.75rem; /* Reducido de 1rem */
            margin-bottom: 0.5rem; /* Reducido de 0.75rem */
            cursor: move;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        }
        
        /* Eliminar todas las animaciones de las tarjetas */
        /* Mantener solo animaciones para tarjetas recién arrastradas */
        
        .card-just-moved {
            animation: highlightCard 0.8s ease;
            z-index: 10;
        }
        
        @keyframes highlightCard {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(59, 130, 246, 0); }
            30% { transform: scale(1.05); box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(59, 130, 246, 0); }
        }
        
        .kanban-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.05);
            border-color: currentColor; /* Usar el mismo color del borde pero más intenso */
            z-index: 5; /* Asegurar que la tarjeta aparezca por encima de otras al pasar el cursor */
        }
        /* Estilos de tarjetas que coinciden con los colores de las barras */
        #col-pendiente .kanban-card { background-color: #ffebeb; border-color: #ef4444; }
        #col-en-curso .kanban-card { background-color: #e6f0ff; border-color: #3b82f6; }
        #col-finalizadas .kanban-card { background-color: #e6faea; border-color: #22c55e; }
        #col-incidencias .kanban-card { background-color: #fef9e6; border-color: #eab308; }

        /* --- Estilos Etiquetas OPE --- */
         .ope-tag {
            display: inline-block; padding-left: 0.5rem; padding-right: 0.5rem;
            padding-top: 0.125rem; padding-bottom: 0.125rem; border-radius: 0.25rem;
            font-size: 0.75rem; font-weight: 500; margin-right: 0.25rem; margin-bottom: 0.25rem;
            line-height: 1;
        }
        .ope-pendiente { background-color: #fef08a; color: #a16207; }
        .ope-en-curso { background-color: #bfdbfe; color: #1e40af; }
        .ope-finalizada { background-color: #bbf7d0; color: #166534; }
        .ope-incidencia { background-color: #fecaca; color: #991b1b; }
        .ope-default { background-color: #e5e7eb; color: #374151; }

        /* --- Otros estilos --- */
        .kanban-column {
            background-color: #ffffff;
            padding: 1.25rem;
            border-radius: 0.75rem;
            min-height: 200px;
            max-height: 32rem;
            overflow-y: auto;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }
        
        .column-drop-target {
            border: 2px dashed #94a3b8;
            background-color: #f8fafc;
        }
        
        .kanban-column:hover {
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .kanban-title {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.75rem;
            margin-top: -0.25rem;
            text-align: center;
            padding: 0.25rem 0 0.15rem;
            position: relative;
            font-size: 1.1rem; /* Texto más grande */
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .column-counter {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 1.5rem; /* Más alto */
            min-width: 1.5rem; /* Más ancho */
            font-size: 0.9rem; /* Texto más grande */
            border-radius: 9999px;
            margin-left: 0.5rem;
            padding: 0 0.35rem; /* Más padding horizontal */
            background-color: #e5e7eb;
            color: #374151;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .counter-updated {
            animation: counterPulse 1s ease;
        }
        
        @keyframes counterPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.35); }
            100% { transform: scale(1); }
        }
        
        .kanban-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px; /* Reducido de 3px para un aspecto más fino */
            border-radius: 0;
        }
        
        /* Colores específicos para cada columna */
        #col-pendiente .kanban-title::after {
            background-color: #ef4444; /* Rojo */
        }
        #col-pendiente .column-counter { background-color: #fecaca; color: #991b1b; }
        
        #col-en-curso .kanban-title::after {
            background-color: #3b82f6; /* Azul */
        }
        #col-en-curso .column-counter { background-color: #bfdbfe; color: #1e40af; }
        
        #col-finalizadas .kanban-title::after {
            background-color: #22c55e; /* Verde */
        }
        #col-finalizadas .column-counter { background-color: #bbf7d0; color: #166534; }
        
        #col-incidencias .kanban-title::after {
            background-color: #eab308; /* Amarillo */
        }
        #col-incidencias .column-counter { background-color: #fef08a; color: #a16207; }
        .gu-mirror {
            padding: 0.75rem; border-radius: 0.375rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); border-width: 1px; font-size: 0.875rem; line-height: 1.25rem; border-style: solid;
            opacity: 0.9 !important; position: fixed !important; cursor: grabbing !important; z-index: 9999 !important; touch-action: none; margin-bottom: 0;
            transform: rotate(1deg) scale(1.02);
            transition: transform 0.1s ease;
        }
        #col-pendiente .gu-mirror { background-color: #fefce8; border-color: #fde68a; }
        #col-en-curso .gu-mirror { background-color: #eff6ff; border-color: #bfdbfe; }
        #col-finalizadas .gu-mirror { background-color: #f9fafb; border-color: #e5e7eb; }
        #col-incidencias .gu-mirror { background-color: #fef2f2; border-color: #fecaca; }
        .gu-transit { 
            opacity: 0.3; 
            background-color: #f3f4f6 !important; 
            border: 2px dashed #d1d5db !important; 
        }
        .long-press-ready {
             outline: 2px dashed #fbbf24;
             outline-offset: 2px;
        }
        .select2-container--default .select2-selection--single { border: 1px solid #d1d5db; border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); height: 2.5rem; }
        .select2-container--default .select2-selection--single .select2-selection__rendered { line-height: 2.5rem; padding-left: 0.75rem; }
        .select2-container--default .select2-selection--single .select2-selection__arrow { height: calc(2.5rem - 2px); }
        .select2-dropdown { border: 1px solid #d1d5db; border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
        .select2-search--dropdown .select2-search__field { border: 1px solid #d1d5db; border-radius: 0.375rem; margin: 0.25rem; }
        .hidden { display: none; }

        /* Estilo base para los iconos de acción */
        #action-buttons-container .action-icon {
           font-size: 3rem;
           line-height: 1;
           transition: color 0.15s ease-in-out, opacity 0.15s ease-in-out;
           opacity: 0.6;
        }
        .action-button {
            width: 64px; height: 64px; display: flex; align-items: center; justify-content: center;
            border-radius: 0.375rem; background-color: transparent; box-shadow: none;
            transition: background-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        #start-shift-button .action-icon,
        #resume-button .action-icon { color: #22c55e; }
        #start-pause-button .action-icon { color: #eab308; }
        #end-shift-button .action-icon,
        #end-pause-button .action-icon { color: #ef4444; }
        .action-button:hover {
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        #start-shift-button:hover .action-icon,
        #resume-button:hover .action-icon,
        #start-pause-button:hover .action-icon,
        #end-shift-button:hover .action-icon,
        #end-pause-button:hover .action-icon {
            color: white !important;
            opacity: 1 !important;
        }
        #start-shift-button:hover, #resume-button:hover { background-color: #22c55e; }
        #start-pause-button:hover { background-color: #eab308; }
        #end-shift-button:hover, #end-pause-button:hover { background-color: #ef4444; }

        #shift-select-container { margin-top: 1rem; }
        #shift-select {
             padding: 0.5rem 0.75rem; border: 1px solid #d1d5db;
             border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
             background-color: white; font-size: 0.875rem; line-height: 1.25rem;
        }
        .progress-bar-segment {
            transition: width 0.5s ease-in-out;
            height: 100%;
        }
        /* === Estilos para Paneles Flotantes === */
        .floating-panel {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 120px;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .floating-panel:hover {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transform: translateY(-2px);
        }
        .floating-panel-header {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 0.875rem 1.25rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        .floating-panel-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
        }
        
        .floating-panel-header h3 {
            font-weight: 600;
            color: #1e293b;
            font-size: 1rem;
            margin: 0;
            position: relative;
            z-index: 1;
        }
        .floating-panel-content {
            padding: 1.5rem;
            background-color: #ffffff;
        }
        #floating-operator-panel {
            top: 36%;
            right: 20px;
            width: 340px;
            z-index: 1000;
            border-top: 3px solid #3b82f6;
        }
        
        #floating-actions-panel {
            left: 20px;
            top: 36%;
            width: 340px;
            z-index: 1000;
            border-top: 3px solid #10b981;
        }
        #floating-actions-panel {
            top: 36%; /* Posición inicial ajustada */
            left: 20px;
            width: 320px; /* Ancho fijo igual al panel de operario */
            z-index: 990; /* Ligeramente por debajo del panel de operario */
        }
        #floating-actions-panel .floating-panel-content { /* Para centrar los botones */
            display: flex;
            justify-content: center; /* Centra el contenedor de botones si es más estrecho que el panel */
        }
        #action-buttons-container { /* Asegurar que los botones se distribuyan bien */
            display: flex;
            flex-wrap: wrap; /* Permitir que los botones pasen a la siguiente línea si no caben */
            justify-content: center; /* Centrar los botones */
            gap: 0.5rem; /* Espacio entre botones */
        }
        .select2-container--default .select2-dropdown {
            z-index: 1050 !important; /* Asegurar que el dropdown de Select2 esté sobre otros elementos del panel */
        }
        /* === Estilo para alinear valores de datos === */
        .data-value {
            min-width: 80px; /* Ajustar según sea necesario para "00:00:00" */
            text-align: right;
            display: inline-block; /* Para que min-width funcione correctamente */
            font-size: 1.1rem; /* Aumentar tamaño de fuente */
            font-weight: 600; /* Hacer la fuente un poco más gruesa */
        }
        /* === Estilos para alertas en modo pantalla completa === */
        .swal2-in-fullscreen {
            z-index: 9999 !important;
        }
        
        .swal2-in-fullscreen-popup {
            font-size: 1.2em;
        }
        
        /* === Estilos para modo pantalla completa === */
        #kanban-board:fullscreen {
            background-color: #f8fafc;
            padding: 1.5rem;
            overflow-y: auto;
        }
        
        #kanban-board:fullscreen .kanban-column {
            min-height: 90vh;
        }
        
        #kanban-board:fullscreen #fullscreen-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 9999;
        }
        
        /* Compatibilidad con diferentes navegadores */
        #kanban-board:-webkit-full-screen { background-color: #f8fafc; padding: 1.5rem; }
        #kanban-board:-moz-full-screen { background-color: #f8fafc; padding: 1.5rem; }
        #kanban-board:-ms-fullscreen { background-color: #f8fafc; padding: 1.5rem; }
        
        /* ========================================== */

    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      @font-face { font-family: 'LucideIcons'; src: url('https://cdn.jsdelivr.net/npm/lucide-static@latest/font/lucide.ttf') format('truetype'); }
      .lucide { font-family: 'LucideIcons'; font-style: normal; font-weight: normal; font-variant: normal; text-rendering: auto; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; display: inline-block; vertical-align: middle; }
    </style>
</head>
<body class="bg-gray-200 p-8">
    <div class="container mx-auto bg-white p-6 rounded-lg shadow-md">

        <!-- Botón flotante de pantalla completa -->
        <div class="fixed top-4 right-4 z-50">
            <button id="fullscreen-button" class="bg-transparent hover:bg-gray-100 text-gray-800 p-2 rounded-full shadow-sm transition-all duration-150" title="Pantalla completa">
                <i class="fas fa-expand"></i>
            </button>
        </div>
        
        <!-- Botón flotante de refresco en la parte inferior -->
        <div class="fixed bottom-4 right-4 z-50">
            <button id="refresh-button" class="bg-transparent hover:bg-gray-100 text-gray-800 p-2 rounded-full shadow-sm transition-all duration-150" title="Refrescar Datos">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>
        <div id="kanban-board" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-3 mb-4">
            <div id="col-pendiente" data-column-name="PENDIENTES" class="kanban-column">
                <h2 class="kanban-title">PENDIENTES <span class="column-counter">0</span></h2>
                </div>
            <div id="col-en-curso" data-column-name="EN CURSO" class="kanban-column">
                <h2 class="kanban-title">EN CURSO <span class="column-counter">0</span></h2>
                </div>
            <div id="col-finalizadas" data-column-name="FINALIZADAS" class="kanban-column">
                <h2 class="kanban-title">FINALIZADAS <span class="column-counter">0</span></h2>
                </div>
            <div id="col-incidencias" data-column-name="INCIDENCIAS" class="kanban-column">
                <h2 class="kanban-title">INCIDENCIAS <span class="column-counter">0</span></h2>
                </div>
        </div>

        <div id="pause-notification" class="container mx-auto mt-4 hidden">
            <div class="bg-yellow-100 border border-yellow-300 text-yellow-800 px-4 py-3 rounded relative">
                <center>
                    <span class="block sm:inline font-semibold">
                        Estás en pausa. Vuelve a reanudar cuando estés listo.
                    </span>
                </center>
            </div>
        </div>



        <div class="md:grid md:grid-cols-3 md:gap-6 items-start border-t border-gray-200 pt-2 pb-2">
            <div class="w-full mb-4 md:mb-0 px-2 md:col-span-2">
                 <div class="text-sm max-w-md mx-auto md:mx-0">

                    <div class="flex justify-between py-0.5">
                        <span style="background-color: #f9fafb; padding: 5px; border-radius: 5px;" class="text-gray-600 font-medium">ORDEN EN CURSO</span>
                    </div>
                     <div class="flex justify-between py-0.5">
                         <span class="text-gray-600">TIEMPO EN PARADA / FALTA MATERIAL</span>
                         <span id="tiempo-parada-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span> </div>
                    <div class="flex justify-between py-0.5">
                         <span class="text-gray-600">TIEMPO EN PARADA</span>
                         <span id="tiempo-parada-noidentificada-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span> </div> 
                     <div class="flex justify-between py-0.5">
                         <span class="text-gray-600">TIEMPO PREPARACION</span>
                         <span id="tiempo-preparacion-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span> </div>
                     <div class="flex justify-between py-0.5">
                         <span class="text-gray-600">TIEMPO LENTO</span>
                         <span id="tiempo-lento-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span> </div>
                     <div id="unidades-hechas-container" class="flex justify-between py-0.5">
                          <span class="text-gray-600">Unidades Hechas</span>
                          <span id="unidades-hechas-val" class="font-mono font-medium text-gray-800 data-value">0</span>
                      </div>
                     <div id="unidades-pendientes-container" class="flex justify-between py-0.5">
                          <span class="text-gray-600">Unidades Pendientes</span>
                          <span id="unidades-pendientes-val" class="font-mono font-medium text-gray-800 data-value">0</span>
                      </div>
                     <div id="unidades-retrasadas-container" class="flex justify-between py-0.5">
                          <span class="text-gray-600">Unidades Retrasadas</span>
                          <span id="unidades-retrasadas-val" class="font-mono font-medium text-gray-800 data-value">0</span>
                      </div>
                 </div>
             </div>

            <div class="w-full px-4 flex justify-center">
                <div id="progress-indicator" class="progress-circle">
                    <span id="progress-value">0</span>
                </div>
            </div>
        </div>
        

        <div class="md:grid md:grid-cols-3 md:gap-6 items-start border-t border-gray-200 pt-2 pb-2">
            <div class="w-full mb-4 md:mb-0 px-2 md:col-span-2">
                 <div class="text-sm max-w-md mx-auto md:mx-0">
                    <div class="flex justify-between py-0.5">
                        <!-- vamos a darle un color a la maquina para que paresca que es como un header-->
                        <span style="background-color: #f9fafb; padding: 5px; border-radius: 5px;" class="text-gray-600 font-medium">MAQUINA</span>
                    </div>
                     <div class="flex justify-between py-0.5">
                         <span class="text-gray-600">TIEMPO EN PARADA / FALTA MATERIAL</span>
                         <span id="tiempo-parada-maquina-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span>
                     </div>
                     <div class="flex justify-between py-0.5">
                        <span class="text-gray-600">TIEMPO EN PARADA</span>
                        <span id="tiempo-parada-maquina-noidentificada-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span>
                    </div>
                     <div class="flex justify-between py-0.5">
                         <span class="text-gray-600">TIEMPO PREPARACION</span>
                         <span id="tiempo-preparacion-maquina-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span>
                     </div>
                     <div class="flex justify-between py-0.5">
                         <span class="text-gray-600">TIEMPO LENTO</span>
                         <span id="tiempo-lento-maquina-val" class="font-mono font-medium text-gray-800 data-value">00:00:00</span>
                     </div>
                     <div class="flex justify-between py-0.5">
                         <span class="text-gray-600">TIEMPO PAUSA</span>
                         <span id="tiempo-pausa-val2" class="font-mono font-medium text-gray-800 data-value">00:00:00</span>
                     </div>
                 </div>
            </div>

            <div class="w-full px-4 flex flex-col items-center md:items-end">
                 <div id="oee-maquina-indicator" class="progress-circle">
                     <span id="oee-maquina-value">0</span>
                 </div>
            </div>
        </div>
        <div class="border-t border-gray-200 pt-6">
            <div class="flex justify-between text-sm text-gray-500 mb-1">
                <span id="shift-start-time-label" class="font-mono font-medium text-gray-800">HORA INICIO</span> <span id="shift-end-time-label" class="font-mono font-medium text-gray-800">HORA FIN</span>
            </div>
            <div id="progress-bar-container" class="w-full bg-gray-200 rounded-full h-4 overflow-hidden flex">
                 <div id="shift-delay-bar" class="progress-bar-segment" style="width: 0%; background-color: #8B0000;"></div>
                 <div id="shift-pause-bar" class="progress-bar-segment" style="width: 0%; background-color: #CC3333;"></div>
                 <div id="shift-slow-bar" class="progress-bar-segment" style="width: 0%; background-color: #FFCC00;"></div>
                 <div id="shift-button-pause-bar" class="progress-bar-segment" style="width: 0%; background-color: #AAAAAA;"></div>
                 <div id="shift-late-bar" class="progress-bar-segment" style="width: 0%; background-color: #FFCC00;"></div>
                 <div id="shift-progress-bar" class="progress-bar-segment bg-green-500" style="width: 0%;"></div>
            </div>
            <div class="flex justify-between text-sm mt-1.5">
                <div class="flex justify-start space-x-2">
                     <span id="tiempo-pausa-val" class="font-mono font-medium text-gray-800">TIEMPO PAUSA:</span>
                </div>
                <span id="shift-info-text" class="font-mono font-medium text-gray-800">SIN DATOS</span>
            </div>
            
            <!-- Leyenda de colores para la barra de progreso -->
            <div class="flex flex-wrap gap-3 mt-1 text-xs">
                <div class="flex items-center">
                    <div class="w-3 h-3 mr-1" style="background-color: #8B0000;"></div>
                    <span>TIEMPO EN PARADA</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 mr-1" style="background-color: #CC3333;"></div>
                    <span>TIEMPO PREPARACIÓN</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 mr-1" style="background-color: #AAAAAA;"></div>
                    <span>TIEMPO PAUSA</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 mr-1" style="background-color: #FFCC00;"></div>
                    <span>TIEMPO LENTO</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 bg-green-500 mr-1"></div>
                    <span>TIEMPO PRODUCTIVO</span>
                </div>
            </div>
        </div>

    <!-- Modal de Incidencias -->
    <div id="incidentModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999] hidden">
        <div class="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4">Registrar Incidencia</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Motivo</label>
                    <select id="incidentReason" class="w-full p-2 border rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="">Selecciona un motivo</option>
                        <option value="pausado">Pausado</option>
                        <option value="averia">Avería</option>
                        <option value="falta_material">Falta de material</option>
                        <option value="calidad">Problema de calidad</option>
                        <option value="otro">Otro motivo</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Notas adicionales</label>
                    <textarea id="incidentNotes" rows="3" class="w-full p-2 border rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Detalles de la incidencia"></textarea>
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="cancelIncident" type="button" class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancelar
                </button>
                <button id="confirmIncident" type="button" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                    Registrar Incidencia
                </button>
            </div>
        </div>
    </div>

    <!-- Modal de Detalles de la Orden -->
    <div id="orderDetailsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold">Detalles de la Orden</h3>
                <button id="closeOrderDetailsModal" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            
            <div id="orderDetailsContent" class="mb-6">
                <!-- Los detalles de la orden se cargarán aquí -->
            </div>
            
            <!-- Sección de Incidencias -->
            <div class="mt-6 border-t pt-4">
                <h4 class="font-medium mb-3 flex items-center">
                    <svg class="w-5 h-5 mr-2 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                    </svg>
                    Incidencias registradas
                </h4>
                <div id="incidentsList" class="space-y-3 mb-4">
                    <!-- Las incidencias se cargarán aquí -->
                </div>
                <p id="noIncidentsMessage" class="text-gray-500 text-sm mb-4">No hay incidencias registradas para esta orden.</p>
                
                <!-- Formulario para nueva incidencia -->
                <div class="mt-6 bg-gray-50 p-4 rounded-lg">
                    <h5 class="font-medium mb-3 text-gray-700">Registrar nueva incidencia</h5>
                    <form id="newIncidentForm" class="space-y-3">
                        <input type="hidden" id="orderIncidentOrderId" name="order_id">
                        
                        <div>
                            <label for="orderIncidentReason" class="block text-sm font-medium text-gray-700 mb-1">Motivo de la incidencia</label>
                            <select id="orderIncidentReason" name="reason" required
                                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                                <option value="">Selecciona un motivo</option>
                                <option value="Falta de material">Falta de material</option>
                                <option value="Problema de calidad">Problema de calidad</option>
                                <option value="Fallo de maquinaria">Fallo de maquinaria</option>
                                <option value="Error en documentación">Error en documentación</option>
                                <option value="Otro">Otro</option>
                            </select>
                        </div>
                        
                        <div>
                            <label for="orderIncidentNotes" class="block text-sm font-medium text-gray-700 mb-1">Notas adicionales</label>
                            <textarea id="orderIncidentNotes" name="notes" rows="3"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                                placeholder="Describe la incidencia con detalle..."></textarea>
                        </div>
                        
                        <div class="flex items-center space-x-4">
                            <div class="flex-1">
                                <label for="incidentPriority" class="block text-sm font-medium text-gray-700 mb-1">Prioridad</label>
                                <select id="incidentPriority" name="priority"
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                                    <option value="baja">Baja</option>
                                    <option value="media" selected>Media</option>
                                    <option value="alta">Alta</option>
                                    <option value="critica">Crítica</option>
                                </select>
                            </div>
                            
                            <div class="flex-1">
                                <label for="incidentStatus" class="block text-sm font-medium text-gray-700 mb-1">Estado</label>
                                <select id="incidentStatus" name="status"
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                                    <option value="pendiente">Pendiente</option>
                                    <option value="en_progreso">En progreso</option>
                                    <option value="resuelta">Resuelta</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="flex justify-end space-x-3 pt-2">
                            <button type="button" id="cancelIncidentBtn"
                                class="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                                Cancelar
                            </button>
                            <button type="submit"
                                class="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">
                                Registrar Incidencia
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
    <!-- Fin Modal de Detalles de la Orden -->

    </div>
    <div id="floating-actions-panel" class="floating-panel">
        <div id="floating-actions-header" class="floating-panel-header text-center border-b border-gray-200 py-2">
            <h3 class="text-sm font-medium">Acciones</h3>
        </div>
        <div class="floating-panel-content p-3">
            <div class="flex flex-col items-center">
                <!-- Icono de acciones -->
                <div class="actions-logo mb-2">
                    <i class="fa fa-cogs text-xl text-gray-700"></i>
                </div>
                
                <!-- Contenedor de botones de acción -->
                <div class="text-center w-full">
                    <span class="block text-xs font-medium text-gray-700 mb-2">CONTROLES</span>
                    <div id="action-buttons-container" class="flex items-center justify-center space-x-2">
                        <button id="start-shift-button" class="action-button hidden" data-action-type="start-shift" title="Iniciar Turno/Tarea">
                            <i class="fa fa-play action-icon text-green-500" aria-hidden="true"></i>
                        </button>
                        <button id="start-pause-button" class="action-button hidden" data-action-type="start-pause" title="Iniciar Parada">
                            <i class="fa fa-pause action-icon text-amber-500" aria-hidden="true"></i>
                        </button>
                        <button id="resume-button" class="action-button hidden" data-action-type="resume-pause" title="Reanudar">
                            <i class="fa fa-play action-icon text-green-500" aria-hidden="true"></i>
                        </button>
                        <button id="end-shift-button" class="action-button hidden" data-action-type="end-shift" title="Finalizar Turno/Tarea">
                            <i class="fa fa-stop action-icon text-red-500" aria-hidden="true"></i>
                        </button>
                        <button id="end-pause-button" class="action-button hidden" data-action-type="end-pause" title="Finalizar Parada">
                            <i class="fa fa-stop action-icon text-red-500" aria-hidden="true"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Panel flotante para TIEMPO HASTA FINALIZACIÓN -->
    <div id="floating-tiempo-panel" class="floating-panel" style="width: 180px; position: absolute;">
        <div class="floating-panel-header text-center border-b border-gray-200 py-2">
            <h3 class="text-sm font-medium">TIEMPO HASTA FINALIZACIÓN</h3>
        </div>
        <div class="floating-panel-content p-3">
            <div class="flex flex-col items-center">
                <div id="tiempo-hasta-finalizacion" class="font-mono font-medium text-gray-800 text-3xl text-center font-bold">00:00:00</div>
            </div>
        </div>
    </div>
    
    <div id="floating-operator-panel" class="floating-panel" style="width: 180px;">
        <div id="floating-panel-header" class="floating-panel-header text-center border-b border-gray-200 py-2">
            <h3 class="text-sm font-medium">Operario / Turno</h3>
        </div>
        <div class="floating-panel-content p-3">
            <div class="flex flex-col items-center">
                <!-- Icono de operario -->
                <div class="operator-logo mb-2">
                    <i class="fa fa-user-circle text-xl text-gray-700"></i>
                </div>
                
                <!-- Información del operario -->
                <div class="text-center w-full">
                    <!-- Contenedor para mostrar el operario seleccionado -->
                    <div id="selected-worker-info" class="flex items-center justify-center">
                        <span id="worker-name" class="text-sm font-medium">Selecciona un operario</span>
                        <button id="logout-button" title="Cambiar operario" class="text-red-500 hover:text-red-700 focus:outline-none p-1 ml-1 hidden">
                            <i class="fa fa-times-circle text-sm"></i>
                        </button>
                    </div>
                    
                    <!-- Selector de operario -->
                    <div id="select-container" class="mt-2 w-full">
                        <select id="worker-select" class="w-full px-1 py-1 text-sm border border-gray-300 rounded-md" style="box-sizing: border-box; width: 100%; max-width: 100%; overflow: hidden; text-overflow: ellipsis; font-size: 0.8rem;"> 
                            <option value="">Selecciona un operario</option> 
                        </select>
                    </div>
                    
                    <!-- Selector de turno -->
                    <div id="shift-select-container" class="mt-3 hidden w-full">
                        <select id="shift-select" class="w-full px-1 py-1 text-sm border border-gray-300 rounded-md" style="box-sizing: border-box; width: 100%; max-width: 100%; overflow: hidden; text-overflow: ellipsis; font-size: 0.8rem;">
                            <option value="">Selecciona un turno</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- El botón de refresco se ha movido al contenedor de botones flotantes -->
    
    <!-- Panel flotante para código de barras -->
    <div id="floating-barcode-panel" class="floating-panel">
        <div id="floating-barcode-header" class="floating-panel-header text-center border-b border-gray-200 py-2">
            <h3 class="text-sm font-medium">Código de Barras</h3>
        </div>
        <div class="floating-panel-content p-3">
            <div class="flex flex-col items-center">
                <!-- Logo de código de barras -->
                <div class="barcode-logo mb-2">
                    <i class="fa fa-barcode text-xl text-gray-700"></i>
                </div>
                
                <!-- Número de código de barras actual -->
                <div class="text-center w-full">
                    <span class="block text-xs font-medium text-gray-700 mb-1">CÓDIGO ACTUAL</span>
                    <span id="current-barcode" class="text-sm font-mono font-medium text-gray-800">-</span>
                </div>
                
                <!-- Botón para escanear nuevo código -->
                <button id="scan-barcode-button" class="mt-2 w-full bg-blue-50 text-blue-600 py-1 px-2 rounded border border-blue-200 hover:bg-blue-100 text-sm">
                    <i class="fa fa-qrcode mr-1"></i>Escanear
                </button>
            </div>
        </div>
    </div>

    <!-- Modal para escanear código de barras -->
    <div id="barcodeModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4">Escanear Código de Barras</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Código de Barras</label>
                    <input type="text" id="barcodeInput" class="w-full p-2 border rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Escanee o introduzca el código" autofocus>
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="cancelBarcode" type="button" class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancelar
                </button>
                <button id="confirmBarcode" type="button" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                    Confirmar
                </button>
            </div>
        </div>
    </div>


    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11" defer onerror="console.error('Error loading SweetAlert2 script:', event)"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" defer onerror="console.error('Error loading Dragula script:', event)"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Configuración ---
            const API_BASE_URL = window.location.origin;
            const REFRESH_INTERVAL_MS = 1000;
            const PRODUCTION_ORDERS_REFRESH_INTERVAL_MS = 60000; // 60 seconds (aumentado de 5 a 60 segundos)
            const API_DELAY_MS = 500;
            console.log(`API Base URL set dynamically to: ${API_BASE_URL}`);
            
            // Nota: La funcionalidad de pantalla completa se maneja externamente en modo kiosko

            // Verificar librerías principales
            if (typeof $ === 'undefined' || typeof $.fn.select2 === 'undefined') { console.error("Error Crítico: jQuery o Select2 no cargados."); return; }
            if (typeof dragula !== 'function') { console.error("Error Crítico: Dragula no cargado."); return; }
            if (typeof Swal !== 'function') { console.warn("Advertencia: SweetAlert2 (Swal) no cargado."); }

            // --- Elementos del DOM ---
            const workerLabel = $('#worker-label');
            const workerSelect = $('#worker-select');
            const selectContainer = $('#select-container');
            const displayContainer = $('#display-container');
            const selectedWorkerInfo = $('#selected-worker-info');
            const logoutButton = $('#logout-button');
            const actionButtonsContainer = document.getElementById('action-buttons-container');
            // Círculo OEE Orden
            const progressIndicator = document.getElementById('progress-indicator');
            const progressValue = document.getElementById('progress-value');
            // Círculo OEE Máquina
            const oeeMaquinaIndicator = document.getElementById('oee-maquina-indicator');
            const oeeMaquinaValue = document.getElementById('oee-maquina-value');

            // Selectores y barra de progreso inferior
            const shiftSelectContainer = $('#shift-select-container');
            const shiftSelect = $('#shift-select');
            const shiftStartTimeLabel = $('#shift-start-time-label');
            const shiftEndTimeLabel = $('#shift-end-time-label');
            const progressBarContainer = $('#progress-bar-container');
            const shiftDelayBar = $('#shift-delay-bar');
            const shiftPauseBar = $('#shift-pause-bar');
            const shiftButtonPauseBar = $('#shift-button-pause-bar');
            const shiftSlowBar = $('#shift-slow-bar');
            const shiftLateBar = $('#shift-late-bar');
            const shiftProgressBar = $('#shift-progress-bar');
            const shiftInfoText = $('#shift-info-text');
            // Spans de tiempos y unidades (Orden)
            const tiempoParadaVal = $('#tiempo-parada-val');
            const tiempoLentoVal = $('#tiempo-lento-val');
            const tiempoPreparacionVal = $('#tiempo-preparacion-val');
            const unidadesHechasVal = $('#unidades-hechas-val');
            const unidadesPendientesVal = $('#unidades-pendientes-val');
            const unidadesRetrasadasVal = $('#unidades-retrasadas-val');
            // Span para Tiempo Pausa (Turno - debajo de la barra)
            const tiempoPausaValSpan = $('#tiempo-pausa-val');
            // Segundo span para Tiempo Pausa (en la sección de Maquina)
            const tiempoPausaVal2Span = $('#tiempo-pausa-val2');

            // Spans para Tiempos / Maquina
            const tiempoParadaMaquinaVal = $('#tiempo-parada-maquina-val');
            const tiempoLentoMaquinaVal = $('#tiempo-lento-maquina-val');
            const tiempoPreparacionMaquinaVal = $('#tiempo-preparacion-maquina-val');


            // Botón de refresco
            const refreshButton = document.getElementById('refresh-button');
            // Paneles Flotantes
            const floatingOperatorPanel = document.getElementById('floating-operator-panel');
            const operatorPanelHeader = document.getElementById('floating-panel-header');
            const floatingActionsPanel = document.getElementById('floating-actions-panel');
            const actionsPanelHeader = document.getElementById('floating-actions-header');

            // Columnas Kanban
            const colPendiente = document.getElementById('col-pendiente');
            const colEnCurso = document.getElementById('col-en-curso');
            const colFinalizadas = document.getElementById('col-finalizadas');
            const colIncidencias = document.getElementById('col-incidencias');


            // Inicialización de variables
            let currentWorker = null;
            let currentShiftState = { type: null, action: null };
            let selectedShiftId = null;
            let potentialNewWorker = null;
            let shiftHistoryTimeoutId = null;
            let orderStatsTimeoutId = null;
            let productionOrdersTimeoutId = null;
            let productionLineToken = null;
            let isSelectOpen = false;
            let isProcessingLogin = false;
            // Variables para arrastrar paneles
            let isDraggingOperatorPanel = false;
            let operatorPanelOffsetX, operatorPanelOffsetY;
            let isDraggingActionsPanel = false;
            let actionsPanelOffsetX, actionsPanelOffsetY;


            // --- Lógica para arrastrar el panel flotante de OPERARIO ---
            if (operatorPanelHeader && floatingOperatorPanel) {
                operatorPanelHeader.addEventListener('mousedown', function(e) {
                    isDraggingOperatorPanel = true;
                    operatorPanelOffsetX = e.clientX - floatingOperatorPanel.offsetLeft;
                    operatorPanelOffsetY = e.clientY - floatingOperatorPanel.offsetTop;
                    floatingOperatorPanel.style.cursor = 'grabbing';
                    e.preventDefault();
                });
            } else {
                console.error("Panel flotante de operario o su cabecera no encontrados.");
            }

            // --- Lógica para arrastrar el panel flotante de ACCIONES ---
            if (actionsPanelHeader && floatingActionsPanel) {
                actionsPanelHeader.addEventListener('mousedown', function(e) {
                    isDraggingActionsPanel = true;
                    actionsPanelOffsetX = e.clientX - floatingActionsPanel.offsetLeft;
                    actionsPanelOffsetY = e.clientY - floatingActionsPanel.offsetTop;
                    floatingActionsPanel.style.cursor = 'grabbing';
                    e.preventDefault();
                });
            } else {
                console.error("Panel flotante de acciones o su cabecera no encontrados.");
            }

            document.addEventListener('mousemove', function(e) {
                if (isDraggingOperatorPanel && floatingOperatorPanel) {
                    let newLeft = e.clientX - operatorPanelOffsetX;
                    let newTop = e.clientY - operatorPanelOffsetY;
                    const maxLeft = window.innerWidth - floatingOperatorPanel.offsetWidth;
                    const maxTop = window.innerHeight - floatingOperatorPanel.offsetHeight;
                    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                    newTop = Math.max(0, Math.min(newTop, maxTop));
                    floatingOperatorPanel.style.left = newLeft + 'px';
                    floatingOperatorPanel.style.top = newTop + 'px';
                }
                if (isDraggingActionsPanel && floatingActionsPanel) {
                    let newLeft = e.clientX - actionsPanelOffsetX;
                    let newTop = e.clientY - actionsPanelOffsetY;
                    const maxLeft = window.innerWidth - floatingActionsPanel.offsetWidth;
                    const maxTop = window.innerHeight - floatingActionsPanel.offsetHeight;
                    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                    newTop = Math.max(0, Math.min(newTop, maxTop));
                    floatingActionsPanel.style.left = newLeft + 'px';
                    floatingActionsPanel.style.top = newTop + 'px';
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDraggingOperatorPanel) {
                    isDraggingOperatorPanel = false;
                    if(floatingOperatorPanel) floatingOperatorPanel.style.cursor = 'move';
                }
                if (isDraggingActionsPanel) {
                    isDraggingActionsPanel = false;
                    if(floatingActionsPanel) floatingActionsPanel.style.cursor = 'move';
                }
            });


            // --- Función de utilidad para Delay ---
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

            // --- Función para formatear hora (HH:MM) ---
            function formatTime(dateTimeString) {
                if (!dateTimeString) return '--:--';
                try {
                    const date = new Date(dateTimeString);
                    if (!isNaN(date)) {
                        const hours = date.getHours().toString().padStart(2, '0');
                        const minutes = date.getMinutes().toString().padStart(2, '0');
                        return `${hours}:${minutes}`;
                    }
                    if (typeof dateTimeString === 'string' && dateTimeString.includes(':')) {
                        return dateTimeString.substring(0, 5);
                    }
                } catch (e) { console.error("Error formatting time:", dateTimeString, e); }
                return '--:--';
            }
             // --- Función para formatear fecha (DD/MM/YYYY) ---
             function formatDate(dateString) {
                if (!dateString) return 'N/A';
                try {
                    const date = new Date(dateString);
                    if (isNaN(date.getTime())) return 'N/A'; // Fecha inválida
                    const day = date.getDate().toString().padStart(2, '0');
                    const month = (date.getMonth() + 1).toString().padStart(2, '0'); // Meses son 0-indexados
                    const year = date.getFullYear();
                    return `${day}/${month}/${year}`;
                } catch (e) {
                    console.error("Error formatting date:", dateString, e);
                    return 'N/A';
                }
            }


            // --- Función para formatear duración (HH:MM:SS) con soporte para valores negativos ---
            function formatDuration(ms) {
                // Determinar si el tiempo es negativo
                const isNegative = ms < 0;
                
                // Convertir a valor absoluto para los cálculos
                ms = Math.abs(ms);
                
                if (isNaN(ms)) ms = 0;
                
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                const paddedHours = hours.toString().padStart(2, '0');
                const paddedMinutes = minutes.toString().padStart(2, '0');
                const paddedSeconds = seconds.toString().padStart(2, '0');
                
                // Añadir el signo menos si el tiempo es negativo
                return `${isNegative ? '-' : ''}${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
            }

            // --- Función para parsear duración "HH:MM:SS" a ms ---
            function parseDuration(timeString) {
                if (!timeString || typeof timeString !== 'string' || !timeString.includes(':')) return 0;
                try {
                    const parts = timeString.split(':').map(Number);
                    if (parts.length === 3 && parts.every(num => !isNaN(num))) {
                        const [hours, minutes, seconds] = parts;
                        return (hours * 3600 + minutes * 60 + seconds) * 1000;
                    }
                } catch (e) {
                    console.error("Error parsing duration string:", timeString, e);
                }
                return 0;
            }

            // --- Función para mostrar alerta de operario/turno requerido ---
            function showWorkerRequiredAlert() {
                if (typeof Swal === 'function') { 
                    // Configurar opciones para el mensaje de alerta
                    const swalOptions = { 
                        icon: 'warning', 
                        title: 'Acción no permitida', 
                        text: 'Por favor, selecciona un operario primero.', 
                        confirmButtonColor: '#3085d6' 
                    };
                    
                    // Si estamos en modo pantalla completa, ajustar el contenedor
                    if (isFullScreen && document.getElementById('kanban-board')) {
                        swalOptions.target = document.getElementById('kanban-board');
                        swalOptions.customClass = {
                            container: 'swal2-in-fullscreen',
                            popup: 'swal2-in-fullscreen-popup'
                        };
                    }
                    
                    // Mostrar el mensaje
                    Swal.fire(swalOptions);
                }
                else { alert('Por favor, selecciona un operario primero.'); }
            }
            function showShiftRequiredAlert() {
                 if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Acción no permitida', text: 'Por favor, selecciona un turno primero.', confirmButtonColor: '#3085d6' }); }
                 else { alert('Por favor, selecciona un turno primero.'); }
            }

             // --- Función para mostrar confirmación genérica ---
             function showActionConfirmation(actionDescription, callback) {
                 const isLogoutAction = actionDescription.includes("finalizar el turno/tarea");
                 if (!isLogoutAction && !currentWorker) { showWorkerRequiredAlert(); return; }

                 if (typeof Swal === 'function') {
                     Swal.fire({
                         title: 'Confirmar Acción', text: `Estás a punto de ${actionDescription}. ¿Estás seguro?`,
                         icon: 'question', showCancelButton: true, confirmButtonColor: '#3085d6',
                         cancelButtonColor: '#d33', confirmButtonText: 'Sí', cancelButtonText: 'Cancelar'
                     }).then((result) => {
                         if (result.isConfirmed) {
                             if (!isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' confirmada por ${currentWorker.name}`); }
                             else if (isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada por ${currentWorker.name}`); }
                             else if (isLogoutAction && !currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada sin operario activo.`); }
                             callback();
                         } else {
                             console.log(`Acción '${actionDescription}' cancelada.`);
                             if (!isLogoutAction) {
                                 resetShiftSelection();
                             }
                         }
                     });
                 } else {
                      if (confirm(`Estás a punto de ${actionDescription}. ¿Estás seguro?`)) {
                          if (!isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' confirmada por ${currentWorker.name}`); }
                          else if (isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada por ${currentWorker.name}`); }
                          else if (isLogoutAction && !currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada sin operario activo.`); }
                          callback();
                      } else {
                          console.log(`Acción '${actionDescription}' cancelada.`);
                          if (!isLogoutAction) {
                              resetShiftSelection();
                          }
                      }
                 }
             }

            // --- Función para enviar evento de turno a la API ---
            function postShiftEvent(eventName) {
                if (eventName !== 'final_trabajo' && (!productionLineToken || !currentWorker || !currentWorker.id)) {
                    console.error("Falta token o ID de operario para enviar evento:", eventName);
                    showWorkerRequiredAlert();
                    return Promise.reject("Faltan datos para enviar evento");
                }
                if (eventName === 'inicio_trabajo' && !selectedShiftId) {
                    console.error("Falta ID de turno para enviar evento inicio_trabajo");
                    showShiftRequiredAlert();
                    return Promise.reject("Falta ID de turno");
                }

                const payload = { production_line_token: productionLineToken, event: eventName };
                if (currentWorker && currentWorker.id) {
                    payload.operator_id = currentWorker.id;
                }
                if (eventName === 'inicio_trabajo' && selectedShiftId) {
                    payload.shift_id = (selectedShiftId === "especial") ? null : selectedShiftId;
                }

                const eventEndpoint = '/api/shift-event';
                const eventApiUrl = `${API_BASE_URL}${eventEndpoint}`;
                console.log(`Posting shift event: ${eventName} to ${eventApiUrl}`, payload);

                // Obtener el token CSRF
                const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || '';
                
                // Configurar los headers
                const headers = new Headers();
                headers.append('Content-Type', 'application/json');
                headers.append('Accept', 'application/json');
                headers.append('X-CSRF-TOKEN', csrfToken);
                
                // Configurar la autenticación si está disponible
                const token = localStorage.getItem('token');
                if (token) {
                    headers.append('Authorization', `Bearer ${token}`);
                }
                
                return fetch(eventApiUrl, { 
                    method: 'POST', 
                    headers: headers,
                    credentials: 'include',
                    body: JSON.stringify(payload) 
                })
                .then(response => {
                    if (!response.ok) { return response.json().catch(() => null).then(errorBody => { console.error(`Error en API ${eventName}: ${response.status}`, errorBody); throw new Error(`Error ${response.status} al ${eventName}`); }); }
                    return response.text().then(text => text ? JSON.parse(text) : {});
                })
                .then(data => {
                    console.log(`Evento ${eventName} enviado con éxito. Respuesta:`, data);
                    return data;
                })
                .catch(error => {
                    console.error(`Fallo al enviar evento ${eventName}:`, error);
                    if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo ${eventName}. ${error.message || ''}`, 'error'); }
                    else { alert(`Error al ${eventName}.`); }
                    throw error;
                });
            }

            // --- Función para actualizar UN círculo de progreso específico ---
            function updateProgress(indicatorElement, valueElement, percent) {
                const numericPercent = parseFloat(percent);
                const clampedPercent = isNaN(numericPercent) ? 0 : Math.max(0, Math.min(100, numericPercent));

                if (indicatorElement && valueElement) {
                    indicatorElement.style.setProperty('--progress-percent', clampedPercent);
                    valueElement.textContent = Math.round(clampedPercent);
                } else {
                    if (!indicatorElement) console.error("Elemento indicador del círculo de progreso no encontrado.");
                    if (!valueElement) console.error("Elemento de valor del círculo de progreso no encontrado.");
                }
            }

            // --- Inicializar Select2 ---
            workerSelect.select2({ placeholder: "Selecciona un operario...", allowClear: true, language: "es" });

            // --- Función para cargar operarios ---
            function loadWorkers() {
                const workersEndpoint = '/api/workers/list-all2';
                const apiUrl = `${API_BASE_URL}${workersEndpoint}`;
                console.log("Fetching workers...");
                fetch(apiUrl)
                    .then(response => response.ok ? response.json() : Promise.reject(`HTTP error! status: ${response.status}`))
                    .then(data => {
                        workerSelect.empty();
                        workerSelect.append(new Option("Selecciona un operario...", "", true, true));
                        if (data && Array.isArray(data.operators) && data.operators.length > 0) {
                            data.operators.forEach(worker => { if (worker && typeof worker.id !== 'undefined' && typeof worker.name !== 'undefined') { workerSelect.append(new Option(worker.name, worker.id)); } });
                        } else { workerSelect.append(new Option("No se encontraron operarios", "", false, true)); }
                        if (currentWorker) { workerSelect.val(currentWorker.id).trigger('change.select2'); }
                        else { workerSelect.val(null).trigger('change'); }
                        console.log("Worker list reloaded.");
                    })
                    .catch(error => { console.error('Error fetching workers:', error); workerSelect.empty().append(new Option("Error al cargar operarios", "", true, true)); if (typeof Swal === 'function') Swal.fire('Error', 'No se pudo cargar la lista de operarios.', 'error'); });
            }

            // --- Función para cargar y mostrar turnos ---
            async function loadAndShowShifts() {
                if (!productionLineToken) {
                    console.error("No hay token para cargar turnos.");
                    return Promise.reject("No hay token");
                }
                const shiftsEndpoint = `/api/shift-lists?token=${productionLineToken}`;
                const shiftsApiUrl = `${API_BASE_URL}${shiftsEndpoint}`;
                console.log("Fetching shifts from:", shiftsApiUrl);

                try {
                    const response = await fetch(shiftsApiUrl);
                    if (!response.ok) {
                        throw new Error(`Error ${response.status} al cargar turnos`);
                    }
                    const shifts = await response.json();

                    shiftSelect.empty();
                    shiftSelect.append(new Option("Selecciona un turno...", "", true, true));

                    if (shifts && Array.isArray(shifts) && shifts.length > 0) {
                        shifts.forEach(shift => {
                            if (shift && typeof shift.id !== 'undefined' && shift.start && shift.end) {
                                const startTime = shift.start.substring(0, 5);
                                const endTime = shift.end.substring(0, 5);
                                const optionText = `Turno ${startTime} - ${endTime}`;
                                shiftSelect.append(new Option(optionText, shift.id));
                            }
                        });
                    } else {
                        console.warn("No se encontraron turnos o la respuesta no es válida.");
                        shiftSelect.append(new Option("No hay turnos disponibles", "", false, true));
                    }
                    shiftSelect.append(new Option("Especial", "especial"));
                    console.log("Added 'Especial' shift option with value 'especial'.");

                    shiftSelectContainer.removeClass('hidden');
                    return true;

                } catch (error) {
                    console.error('Error fetching shifts:', error);
                    if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo cargar la lista de turnos. ${error.message || ''}`, 'error'); }
                    else { alert('Error al cargar turnos.'); }
                    shiftSelectContainer.addClass('hidden');
                    return Promise.reject(error);
                }
            }


            // --- Función para resetear selección de turno ---
            function resetShiftSelection() {
                selectedShiftId = null;
                potentialNewWorker = null;
                shiftSelect.val("");
                if (!shiftSelectContainer.hasClass('hidden')) {
                    shiftSelectContainer.addClass('hidden');
                    console.log("Shift selection reset and hidden.");
                } else {
                    console.log("Shift selection reset.");
                }
            }

            // --- Función para resetear la barra de progreso inferior ---
            function resetShiftProgressBar() {
                 shiftStartTimeLabel.text("HORA INICIO");
                 shiftEndTimeLabel.text("HORA FIN");
                 shiftInfoText.text("SIN DATOS");
                 shiftDelayBar.css('width', '0%').attr('title', '');
                 shiftPauseBar.css('width', '0%').attr('title', '');
                 shiftButtonPauseBar.css('width', '0%').attr('title', '');
                 shiftSlowBar.css('width', '0%').attr('title', '');
                 shiftLateBar.css('width', '0%').attr('title', '');
                 shiftProgressBar.css('width', '0%').attr('title', '');
                 progressBarContainer.attr('title', '');
                 console.log("Shift progress bar reset.");
            }

            // --- Pausar/Reanudar polling al abrir/cerrar Select2 de Operarios ---
            workerSelect.on('select2:opening', function (e) {
                isSelectOpen = true;
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; console.log('Shift history refresh PAUSED (worker select open).'); }
                if (orderStatsTimeoutId) { clearTimeout(orderStatsTimeoutId); orderStatsTimeoutId = null; console.log('Order stats refresh PAUSED (worker select open).'); }
                if (productionOrdersTimeoutId) { clearTimeout(productionOrdersTimeoutId); productionOrdersTimeoutId = null; console.log('Production orders refresh PAUSED (worker select open).');}
            });
             workerSelect.on('select2:close', function (e) {
                 isSelectOpen = false;
                 console.log('Worker Select2 closed, attempting to restart refreshes.');
                 if (productionLineToken && !isProcessingLogin) {
                     if (!shiftHistoryTimeoutId) {
                         console.log('Restarting shift history refresh after worker select close.');
                         fetchLastShiftHistory(productionLineToken);
                     }
                     if (!orderStatsTimeoutId) {
                         console.log('Restarting order stats refresh after worker select close.');
                         fetchOrderStats(productionLineToken);
                     }
                     if (!productionOrdersTimeoutId) {
                        console.log('Restarting production orders refresh after worker select close.');
                        fetchProductionOrders(productionLineToken);
                     }
                 } else {
                     console.log(`Refresh restart skipped (processing: ${isProcessingLogin})`);
                 }
             });

              // --- Función para actualizar botones de acción ---
              function updateActionButtons(type, action) {
                  console.log("Updating buttons for state:", type, action);
                  const buttons = actionButtonsContainer.querySelectorAll('button.action-button');
                  buttons.forEach(btn => btn.classList.add('hidden'));

                  if (type === 'shift' && action === 'start') {
                      $('#start-pause-button').removeClass('hidden');
                      $('#end-shift-button').removeClass('hidden');
                      $('#pause-notification').addClass('hidden');
                  } else if (type === 'stop' && action === 'start') {
                      $('#resume-button').removeClass('hidden');
                      $('#end-pause-button').removeClass('hidden');
                      $('#pause-notification').removeClass('hidden');
                  } else if (type === 'shift' && action === 'end') {
                      $('#start-shift-button').removeClass('hidden');
                      $('#pause-notification').addClass('hidden');
                  } else if (type === 'stop' && action === 'end') {
                      $('#start-pause-button').removeClass('hidden');
                      $('#end-shift-button').removeClass('hidden');
                      $('#pause-notification').addClass('hidden');
                  } else { // Default / Unknown state
                      $('#start-shift-button').removeClass('hidden');
                      $('#pause-notification').addClass('hidden');
                  }
              }

               // --- Añadir listeners genéricos a los botones de acción ---
               actionButtonsContainer.addEventListener('click', function(event) {
                   const button = event.target.closest('button.action-button');
                   if (!button) return;
                   const actionType = button.dataset.actionType;
                   let actionDescription = "realizar esta acción";
                   let eventName = null;

                   if (actionType === 'start-shift') {
                       console.log("Start shift button clicked, initiating worker/shift selection process.");
                       if (!currentWorker && selectContainer.is(':visible')) {
                            if (typeof Swal === 'function') { Swal.fire({ icon: 'info', title: 'Selecciona Operario', text: 'Por favor, selecciona tu nombre en la lista para iniciar el turno.', confirmButtonColor: '#3085d6' }); }
                            else { alert('Por favor, selecciona tu nombre en la lista para iniciar el turno.'); }
                       } else if (currentWorker) {
                            if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Turno ya iniciado', text: `El turno ya está iniciado para ${currentWorker.name}. Finaliza el turno actual si quieres empezar uno nuevo.`, confirmButtonColor: '#3085d6' }); }
                            else { alert(`El turno ya está iniciado para ${currentWorker.name}.`); }
                       }
                       return;
                   }

                   switch (actionType) {
                       case 'start-pause': actionDescription = "iniciar una parada"; eventName = "inicio_pausa"; break;
                       case 'resume-pause': actionDescription = "reanudar la tarea"; eventName = "final_pausa"; break;
                       case 'end-shift': actionDescription = "finalizar el turno/tarea"; eventName = "final_trabajo"; break;
                       case 'end-pause': actionDescription = "finalizar la parada"; eventName = "final_pausa"; break;
                   }
                   if (!eventName) { console.error("Tipo de acción desconocida:", actionType); return; }
                   if (actionType !== 'end-shift' && !currentWorker) { showWorkerRequiredAlert(); return; }

                   showActionConfirmation(actionDescription, () => {
                        if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                        if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                        if (productionOrdersTimeoutId) clearTimeout(productionOrdersTimeoutId);
                        isProcessingLogin = true;
                        console.log(`DEBUG: Processing ${eventName} START, refreshes blocked.`);

                        postShiftEvent(eventName)
                           .catch(err => { console.error(`Error en la acción ${actionType} (API):`, err); })
                           .finally(() => {
                               isProcessingLogin = false;
                               console.log(`DEBUG: Processing ${eventName} END, refreshes unblocked.`);
                               if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                               if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                               if (productionOrdersTimeoutId) clearTimeout(productionOrdersTimeoutId);
                               fetchLastShiftHistory(productionLineToken);
                               fetchOrderStats(productionLineToken);
                               fetchProductionOrders(productionLineToken);
                           });
                   });
               });

               // --- Función para procesar datos del historial de turno (API shift-history) ---
               function processShiftData(shiftData) {
                    let operator = null;
                    let type = null;
                    let action = null;
                    let shiftList = null;
                    let eventCreatedAt = null;
                    let totalPauseDurationSeconds = 0;
                    let oeeMaquinaPercent = 0;

                    let machineDownTimeSec = 0;
                    let machineSlowTimeSec = 0;
                    let machinePrepTimeSec = 0;

                    let previousState = {...currentShiftState};

                    if (shiftData) {
                        totalPauseDurationSeconds = shiftData.total_pause_duration_seconds || 0;

                        if (shiftData.data) {
                            operator = shiftData.data.operator;
                            type = shiftData.data.type;
                            action = shiftData.data.action;
                            shiftList = shiftData.data.shift_list;
                            eventCreatedAt = shiftData.data.created_at || shiftData.data.updated_at || shiftData.shift_start_date;

                            if (type === 'shift' && action === 'start') {
                                oeeMaquinaPercent = parseFloat(shiftData.data.oee) || 0;
                                machineDownTimeSec = parseFloat(shiftData.data.down_time) || 0;
                                machineSlowTimeSec = parseFloat(shiftData.data.slow_time) || 0;
                                machinePrepTimeSec = parseFloat(shiftData.data.prepair_time) || 0;
                            } else {
                                oeeMaquinaPercent = parseFloat(shiftData.oee) || parseFloat(shiftData.data.oee) || 0;
                                machineDownTimeSec = parseFloat(shiftData.down_time) || parseFloat(shiftData.data.down_time) || 0;
                                machineSlowTimeSec = parseFloat(shiftData.slow_time) || parseFloat(shiftData.data.slow_time) || 0;
                                machinePrepTimeSec = parseFloat(shiftData.prepare_time) || parseFloat(shiftData.data.prepair_time) || 0;
                            }
                        } else if (shiftData === null || !shiftData.data) {
                           type = 'shift'; action = 'end';
                           oeeMaquinaPercent = parseFloat(shiftData.oee) || 0;
                           machineDownTimeSec = parseFloat(shiftData.down_time) || 0;
                           machineSlowTimeSec = parseFloat(shiftData.slow_time) || 0;
                           machinePrepTimeSec = parseFloat(shiftData.prepare_time) || 0;
                           console.log("No shiftData.data or shiftData is null, using root values or defaulting.");
                        }
                    } else {
                        console.warn("Undefined or unexpected shiftData structure, defaulting values.");
                        type = 'shift'; action = 'end';
                    }

                    oeeMaquinaPercent = Math.max(0, Math.min(100, oeeMaquinaPercent));
                    updateProgress(oeeMaquinaIndicator, oeeMaquinaValue, oeeMaquinaPercent);

                    tiempoParadaMaquinaVal.text(formatDuration(machineDownTimeSec * 1000));
                    tiempoLentoMaquinaVal.text(formatDuration(machineSlowTimeSec * 1000));
                    tiempoPreparacionMaquinaVal.text(formatDuration(machinePrepTimeSec * 1000));

                    const totalButtonPauseMs = totalPauseDurationSeconds * 1000;
                    const formattedButtonPause = formatDuration(totalButtonPauseMs);
                    // tiempoPausaValSpan.text(formattedButtonPause);
                    tiempoPausaValSpan.text(`TIEMPO PAUSA: ${formattedButtonPause}`);
                    tiempoPausaVal2Span.text(formattedButtonPause); // Actualizar también el segundo elemento

                    const isShiftEnded = (type === 'shift' && action === 'end');
                    const isShiftActive = (type === 'shift' && action === 'start') || (type === 'stop' && action === 'end');
                    const isPaused = (type === 'stop' && action === 'start');

                    if (!previousState.type || previousState.type !== type || previousState.action !== action) {
                        currentShiftState = { type, action };
                        console.log("Processing shift data. New state:", currentShiftState);
                        updateActionButtons(type, action);
                    } else {
                        console.log("Shift state unchanged:", currentShiftState);
                        updateActionButtons(currentShiftState.type, currentShiftState.action);
                    }

                    if (isShiftEnded || (!operator && currentWorker) || (operator && !currentWorker) || (!operator && !currentWorker)) {
                        if (!isProcessingLogin) { resetShiftSelection(); }
                    }

                    if (isShiftEnded && !isProcessingLogin) {
                        if (currentWorker) { console.log("Shift ended, logging out current worker:", currentWorker.name); currentWorker = null; }
                        $('#worker-name').text('Selecciona un operario');
                        $('#logout-button').addClass('hidden');
                        displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden'); workerSelect.val(null).trigger('change.select2');
                        shiftSelectContainer.addClass('hidden');
                    } else if (operator && !isProcessingLogin) {
                        if (!currentWorker || currentWorker.id != operator.id) {
                            console.log("Operator found in API. Auto-displaying/updating:", operator.name);
                            currentWorker = { id: operator.id, name: operator.name };
                            $('#worker-name').text(currentWorker.name);
                            $('#logout-button').removeClass('hidden');
                            workerSelect.val(currentWorker.id).trigger('change.select2');
                        }
                        workerLabel.addClass('hidden'); selectContainer.addClass('hidden'); displayContainer.removeClass('hidden');
                    } else if (!operator && currentWorker && !isProcessingLogin) {
                        console.warn("No operator in API, but worker logged in locally. Forcing local logout.");
                        currentWorker = null;
                        $('#worker-name').text('Selecciona un operario');
                        $('#logout-button').addClass('hidden');
                        displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden'); workerSelect.val(null).trigger('change.select2');
                        shiftSelectContainer.addClass('hidden');
                    } else if (!operator && !currentWorker && !isProcessingLogin) {
                         if (selectContainer.hasClass('hidden')) {
                            console.log("No worker manually logged in and no operator in API. Ensuring selector is visible.");
                            $('#worker-name').text('Selecciona un operario');
                            $('#logout-button').addClass('hidden');
                            displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden'); workerSelect.val(null).trigger('change.select2');
                            shiftSelectContainer.addClass('hidden');
                        }
                    }

                    // --- Actualizar Barra de Progreso Inferior ---
                    if ((isShiftActive || isPaused) && eventCreatedAt && shiftList && shiftList.start && shiftList.end) {
                        const eventStartForBar = shiftData.shift_start_date || eventCreatedAt;
                        const eventStartTimeStr = formatTime(eventStartForBar);
                        const shiftStartTimeStr = formatTime(shiftList.start);
                        const shiftEndTimeStr = formatTime(shiftList.end);

                        shiftStartTimeLabel.text(`INICIO: ${eventStartTimeStr}`);
                        shiftEndTimeLabel.text(`FIN TURNO: ${shiftEndTimeStr}`);
                        shiftInfoText.text(`TURNO: ${shiftStartTimeStr} - ${shiftEndTimeStr}`);

                        try {
                            const pauseTimeMsForBar = machineDownTimeSec * 1000;
                            const slowTimeMsForBar = machineSlowTimeSec * 1000;
                            const prepTimeMsForBar = machinePrepTimeSec * 1000;
                            const buttonPauseTimeMsForBar = totalButtonPauseMs;

                            console.log(`Progress Bar Calc using (ms) - Machine Pause: ${pauseTimeMsForBar}, Button Pause (Shift): ${buttonPauseTimeMsForBar}, Machine Slow: ${slowTimeMsForBar}, Machine Prep: ${prepTimeMsForBar}`);

                            const now = new Date();
                            const eventStartDateTime = new Date(eventStartForBar);
                            const [startHours, startMinutes] = shiftStartTimeStr.split(':').map(Number);
                            const [endHours, endMinutes] = shiftEndTimeStr.split(':').map(Number);

                            let shiftStartDateTime = new Date(eventStartDateTime);
                            shiftStartDateTime.setHours(startHours, startMinutes, 0, 0);
                            let shiftEndDateTime = new Date(eventStartDateTime);
                            shiftEndDateTime.setHours(endHours, endMinutes, 0, 0);

                            if (shiftEndDateTime <= shiftStartDateTime) {
                                shiftEndDateTime.setDate(shiftEndDateTime.getDate() + 1);
                            }
                            if (eventStartDateTime > shiftEndDateTime) {
                                shiftStartDateTime.setDate(shiftStartDateTime.getDate() -1);
                                shiftEndDateTime.setDate(shiftEndDateTime.getDate() -1);
                            }

                            const totalShiftDurationMs = shiftEndDateTime.getTime() - shiftStartDateTime.getTime();
                            let actualStartDelayMs = eventStartDateTime.getTime() - shiftStartDateTime.getTime();
                            actualStartDelayMs = Math.max(0, actualStartDelayMs);

                            let elapsedSinceActualStartMs = now.getTime() - eventStartDateTime.getTime();
                            elapsedSinceActualStartMs = Math.max(0, elapsedSinceActualStartMs);

                            let remainingMs = shiftEndDateTime.getTime() - now.getTime();
                            remainingMs = Math.max(0, remainingMs);

                            let delayPercentage = 0;
                            let pausePercentage = 0;
                            let buttonPausePercentage = 0;
                            let slowPercentage = 0;
                            let prepPercentage = 0;
                            let productivePercentage = 0;

                            let formattedDelay = formatDuration(actualStartDelayMs);
                            let formattedPause = formatDuration(pauseTimeMsForBar);
                            let formattedButtonPause = formatDuration(buttonPauseTimeMsForBar);
                            let formattedSlow = formatDuration(slowTimeMsForBar);
                            let formattedPrep = formatDuration(prepTimeMsForBar);
                            let formattedRemaining = formatDuration(remainingMs);

                            if (totalShiftDurationMs > 0) {
                                if (actualStartDelayMs > 0) { delayPercentage = (actualStartDelayMs / totalShiftDurationMs) * 100; }
                                pausePercentage = (pauseTimeMsForBar / totalShiftDurationMs) * 100;
                                buttonPausePercentage = (buttonPauseTimeMsForBar / totalShiftDurationMs) * 100;
                                slowPercentage = (slowTimeMsForBar / totalShiftDurationMs) * 100;
                                prepPercentage = (prepTimeMsForBar / totalShiftDurationMs) * 100;

                                let productiveElapsedMs = elapsedSinceActualStartMs - pauseTimeMsForBar - buttonPauseTimeMsForBar - slowTimeMsForBar - prepTimeMsForBar - actualStartDelayMs;
                                productiveElapsedMs = Math.max(0, productiveElapsedMs);
                                formattedProductive = formatDuration(productiveElapsedMs);
                                productivePercentage = (productiveElapsedMs / totalShiftDurationMs) * 100;

                                delayPercentage = Math.max(0, Math.min(100, delayPercentage));
                                pausePercentage = Math.max(0, Math.min(100 - delayPercentage, pausePercentage));
                                buttonPausePercentage = Math.max(0, Math.min(100 - delayPercentage - pausePercentage, buttonPausePercentage));
                                slowPercentage = Math.max(0, Math.min(100 - delayPercentage - pausePercentage - buttonPausePercentage, slowPercentage));
                                prepPercentage = Math.max(0, Math.min(100 - delayPercentage - pausePercentage - buttonPausePercentage - slowPercentage, prepPercentage));
                                productivePercentage = Math.max(0, Math.min(100 - delayPercentage - pausePercentage - buttonPausePercentage - slowPercentage - prepPercentage, productivePercentage));

                                console.log(`Progress Bar - Delay: ${delayPercentage.toFixed(2)}%, Machine Pause: ${pausePercentage.toFixed(2)}%, Button Pause: ${buttonPausePercentage.toFixed(2)}%, Machine Slow: ${slowPercentage.toFixed(2)}%, Machine Prep: ${prepPercentage.toFixed(2)}%, Productive: ${productivePercentage.toFixed(2)}%`);

                                shiftDelayBar.css('width', `${delayPercentage}%`).attr('title', delayPercentage > 0 ? `Retraso inicio turno: ${formattedDelay}` : '');
                                shiftPauseBar.css('width', `${pausePercentage}%`).attr('title', `Tiempo Parada (Maquina): ${formattedPause}`);
                                shiftButtonPauseBar.css('width', `${buttonPausePercentage}%`).attr('title', `Tiempo Pausa (Turno): ${formattedButtonPause}`);
                                shiftSlowBar.css('width', `${slowPercentage}%`).attr('title', `Tiempo Lento (Maquina): ${formattedSlow}`);
                                shiftLateBar.css('width', `${prepPercentage}%`).attr('title', `Tiempo Preparación (Maquina): ${formattedPrep}`);
                                shiftProgressBar.css('width', `${productivePercentage}%`).attr('title', `Tiempo Productivo: ${formattedProductive}`);
                                progressBarContainer.attr('title', `Faltante: ${formattedRemaining}`);

                            } else { console.warn("Total shift duration is zero or negative."); resetShiftProgressBar(); }
                        } catch(e) { console.error("Error calculating progress:", e); resetShiftProgressBar(); }
                    } else { resetShiftProgressBar(); }
               } // Fin de processShiftData

            // --- Función para obtener el último historial de turno (API shift-history) ---
            function fetchLastShiftHistory(token) {
                if (isSelectOpen || isProcessingLogin) {
                    console.log(`Shift history refresh SKIPPED (Select open: ${isSelectOpen}, Processing login: ${isProcessingLogin})`);
                    if (!shiftHistoryTimeoutId) { shiftHistoryTimeoutId = setTimeout(() => fetchLastShiftHistory(token), REFRESH_INTERVAL_MS); }
                    return;
                }
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; }
                if (!token) { console.error("Token no encontrado para shift-history."); processShiftData(null); return; }

                const historyEndpoint = `/api/shift-history/production-line/${token}/last`;
                const historyApiUrl = `${API_BASE_URL}${historyEndpoint}`;

                fetch(historyApiUrl)
                    .then(response => { if (!response.ok) { if (response.status === 404) { console.log("No shift history found (404). Treating as 'shift ended'."); return null; } throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); })
                    .then(data => { processShiftData(data); })
                    .catch(error => { console.error('Error fetching shift history:', error); processShiftData(null); })
                    .finally(() => {
                        if (token && !isSelectOpen && !isProcessingLogin) {
                            shiftHistoryTimeoutId = setTimeout(() => fetchLastShiftHistory(token), REFRESH_INTERVAL_MS);
                        } else {
                            console.log("Shift history refresh loop paused.");
                        }
                    });
            }

            // --- Función para procesar datos de estadísticas de orden (API order-stats) ---
            function processOrderStats(statsData) {
                let oeeOrdenValue = 0;

                if (!statsData) {
                    console.warn("No order stats data received. Resetting stats and OEEs.");
                    tiempoParadaVal.text('00:00:00');
                    tiempoLentoVal.text('00:00:00');
                    tiempoPreparacionVal.text('00:00:00');
                    unidadesHechasVal.text('0');
                    unidadesPendientesVal.text('0');
                    unidadesRetrasadasVal.text('0');
                    $('#tiempo-hasta-finalizacion').text('00:00:00');
                    updateProgress(progressIndicator, progressValue, 0);
                    return;
                }

                try {
                    const downTimeSec = parseFloat(statsData.down_time) || 0;
                    const prodStopTimeSec = parseFloat(statsData.production_stops_time) || 0;
                    const totalStopTimeSec = downTimeSec + prodStopTimeSec;
                    const totalStopTimeMs = totalStopTimeSec * 1000;
                    tiempoParadaVal.text(formatDuration(totalStopTimeMs));

                    const slowTimeSec = parseFloat(statsData.slow_time) || 0;
                    const slowTimeMs = slowTimeSec * 1000;
                    tiempoLentoVal.text(formatDuration(slowTimeMs));

                    const prepTimeSec = parseFloat(statsData.prepair_time) || 0;
                    const prepTimeMs = prepTimeSec * 1000;
                    tiempoPreparacionVal.text(formatDuration(prepTimeMs));

                    unidadesHechasVal.text(statsData.units_made !== null ? statsData.units_made : '0');
                    unidadesPendientesVal.text(statsData.units_pending !== null ? statsData.units_pending : '0');
                    unidadesRetrasadasVal.text(statsData.units_delayed !== null ? statsData.units_delayed : '0');
                    
                    // Procesar tiempo hasta finalización
                    const theoreticalEndTimeSec = parseFloat(statsData.theoretical_end_time) || 0;
                    const theoreticalEndTimeMs = theoreticalEndTimeSec * 1000;
                    const tiempoElement = $('#tiempo-hasta-finalizacion');
                    
                    // Formatear y mostrar el tiempo
                    tiempoElement.text(formatDuration(theoreticalEndTimeMs));
                    
                    // Aplicar efectos visuales según el tiempo restante
                    const CINCO_MINUTOS_MS = 5 * 60 * 1000; // 5 minutos en milisegundos
                    
                    // Remover clases anteriores
                    tiempoElement.removeClass('tiempo-warning tiempo-danger');
                    $('#floating-tiempo-panel').removeClass('panel-danger');
                    
                    if (theoreticalEndTimeMs <= 0) {
                        // Tiempo agotado o negativo: mostrar en rojo
                        tiempoElement.addClass('tiempo-danger');
                        $('#floating-tiempo-panel').addClass('panel-danger');
                    } else if (theoreticalEndTimeMs <= CINCO_MINUTOS_MS) {
                        // Menos de 5 minutos: efecto de parpadeo con color ámbar
                        tiempoElement.addClass('tiempo-warning');
                    }

                    if (statsData.oee !== null && statsData.oee !== undefined) {
                        const parsedOee = parseFloat(statsData.oee);
                        if (!isNaN(parsedOee)) {
                            oeeOrdenValue = parsedOee;
                        } else {
                            console.warn(`Invalid OEE Orden value received: ${statsData.oee}. Using 0.`);
                        }
                    } else {
                         console.warn("OEE Orden value is null or undefined. Using 0.");
                    }
                    updateProgress(progressIndicator, progressValue, oeeOrdenValue);

                } catch (error) {
                    console.error("Error processing order stats data:", error, statsData);
                    tiempoParadaVal.text('00:00:00');
                    tiempoLentoVal.text('00:00:00');
                    tiempoPreparacionVal.text('00:00:00');
                    unidadesHechasVal.text('0');
                    unidadesPendientesVal.text('0');
                    unidadesRetrasadasVal.text('0');
                    updateProgress(progressIndicator, progressValue, 0);
                }
            }

            // --- Función para obtener estadísticas de la orden (API order-stats) ---
            function fetchOrderStats(token) {
                if (isSelectOpen || isProcessingLogin) {
                    console.log(`Order stats refresh SKIPPED (Select open: ${isSelectOpen}, Processing login: ${isProcessingLogin})`);
                    if (!orderStatsTimeoutId) { orderStatsTimeoutId = setTimeout(() => fetchOrderStats(token), REFRESH_INTERVAL_MS); }
                    return;
                }
                 if (orderStatsTimeoutId) { clearTimeout(orderStatsTimeoutId); orderStatsTimeoutId = null; }
                if (!token) {
                    console.warn("Token no encontrado para order-stats. Resetting stats.");
                    processOrderStats(null);
                    return;
                }

                const statsEndpoint = `/api/order-stats?token=${token}`;
                const statsApiUrl = `${API_BASE_URL}${statsEndpoint}`;

                fetch(statsApiUrl)
                    .then(response => {
                        if (!response.ok) {
                             if (response.status === 404) {
                                 console.log("No active order stats found (404). Resetting stats.");
                                 return null;
                             }
                             throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        processOrderStats(data);
                    })
                    .catch(error => {
                        console.error('Error fetching order stats:', error);
                        processOrderStats(null);
                    })
                    .finally(() => {
                        if (token && !isSelectOpen && !isProcessingLogin) {
                            orderStatsTimeoutId = setTimeout(() => fetchOrderStats(token), REFRESH_INTERVAL_MS);
                        } else {
                            console.log("Order stats refresh loop paused.");
                        }
                    });
            }


            // --- NUEVO: Funciones para cargar y procesar Órdenes de Producción ---
            
            // Función para mostrar los detalles de una orden
            async function showOrderDetails(orderId) {
                const modal = document.getElementById('orderDetailsModal');
                const content = document.getElementById('orderDetailsContent');
                const incidentsList = document.getElementById('incidentsList');
                const noIncidentsMessage = document.getElementById('noIncidentsMessage');
                
                // Establecer el ID de la orden en el formulario de incidencias
                document.getElementById('orderIncidentOrderId').value = orderId;
                
                // Mostrar indicador de carga
                content.innerHTML = `
                    <div class="animate-pulse space-y-4">
                        <div class="h-6 bg-gray-200 rounded w-3/4"></div>
                        <div class="h-4 bg-gray-200 rounded w-1/2"></div>
                        <div class="h-4 bg-gray-200 rounded w-5/6"></div>
                    </div>`;
                
                // Mostrar el modal
                modal.classList.remove('hidden');
                
                try {
                    // Obtener detalles de la orden
                    const orderResponse = await fetch(`${API_BASE_URL}/api/production-orders/${orderId}`);
                    if (!orderResponse.ok) throw new Error('Error al cargar los detalles de la orden');
                    const orderData = await orderResponse.json();
                    
                    // Obtener incidencias de la orden
                    const incidentsResponse = await fetch(`${API_BASE_URL}/api/production-orders/${orderId}/incidents`);
                    const incidentsData = await incidentsResponse.ok ? await incidentsResponse.json() : [];
                    
                    // Mostrar detalles de la orden
                    content.innerHTML = `
                        <div class="space-y-2">
                            <div class="flex justify-between">
                                <span class="font-medium">Orden #${orderData.id || 'N/A'}</span>
                                <span class="text-gray-600">${orderData.status || 'Sin estado'}</span>
                            </div>
                            <div class="text-lg font-semibold">${orderData.order_id || 'Sin referencia'}</div>
                            <div class="text-gray-600">${(orderData.json && orderData.json.refer && orderData.json.refer.descrip) || 'Sin descripción'}</div>
                            <div class="flex justify-between text-sm text-gray-500 mt-2">
                                <span>Cantidad: ${orderData.units || 'N/A'} ${orderData.json && orderData.json.unit ? orderData.json.unit : ''}</span>
                                <span>Prioridad: ${orderData.priority || 'Media'}</span>
                            </div>
                        </div>`;
                    
                    // Mostrar incidencias
                    if (incidentsData.data && incidentsData.data.length > 0) {
                        noIncidentsMessage.classList.add('hidden');
                        incidentsList.innerHTML = incidentsData.data.map(incident => `
                            <div class="border-l-4 border-red-500 pl-3 py-2 bg-gray-50 rounded">
                                <div class="flex justify-between items-start">
                                    <span class="font-medium">${incident.reason || 'Sin motivo'}</span>
                                    <span class="text-xs text-gray-500">${formatDate(incident.created_at)}</span>
                                </div>
                                ${incident.notes ? `<div class="text-sm text-gray-600 mt-1">${incident.notes}</div>` : ''}
                                <div class="text-xs text-gray-400 mt-1">Reportado por: ${incident.created_by?.name || 'Sistema'}</div>
                            </div>`
                        ).join('');
                    } else {
                        noIncidentsMessage.classList.remove('hidden');
                        incidentsList.innerHTML = '';
                    }
                } catch (error) {
                    console.error('Error al cargar los detalles:', error);
                    content.innerHTML = `
                        <div class="text-red-500">
                            Error al cargar los detalles de la orden. Intente nuevamente.
                        </div>`;
                }
            }
            
            // Cerrar el modal al hacer clic en el botón de cerrar
            document.getElementById('closeOrderDetailsModal').addEventListener('click', () => {
                document.getElementById('orderDetailsModal').classList.add('hidden');
            });
            
            // Cerrar el modal al hacer clic fuera del contenido
            document.getElementById('orderDetailsModal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('orderDetailsModal')) {
                    document.getElementById('orderDetailsModal').classList.add('hidden');
                }
            });
            
            // Manejar el envío del formulario de nueva incidencia
            document.getElementById('newIncidentForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const orderId = document.getElementById('orderIncidentOrderId').value;
                const reason = document.getElementById('orderIncidentReason').value;
                const notes = document.getElementById('orderIncidentNotes').value;
                const priority = document.getElementById('incidentPriority').value;
                const status = document.getElementById('incidentStatus').value;
                
                if (!orderId) {
                    alert('No se pudo identificar la orden');
                    return;
                }
                
                // Depuración: Mostrar valores actuales
                console.log('Valores del formulario:', {
                    orderId,
                    reason,
                    notes,
                    priority,
                    status,
                    trimmedNotes: notes.trim(),
                    hasReason: !!reason,
                    hasNotes: !!notes.trim()
                });
                
                // Validar que haya al menos un motivo seleccionado o notas escritas
                const hasReason = reason && reason.trim() !== '' && reason !== 'Selecciona un motivo';
                const hasNotes = notes && notes.trim() !== '';
                
                if (!hasReason && !hasNotes) {
                    alert('Por favor selecciona un motivo o escribe una descripción');
                    return;
                }
                
                try {
                    // Verificar que hay un operador seleccionado
                    if (!currentWorker || !currentWorker.id) {
                        throw new Error('No hay un operador seleccionado. Por favor, inicia sesión primero.');
                    }

                    const response = await fetch(`${API_BASE_URL}/api/production-orders/${orderId}/incidents`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.content || '',
                            'Accept': 'application/json',
                            'Authorization': `Bearer ${productionLineToken}`
                        },
                        body: JSON.stringify({
                            reason,
                            notes,
                            priority,
                            status,
                            operator_id: currentWorker.id,
                            _token: document.querySelector('meta[name="csrf-token"]')?.content || ''
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        // Recargar los detalles de la orden para mostrar la nueva incidencia
                        await showOrderDetails(orderId);
                        // Limpiar el formulario
                        document.getElementById('newIncidentForm').reset();
                    } else {
                        throw new Error(result.message || 'Error al registrar la incidencia');
                    }
                } catch (error) {
                    console.error('Error al registrar la incidencia:', error);
                    alert('Error al registrar la incidencia: ' + (error.message || 'Error desconocido'));
                }
            });
            
            // Manejar el botón de cancelar del formulario de incidencia
            document.getElementById('cancelIncidentBtn').addEventListener('click', () => {
                // Cerrar el modal de detalles de la orden
                document.getElementById('orderDetailsModal').classList.add('hidden');
                // Limpiar el formulario
                document.getElementById('newIncidentForm').reset();
            });
            
            // Función para obtener el texto del estado de la orden
            function getStatusText(status) {
                const statusMap = {
                    0: 'Pendiente',
                    1: 'En curso',
                    2: 'Finalizada',
                    3: 'Incidencia'
                };
                return statusMap[status] || 'Desconocido';
            }
            
            function createKanbanCardHTML(order) {
                const statusToColumnClass = {
                    0: 'ope-pendiente',  // PENDIENTE
                    1: 'ope-en-curso',   // EN CURSO
                    2: 'ope-finalizada', // FINALIZADA
                    3: 'ope-incidencia'  // INCIDENCIA
                };
                
                // Iconos según el estado
                const statusToIcon = {
                    0: '<i class="fas fa-clock text-red-500 mr-1" title="Pendiente"></i>',  // PENDIENTE - reloj
                    1: '<i class="fas fa-play text-blue-500 mr-1" title="En curso"></i>',   // EN CURSO - play
                    2: '<i class="fas fa-check text-green-500 mr-1" title="Finalizada"></i>', // FINALIZADA - check
                    3: '<i class="fas fa-exclamation-triangle text-yellow-500 mr-1" title="Incidencia"></i>'  // INCIDENCIA - triángulo
                };
                
                const defaultClass = 'ope-default';
                const statusClass = statusToColumnClass[order.status] || defaultClass;
                const statusIcon = statusToIcon[order.status] || '';

                const card = document.createElement('div');
                card.className = 'kanban-card cursor-pointer';
                card.dataset.cardId = order.id;
                card.dataset.orderSort = order.orden || 0;
                
                // Determinar si hay unidades y si es urgente
                const hasUnits = order.units && order.units > 0;
                const isUrgent = order.json && order.json.urgent;
                
                card.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center">
                            ${statusIcon}
                            <span class="font-bold text-xs text-gray-800" style="letter-spacing: -0.3px;">${order.order_id || 'N/A'}</span>
                            ${isUrgent ? '<i class="fas fa-bolt text-orange-500 ml-1" title="Urgente"></i>' : ''}
                        </div>
                        <div class="flex items-center">
                            <span class="text-xs text-gray-600 mr-2">${(order.json && order.json.refer && order.json.refer.customerId) ? order.json.refer.customerId : 'N/A'}</span>
                            <button class="card-menu-btn text-gray-500 hover:text-gray-700 p-1" data-order-id="${order.id}">
                                <i class="fas fa-ellipsis-v"></i>
                            </button>
                        </div>
                    </div>
                    <div class="mb-2 text-xs text-gray-700">
                    ${(order.json && order.json.refer && order.json.refer.descrip) ? order.json.refer.descrip : 'Sin descripción'}
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-500">
                        <span><i class="far fa-calendar-alt mr-1"></i>${formatDate(order.created_at)}</span>
                        <span class="font-medium text-gray-700">
                            ${hasUnits ? '<i class="fas fa-cubes mr-1"></i>' : ''}
                            ${order.units || 0} ${order.json && order.json.unit ? order.json.unit : ''}
                        </span>
                    </div>`;
                
                // Agregar evento de click para el botón de menú (después de crear el HTML)
                const menuBtn = card.querySelector('.card-menu-btn');
                if (menuBtn) {
                    menuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Verificar si hay un operario seleccionado
                        if (!currentWorker) {
                            showWorkerRequiredAlert();
                            return;
                        }
                        showOrderDetails(order.id);
                    });
                }
                // Agregar evento de doble click solo para tarjetas "en curso" (status 1)
                if (order.status === 1) {
                    card.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        // Verificar si hay un operario seleccionado
                        if (!currentWorker) {
                            showWorkerRequiredAlert();
                            return;
                        }
                        // Mostrar confirmación usando SweetAlert2 (que ya está incluido)
                        Swal.fire({
                            title: '¿Estás seguro?',
                            text: 'Estás a punto de cambiar esta tarjeta a finalizadas',
                            icon: 'question',
                            showCancelButton: true,
                            confirmButtonColor: '#22c55e',
                            cancelButtonColor: '#ef4444',
                            confirmButtonText: 'Sí, finalizar',
                            cancelButtonText: 'No, cancelar'
                        }).then((result) => {
                            if (result.isConfirmed) {
                                // Cambiar el estado de la tarjeta a finalizada (status 2)
                                updateOrderStatus(order.id, 2);
                            }
                        });
                    });
                }
                return card;
            }
            // Función para actualizar el estado de una orden de producción
            async function updateOrderStatus(orderId, newStatus) {
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const productionLineToken = urlParams.get('token');
                    
                    if (!productionLineToken) {
                        throw new Error('No se encontró el token de la línea de producción');
                    }
                    
                    const updateResponse = await fetch(`${API_BASE_URL}/api/production-orders/${orderId}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                            'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.content || ''
                        },
                        body: JSON.stringify({
                            status: newStatus,
                            token: productionLineToken
                        })
                    });

                    if (!updateResponse.ok) {
                        throw new Error('Error al actualizar el estado de la orden');
                    }

                    // Refrescar los datos del Kanban
                    fetchProductionOrders(productionLineToken);
                    fetchOrderStats(productionLineToken);
                    
                    return true;
                } catch (error) {
                    console.error('Error al actualizar el estado de la orden:', error);
                    
                    // Mostrar error con SweetAlert2
                    if (window.Swal && typeof window.Swal.fire === 'function') {
                        window.Swal.fire({
                            title: 'Error',
                            text: 'No se pudo actualizar el estado de la orden: ' + error.message,
                            icon: 'error',
                            timer: 3000,
                            showConfirmButton: false
                        });
                    }
                    
                    return false;
                }
            }

            function processProductionOrders(ordersData) {
                if (!ordersData || !ordersData.data) {
                    console.warn("No production orders data to process.");
                    return;
                }

                const ordersByColumn = {
                    '0': [], '1': [], '2': [], '3': []
                };
                
                // Crear un mapa de las órdenes existentes para comparación rápida
                const existingOrdersMap = {};
                [colPendiente, colEnCurso, colFinalizadas, colIncidencias].forEach(column => {
                    if (column) {
                        const cards = column.querySelectorAll('.kanban-card');
                        cards.forEach(card => {
                            if (card.dataset.cardId) {
                                existingOrdersMap[card.dataset.cardId] = {
                                    element: card,
                                    column: column
                                };
                            }
                        });
                    }
                });

                // Organizar órdenes por estado
                ordersData.data.forEach(order => {
                    const statusStr = String(order.status);
                    if (['0', '1', '2', '3'].includes(statusStr)) {
                        ordersByColumn[statusStr].push(order);
                    } else {
                        console.log(`Orden con estado no manejado (${order.status}), ID: ${order.id}. No se mostrará en el tablero.`);
                    }
                });
                
                // Procesar cada columna
                for (const status in ordersByColumn) {
                    // Ordenar por el campo 'orden'
                    ordersByColumn[status].sort((a, b) => (a.orden || 0) - (b.orden || 0));
                    
                    // Obtener la columna destino
                    let targetColumn = null;
                    switch (status) {
                        case '0': targetColumn = colPendiente; break;
                        case '1': targetColumn = colEnCurso; break;
                        case '2': targetColumn = colFinalizadas; break;
                        case '3': targetColumn = colIncidencias; break;
                    }
                    
                    if (!targetColumn) continue;
                    
                    // Guardar la referencia al título existente
                    const titleElement = targetColumn.querySelector('h2.kanban-title');
                    
                    // Crear un array para rastrear las tarjetas que deben estar en esta columna
                    const cardsToKeep = [];
                    const currentCards = Array.from(targetColumn.querySelectorAll('.kanban-card'));
                    
                    // Procesar cada orden para esta columna
                    ordersByColumn[status].forEach(order => {
                        // Comprobar si la tarjeta ya existe en esta columna
                        const existingCardInThisColumn = currentCards.find(card => card.dataset.cardId === order.id.toString());
                        
                        if (existingCardInThisColumn) {
                            // Si la tarjeta ya está en esta columna, mantenerla tal cual
                            cardsToKeep.push(existingCardInThisColumn);
                        } else {
                            // Comprobar si existe en otra columna
                            const existingOrder = existingOrdersMap[order.id];
                            
                            if (existingOrder && existingOrder.column !== targetColumn) {
                                // Si está en otra columna, moverla a esta columna
                                const card = createKanbanCardHTML(order);
                                cardsToKeep.push(card);
                                // Eliminar de existingOrdersMap para que no se use de nuevo
                                delete existingOrdersMap[order.id];
                            } else if (!existingOrder) {
                                // Si es completamente nueva, crearla
                                const card = createKanbanCardHTML(order);
                                cardsToKeep.push(card);
                            }
                        }
                    });
                    
                    // Ocultar temporalmente todas las tarjetas actuales (sin eliminarlas)
                    currentCards.forEach(card => {
                        card.style.display = 'none';
                    });
                    
                    // Añadir las tarjetas nuevas al final
                    cardsToKeep.forEach(card => {
                        if (!card.parentNode) {
                            // Solo añadir si no está ya en el DOM
                            targetColumn.appendChild(card);
                        } else {
                            // Si ya está en el DOM, asegurarse de que sea visible
                            card.style.display = '';
                        }
                    });
                    
                    // Eliminar las tarjetas que ya no deben estar en esta columna
                    currentCards.forEach(card => {
                        if (!cardsToKeep.includes(card)) {
                            if (card.parentNode) {
                                card.parentNode.removeChild(card);
                            }
                        }
                    });
                    
                    // Actualizar el contador de la columna sin animaciones
                    const counter = targetColumn.querySelector('.column-counter');
                    if (counter) {
                        counter.textContent = ordersByColumn[status].length;
                    }
                }
                
                console.log("Production orders processed and Kanban board updated.");
            }


            function fetchProductionOrders(token, page = 1) {
                if (isSelectOpen || isProcessingLogin) {
                    console.log(`Production orders refresh SKIPPED (Select open: ${isSelectOpen}, Processing login: ${isProcessingLogin})`);
                    if (!productionOrdersTimeoutId) {
                        productionOrdersTimeoutId = setTimeout(() => fetchProductionOrders(token), PRODUCTION_ORDERS_REFRESH_INTERVAL_MS);
                    }
                    return;
                }
                if (productionOrdersTimeoutId) { clearTimeout(productionOrdersTimeoutId); productionOrdersTimeoutId = null; }
                if (!token) {
                    console.warn("Token no encontrado. No se cargarán las órdenes.");
                    [colPendiente, colEnCurso, colFinalizadas, colIncidencias].forEach(column => {
                        if (column) {
                            const titleElement = column.querySelector('h2.kanban-title');
                            column.innerHTML = '';
                            if (titleElement) column.appendChild(titleElement);
                        }
                    });
                    return;
                }

                // Usar el nuevo endpoint optimizado para Kanban
                const ordersEndpoint = `/api/kanban/orders?token=${token}`;
                const ordersApiUrl = `${API_BASE_URL}${ordersEndpoint}`;
                console.log(`Fetching kanban production orders from: ${ordersApiUrl}`);

                fetch(ordersApiUrl)
                    .then(response => {
                        if (!response.ok) {
                            if (response.status === 404) {
                                console.log("No production orders found (404).");
                                processProductionOrders({ data: [] });
                                return null;
                            }
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.success) {
                            // Adaptar la respuesta al formato esperado por processProductionOrders
                            processProductionOrders({ data: data.data });
                        } else {
                            console.error('Error en la respuesta del servidor:', data);
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching production orders:', error);
                         [colPendiente, colEnCurso, colFinalizadas, colIncidencias].forEach(column => {
                            if (column) {
                                const titleElement = column.querySelector('h2.kanban-title');
                                column.innerHTML = '';
                                if (titleElement) column.appendChild(titleElement);
                            }
                        });
                    })
                    .finally(() => {
                        if (token && !isSelectOpen && !isProcessingLogin) {
                            productionOrdersTimeoutId = setTimeout(() => fetchProductionOrders(token), PRODUCTION_ORDERS_REFRESH_INTERVAL_MS);
                        } else {
                            console.log("Production orders refresh loop paused.");
                        }
                    });
            }
            // --- FIN NUEVO ---


            // --- Función para obtener token de URL ---
            function getTokenFromUrl() {
                const params = new URLSearchParams(window.location.search);
                return params.get('token');
            }

            // --- Flujo Inicial ---
            productionLineToken = getTokenFromUrl();
            loadWorkers();
            fetchLastShiftHistory(productionLineToken);
            fetchOrderStats(productionLineToken);
            fetchProductionOrders(productionLineToken);


            // --- Manejar selección manual de operario ---
            workerSelect.on('change', async function(e) {
                console.log("DEBUG: Worker Select 'change' event fired!");
                const selectedId = $(this).val();
                resetShiftSelection();
                if (!selectedId || selectedId === "") {
                    potentialNewWorker = null;
                    isProcessingLogin = false;
                    if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null;
                    if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId); orderStatsTimeoutId = null;
                    if (productionOrdersTimeoutId) clearTimeout(productionOrdersTimeoutId); productionOrdersTimeoutId = null;
                    $('#worker-name').text('Selecciona un operario');
                    shiftSelectContainer.addClass('hidden');
                    console.log("DEBUG: Worker deselected. Refreshes stopped.");
                    return;
                }
                // Mostrar el selector de turno cuando se selecciona un operario válido
                shiftSelectContainer.removeClass('hidden');
                loadAndShowShifts();
                const selectedName = $(this).find('option:selected').text();
                if (currentWorker && currentWorker.id != selectedId) {
                    if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Cambio de Operario', text: `Para iniciar sesión como ${selectedName}, primero debes finalizar el turno del operario actual (${currentWorker.name}). Usa el botón (X) o el botón 'Finalizar Turno'.`, confirmButtonColor: '#3085d6' }); } else { alert(`Para iniciar sesión como ${selectedName}, primero debes finalizar el turno del operario actual (${currentWorker.name}). Usa el botón (X) o el botón 'Finalizar Turno'.`); }
                    workerSelect.val(currentWorker.id).trigger('change.select2');
                    return;
                }
                if (currentWorker && currentWorker.id == selectedId) { return; }

                potentialNewWorker = { id: selectedId, name: selectedName };
                console.log("DEBUG: Potential worker selected:", potentialNewWorker.name);

                isProcessingLogin = true;
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; }
                if (orderStatsTimeoutId) { clearTimeout(orderStatsTimeoutId); orderStatsTimeoutId = null; }
                if (productionOrdersTimeoutId) { clearTimeout(productionOrdersTimeoutId); productionOrdersTimeoutId = null; }
                console.log("DEBUG: Processing login START, refreshes blocked.");

                try {
                    const shiftsLoaded = await loadAndShowShifts();
                    if (!shiftsLoaded) {
                        workerSelect.val(null).trigger('change.select2'); potentialNewWorker = null;
                        isProcessingLogin = false;
                        console.log("DEBUG: Processing login END (no shifts), refreshes unblocked.");
                        if (!shiftHistoryTimeoutId) fetchLastShiftHistory(productionLineToken);
                        if (!orderStatsTimeoutId) fetchOrderStats(productionLineToken);
                        if (!productionOrdersTimeoutId) fetchProductionOrders(productionLineToken);
                    } else {
                        console.log("Shifts loaded, waiting for shift selection. Refreshes remain blocked.");
                    }
                } catch (error) {
                     workerSelect.val(null).trigger('change.select2'); potentialNewWorker = null;
                    isProcessingLogin = false;
                    console.log("DEBUG: Processing login END (shift load error), refreshes unblocked.");
                    if (!shiftHistoryTimeoutId) fetchLastShiftHistory(productionLineToken);
                    if (!orderStatsTimeoutId) fetchOrderStats(productionLineToken);
                    if (!productionOrdersTimeoutId) fetchProductionOrders(productionLineToken);
                }
            });

            // --- Manejar selección de turno ---
            shiftSelect.on('change', async function(e) {
                console.log("DEBUG: Shift Select 'change' event fired!");
                selectedShiftId = $(this).val();
                if (!selectedShiftId || selectedShiftId === "") {
                    console.log("DEBUG: Shift selection cleared or placeholder selected.");
                    selectedShiftId = null;
                    return;
                }
                if (!potentialNewWorker) {
                    console.error("Error: Shift selected but no potential worker stored.");
                    workerSelect.val(null).trigger('change.select2'); resetShiftSelection();
                    isProcessingLogin = false;
                    if (!shiftHistoryTimeoutId) fetchLastShiftHistory(productionLineToken);
                    if (!orderStatsTimeoutId) fetchOrderStats(productionLineToken);
                    if (!productionOrdersTimeoutId) fetchProductionOrders(productionLineToken);
                    return;
                }

                const selectedShiftText = $(this).find('option:selected').text();
                let confirmed = false;

                if (typeof Swal === 'function') {
                    const swalResult = await Swal.fire({
                        title: 'Confirmar Inicio de Turno',
                        html: `Vas a iniciar sesión como <b>${potentialNewWorker.name}</b> en el <b>${selectedShiftText}</b>.<br>¿Estás seguro?`,
                        icon: 'question', showCancelButton: true, confirmButtonColor: '#3085d6',
                        cancelButtonColor: '#d33', confirmButtonText: 'Confirmar', cancelButtonText: 'Cancelar' });
                    confirmed = swalResult.isConfirmed;
                } else {
                    confirmed = confirm(`Vas a iniciar sesión como ${potentialNewWorker.name} en el ${selectedShiftText}. ¿Estás seguro?`);
                }

                try {
                    if (confirmed) {
                         console.log("DEBUG: Start shift CONFIRMED.");
                        currentWorker = potentialNewWorker;
                        potentialNewWorker = null;
                        selectedWorkerInfo.text(currentWorker.name);
                        workerLabel.addClass('hidden'); selectContainer.addClass('hidden'); displayContainer.removeClass('hidden');
                        if (typeof Swal === 'function') { Swal.fire({ title: 'Procesando...', allowOutsideClick: false, didOpen: () => Swal.showLoading() }); } else { alert('Procesando...'); }

                        try {
                            await postShiftEvent("inicio_trabajo");
                            if (typeof Swal === 'function' && Swal.isLoading()) { Swal.close(); }
                            resetShiftSelection();
                            if (typeof Swal === 'function') { Swal.fire({ title: '¡Éxito!', text: `Turno iniciado para ${currentWorker.name}.`, icon: 'success', timer: 2500, timerProgressBar: true }); } else { alert('¡Éxito!'); }
                        } catch (error) {
                            console.error("DEBUG: Error during start shift API call:", error);
                            if (typeof Swal === 'function' && Swal.isLoading()) { Swal.close(); }
                            if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo iniciar el turno. ${error.message || ''}`, 'error'); } else { alert(`Error al iniciar turno. ${error.message || ''}`); }
                            currentWorker = null; selectedShiftId = null;
                            displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden');
                            workerSelect.val(null).trigger('change.select2');
                            resetShiftSelection();
                        }
                    } else {
                         console.log("DEBUG: Start shift CANCELLED by user.");
                        shiftSelect.val(""); selectedShiftId = null;
                    }
                } finally {
                    if (confirmed) {
                        isProcessingLogin = false;
                        console.log("DEBUG: Processing login END (Shift selected/processed), refreshes unblocked.");
                        if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                        if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                        if (productionOrdersTimeoutId) clearTimeout(productionOrdersTimeoutId);
                        fetchLastShiftHistory(productionLineToken);
                        fetchOrderStats(productionLineToken);
                        fetchProductionOrders(productionLineToken);
                    } else {
                        console.log("DEBUG: Shift selection cancelled, refreshes remain blocked until worker selection changes.");
                    }
                }
            });


               // --- Manejar clic en botón Logout (X) ---
               logoutButton.on('click', function() {
                   const logoutDescription = "finalizar el turno/tarea actual";
                   const eventName = "final_trabajo";
                   if (!currentWorker) {
                        console.log("Logout button clicked, but no worker seems active locally. Attempting API call anyway.");
                       if (typeof Swal === 'function') { Swal.fire({ icon: 'info', title: 'Finalizar Turno', text: 'Intentando finalizar cualquier turno activo...', confirmButtonColor: '#3085d6' }); } else { alert('Intentando finalizar...'); }
                    }

                   showActionConfirmation(logoutDescription, () => {
                       if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                       if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                       if (productionOrdersTimeoutId) clearTimeout(productionOrdersTimeoutId);
                       isProcessingLogin = true;
                       console.log("DEBUG: Processing final_trabajo START, refreshes blocked.");

                       postShiftEvent(eventName)
                           .then(() => { console.log("Logout API call successful."); })
                           .catch(err => { console.error("Logout failed during API call:", err); })
                            .finally(() => {
                                isProcessingLogin = false;
                                console.log("DEBUG: Processing final_trabajo END, refreshes unblocked.");
                                // Limpiar el estado y actualizar la UI
                                currentWorker = null;
                                $('#worker-name').text('Selecciona un operario');
                                $('#logout-button').addClass('hidden');
                                displayContainer.addClass('hidden');
                                workerLabel.removeClass('hidden');
                                selectContainer.removeClass('hidden');
                                workerSelect.val(null).trigger('change.select2');
                                shiftSelectContainer.addClass('hidden');
                                
                                if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                                if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                                if (productionOrdersTimeoutId) clearTimeout(productionOrdersTimeoutId);
                                fetchLastShiftHistory(productionLineToken);
                                fetchOrderStats(productionLineToken);
                                fetchProductionOrders(productionLineToken);
                            });
                   });
               });

            // --- NUEVO: Manejar clic en botón Refrescar ---
            if (refreshButton) {
                refreshButton.addEventListener('click', function() {
                    console.log("Manual refresh triggered.");
                    if (typeof Swal === 'function') {
                        Swal.fire({ title: 'Refrescando...', timer: 500, didOpen: () => Swal.showLoading(), showConfirmButton: false });
                    } else {
                        alert("Refrescando datos...");
                    }
                    if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                    if (orderStatsTimeoutId) clearTimeout(orderStatsTimeoutId);
                    if (productionOrdersTimeoutId) clearTimeout(productionOrdersTimeoutId);
                    fetchLastShiftHistory(productionLineToken);
                    fetchOrderStats(productionLineToken);
                    fetchProductionOrders(productionLineToken); // Refrescar también las órdenes
                });
            } else {
                console.error("Refresh button not found!");
            }

            // --- Lógica Kanban (Dragula) ---
            const columns = Array.from(document.querySelectorAll('.kanban-column'));
            if (columns.length === 0) { console.error("Error: No se encontraron columnas Kanban."); return; }
            let longPressTimer = null; let isTouchInteraction = false; let longPressTriggered = false; const longPressDelay = 500; let startX, startY; let currentCard = null;
            document.addEventListener('touchstart', handleTouchStart, { passive: false }); document.addEventListener('touchmove', handleTouchMove, { passive: false }); document.addEventListener('touchend', handleTouchEnd); document.addEventListener('touchcancel', handleTouchEnd);

            function handleTouchStart(e) {
                const card = e.target.closest('.kanban-card');
                if (!card) { isTouchInteraction = false; return; }
                currentCard = card;
                isTouchInteraction = true;
                longPressTriggered = false;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                clearTimeout(longPressTimer);
                longPressTimer = setTimeout(() => {
                    if (!isTouchInteraction || !currentCard) return;
                    console.log("Long press triggered!");
                    longPressTriggered = true;
                    currentCard.classList.add('long-press-ready');
                    if (navigator.vibrate) { navigator.vibrate(50); }
                }, longPressDelay);
            }

            function handleTouchMove(e) {
                if (!isTouchInteraction || !currentCard) return;
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const deltaX = Math.abs(currentX - startX);
                const deltaY = Math.abs(currentY - startY);
                const moveThreshold = 10;

                if (!longPressTriggered && (deltaX > moveThreshold || deltaY > moveThreshold)) {
                    console.log("Movement detected before long press, cancelling timer.");
                    clearTimeout(longPressTimer);
                    if(currentCard) currentCard.classList.remove('long-press-ready');
                }
            }

            function handleTouchEnd(e) {
                clearTimeout(longPressTimer);
                if (currentCard) {
                    currentCard.classList.remove('long-press-ready');
                }
                currentCard = null;
            }

            const drake = dragula(columns, {
                moves: function (el, source, handle, sibling) {
                    // Permitir arrastrar desde cualquier columna, incluyendo incidencias
                    if (!isTouchInteraction) { return true; }
                    return longPressTriggered;
                },
                accepts: function (el, target, source, sibling) {
                     if (target.id === 'col-en-curso') {
                         if (source.id === 'col-en-curso') return true;
                         const cardsInTarget = target.querySelectorAll('.kanban-card:not(.gu-transit)').length;
                         if (cardsInTarget > 0) {
                               if (typeof Swal === 'function') {
                                   // Configurar opciones para el mensaje de alerta
                                   const swalOptions = {
                                       icon: 'warning', 
                                       title: 'Movimiento no permitido',
                                       text: 'Solo puede haber una tarea en la columna "En Curso".',
                                       toast: true, 
                                       position: 'top-end', 
                                       showConfirmButton: false,
                                       timer: 3000, 
                                       timerProgressBar: true
                                   };
                                   
                                   // Si estamos en modo pantalla completa, ajustar el contenedor
                                   if (isFullScreen && document.getElementById('kanban-board')) {
                                       swalOptions.target = document.getElementById('kanban-board');
                                       swalOptions.customClass = {
                                           container: 'swal2-in-fullscreen',
                                           popup: 'swal2-in-fullscreen-popup'
                                       };
                                   }
                                   
                                   // Mostrar el mensaje
                                   Swal.fire(swalOptions);
                              } else {
                                   alert('Solo puede haber una tarea en la columna "En Curso".');
                              }
                              console.log("Drop rejected: 'En Curso' column already has a card.");
                              return false;
                         }
                     }
                     return true;
                 }
            });

            if (!drake) { console.error("Error: Falló la inicialización de Dragula."); return; }

            drake.on('drag', (el, source) => {
                console.log("Dragula event: drag (started)");
                if (!currentWorker) {
                    console.log("Drag cancelled: No worker selected.");
                    drake.cancel(true);
                    showWorkerRequiredAlert();
                    return;
                }
                if (el) el.classList.remove('long-press-ready');
                isTouchInteraction = false;
                
                // Añadir clase visual a todas las columnas válidas para soltar
                columns.forEach(column => {
                    // No añadir la clase a la columna de origen
                    if (column !== source) {
                        column.classList.add('column-drop-target');
                    }
                });
            });
            
            drake.on('dragend', () => {
                console.log("Dragula event: dragend (finished, dropped or cancelled)");
                
                // Eliminar la clase visual de todas las columnas
                columns.forEach(column => {
                    column.classList.remove('column-drop-target');
                });
            });
            
            drake.on('drop', (el, target, source, sibling) => {
                console.log("Dragula event: drop");
                
                // Añadir clase de animación para destacar la tarjeta recién movida
                el.classList.add('card-just-moved');
                
                // Eliminar la clase después de la animación
                setTimeout(() => {
                    el.classList.remove('card-just-moved');
                }, 800);
            });

            // Variables para el manejo del modal de incidencias
            let currentCardId = null;
            let currentCardElement = null;
            let currentSourceColumn = null;
            
            // Mostrar el modal de incidencias
            function showIncidentModal(cardElement, sourceColumn, targetColumn) {
                // Si estamos en modo pantalla completa, asegurarnos de que el modal se muestre dentro del elemento fullscreen
                const incidentModal = document.getElementById('incidentModal');
                
                // Comprobar si estamos en modo pantalla completa
                if (isFullScreen) {
                    // Mover el modal dentro del kanban-board para que sea visible en pantalla completa
                    document.getElementById('kanban-board').appendChild(incidentModal);
                } else {
                    // Si no estamos en pantalla completa, asegurarnos de que el modal esté en el body
                    if (incidentModal.parentElement.id === 'kanban-board') {
                        document.body.appendChild(incidentModal);
                    }
                }
                console.log('showIncidentModal called with cardElement:', cardElement);
                console.log('cardElement.dataset:', cardElement.dataset);
                
                if (!cardElement || !cardElement.dataset) {
                    console.error('Invalid card element or missing dataset');
                    return;
                }
                
                // Obtener el ID de la tarjeta de diferentes maneras para mayor robustez
                currentCardId = cardElement.dataset.cardId || cardElement.dataset.id || cardElement.id.replace('card-', '');
                
                if (!currentCardId) {
                    console.error('No se pudo obtener el ID de la tarjeta');
                    if (typeof Swal === 'function') {
                        Swal.fire('Error', 'No se pudo identificar la orden de producción', 'error');
                    }
                    return;
                }
                
                currentCardElement = cardElement;
                currentSourceColumn = sourceColumn;
                
                console.log('currentCardId set to:', currentCardId);
                
                // Resetear el formulario
                document.getElementById('incidentReason').value = '';
                document.getElementById('incidentNotes').value = '';
                
                // Mostrar el modal
                document.getElementById('incidentModal').classList.remove('hidden');
                
                // Enfocar el primer campo
                document.getElementById('incidentReason').focus();
            }
            
            // Ocultar el modal de incidencias
            function hideIncidentModal() {
                document.getElementById('incidentModal').classList.add('hidden');
                // No limpiamos las variables aquí para mantener la referencia
                // hasta que se complete la operación o se cancele
            }
            
            // Manejadores de eventos del modal
            document.getElementById('cancelIncident').addEventListener('click', () => {
                document.getElementById('incidentModal').classList.add('hidden');
                // Revertir el movimiento
                if (currentSourceColumn && currentCardElement) {
                    currentSourceColumn.appendChild(currentCardElement);
                }
                currentSourceColumn = null;
                currentCardElement = null;
                currentCardId = null;
            });

            document.getElementById('confirmIncident').addEventListener('click', async () => {
                const reason = document.getElementById('incidentReason').value;
                const notes = document.getElementById('incidentNotes').value;
                
                if (!reason) {
                    if (typeof Swal === 'function') {
                        Swal.fire({
                            icon: 'error',
                            title: 'Error',
                            text: 'Por favor, selecciona un motivo para la incidencia.',
                            confirmButtonColor: '#3085d6'
                        });
                    } else {
                        alert('Por favor, selecciona un motivo para la incidencia.');
                    }
                    return;
                }
                
                try {
                    // Mostrar indicador de carga
                    const loadingSwal = Swal.fire({
                        title: 'Registrando incidencia...',
                        allowOutsideClick: false,
                        didOpen: () => {
                            Swal.showLoading();
                        }
                    });

                    // 1. Registrar la incidencia
                    console.log('Attempting to report incident for card ID:', currentCardId);
                    if (!currentCardId) {
                        throw new Error('No se pudo obtener el ID de la orden de producción');
                    }
                    
                    // Obtener el token CSRF
                    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || '';
                    
                    // Configurar los headers
                    const headers = new Headers();
                    headers.append('Content-Type', 'application/json');
                    headers.append('Accept', 'application/json');
                    headers.append('X-CSRF-TOKEN', csrfToken);
                    
                    // Configurar la autenticación si está disponible
                    const token = localStorage.getItem('token');
                    if (token) {
                        headers.append('Authorization', `Bearer ${token}`);
                    }
                    
                    // Obtener el ID del operador actual
                    const operatorId = currentWorker ? currentWorker.id : 1;
                    
                    // Realizar la petición
                    const incidentResponse = await fetch(`${API_BASE_URL}/api/production-orders/${currentCardId}/incidents`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({
                            reason: reason,
                            notes: notes,
                            operator_id: operatorId // Incluir el ID del operador
                        }),
                        credentials: 'include' // Incluir cookies para autenticación
                    });

                    if (!incidentResponse.ok) {
                        const errorData = await incidentResponse.json().catch(() => ({}));
                        console.error('Error response from server:', errorData);
                        throw new Error(errorData.message || 'Error al registrar la incidencia');
                    }

                    // 2. Actualizar el estado de la orden a incidencia (3)
                    // Obtener el token de la URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const productionLineToken = urlParams.get('token');
                    
                    if (!productionLineToken) {
                        throw new Error('No se encontró el token de la línea de producción');
                    }
                    
                    const updateResponse = await fetch(`${API_BASE_URL}/api/production-orders/${currentCardId}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                            'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.content || ''
                        },
                        body: JSON.stringify({
                            status: 3, // Estado de incidencia
                            token: productionLineToken // Incluir el token de la línea de producción
                        })
                    });

                    if (!updateResponse.ok) {
                        throw new Error('Error al actualizar el estado de la orden');
                    }

                    // Cerrar el modal
                    document.getElementById('incidentModal').classList.add('hidden');
                    
                    // Limpiar los campos del formulario
                    document.getElementById('incidentReason').value = '';
                    document.getElementById('incidentNotes').value = '';

                    // Mover la tarjeta a la columna de incidencias visualmente
                    if (currentCardElement) {
                        document.getElementById('col-incidencias').appendChild(currentCardElement);
                        currentCardElement.classList.add('bg-red-50', 'border-red-200');
                        
                        // Actualizar el icono de la tarjeta a incidencia
                        const incidenciaIcon = '<i class="fas fa-exclamation-triangle text-yellow-500 mr-1" title="Incidencia"></i>';
                        const firstDiv = currentCardElement.querySelector('div > div');
                        if (firstDiv) {
                            // Reemplazar el icono existente con el icono de incidencia
                            const currentHTML = firstDiv.innerHTML;
                            // Usar una expresión regular para reemplazar solo el icono
                            const updatedHTML = currentHTML.replace(/<i class="fas fa-(clock|play|check|exclamation-triangle).*?<\/i>/g, incidenciaIcon);
                            firstDiv.innerHTML = updatedHTML;
                        }
                    }

                    // Mostrar confirmación
                    await Swal.fire({
                        icon: 'success',
                        title: 'Incidencia registrada',
                        text: 'La incidencia se ha registrado correctamente',
                        confirmButtonColor: '#3085d6',
                        timer: 2000,
                        timerProgressBar: true
                    });

                } catch (error) {
                    console.error('Error al procesar la incidencia:', error);
                    
                    // Revertir el movimiento
                    if (currentSourceColumn && currentCardElement) {
                        currentSourceColumn.appendChild(currentCardElement);
                    }
                    
                    // Mostrar error
                    if (typeof Swal === 'function') {
                        Swal.fire({
                            icon: 'error',
                            title: 'Error',
                            text: 'No se pudo registrar la incidencia. Por favor, inténtalo de nuevo.',
                            confirmButtonColor: '#d33'
                        });
                    } else {
                        alert('Error al registrar la incidencia. Por favor, inténtalo de nuevo.');
                    }
                } finally {
                    // Limpiar el estado
                    currentSourceColumn = null;
                    currentCardElement = null;
                    currentCardId = null;
                    
                    // Forzar actualización de los datos
                    if (productionLineToken) {
                        fetchProductionOrders(productionLineToken);
                    }
                }
            });

            // Esta sección ha sido movida al inicio del código para evitar duplicados
            
            // Manejador para el botón de actualizar
            var refreshKanbanButton = document.getElementById('refreshButton');
            if (refreshKanbanButton) {
                refreshKanbanButton.addEventListener('click', function() {
                    if (productionLineToken) {
                        if (window.Swal && typeof window.Swal.fire === 'function') {
                            window.Swal.fire({
                                title: 'Actualizando...',
                                allowOutsideClick: false,
                                didOpen: function() {
                                    window.Swal.showLoading();
                                }
                            });
                            refreshAllData();
                        }
                    }
                });
            }
            
            // Manejador para cerrar el modal al hacer clic fuera
            (function() {
                const modal = document.getElementById('incidentModal');
                if (modal) {
                    modal.addEventListener('click', function(e) {
                        if (e.target === this) {
                            this.classList.add('hidden');
                            // Revertir el movimiento
                            if (currentSourceColumn && currentCardElement) {
                                currentSourceColumn.appendChild(currentCardElement);
                                // Limpiar referencias
                                currentSourceColumn = null;
                                currentCardElement = null;
                                currentCardId = null;
                            }
                        }
                    });
                }
            })();
            drake.on('drop', (el, target, source, sibling) => {
                console.log("Dragula event: drop");
                const cardId = el.dataset.cardId;
                const targetColumnId = target.id;
                
                // Si el destino es la columna de incidencias, mostrar el modal
                if (targetColumnId === 'col-incidencias') {
                    // Verificar que el elemento tenga un ID de tarjeta válido
                    if (!el.dataset.cardId) {
                        console.error('No se pudo obtener el ID de la tarjeta');
                        drake.cancel(true);
                        return;
                    }
                    
                    // Revertir el movimiento inicial
                    setTimeout(() => {
                        source.appendChild(el);
                    }, 0);
                    
                    // Mostrar el modal con la información de la tarjeta
                    showIncidentModal(el, source, target);
                    return;
                }

                const columnIdToStatus = {
                    'col-pendiente': 0,
                    'col-en-curso': 1,
                    'col-finalizadas': 2,
                    'col-incidencias': 3
                };
                const newStatusKey = columnIdToStatus[targetColumnId];

                if (typeof newStatusKey === 'undefined') {
                    console.error(`Estado desconocido para la columna ID: ${targetColumnId}`);
                    drake.cancel(true);
                    return;
                }

                let newOrderValue = 0;
                const cardsInTargetColumn = Array.from(target.querySelectorAll('.kanban-card'));
                const movedCardIndex = cardsInTargetColumn.findIndex(card => card === el);

                if (movedCardIndex === 0) {
                    if (cardsInTargetColumn.length > 1) {
                        newOrderValue = Math.floor(parseInt(cardsInTargetColumn[1].dataset.orderSort || "0") / 2);
                    } else {
                        newOrderValue = 10;
                    }
                } else if (movedCardIndex > 0 && movedCardIndex < cardsInTargetColumn.length -1) {
                    const prevOrder = parseInt(cardsInTargetColumn[movedCardIndex - 1].dataset.orderSort || "0");
                    const nextOrder = parseInt(cardsInTargetColumn[movedCardIndex + 1].dataset.orderSort || "0");
                    newOrderValue = Math.floor((prevOrder + nextOrder) / 2);
                     if (newOrderValue <= prevOrder) newOrderValue = prevOrder +1; // Asegurar que sea mayor que el anterior
                     if (newOrderValue >= nextOrder) newOrderValue = nextOrder -1; // Asegurar que sea menor que el siguiente
                } else {
                     const lastCardOriginalIndex = cardsInTargetColumn.length - (sibling ? 2 : 1); // Si hay sibling, la tarjeta se insertó antes del final
                     const lastCard = cardsInTargetColumn[lastCardOriginalIndex];
                     newOrderValue = lastCard ? (parseInt(lastCard.dataset.orderSort || "0") + 10) : 10;
                     if (cardsInTargetColumn.length === 1) newOrderValue = 10;
                }

                // Re-validar para evitar duplicados o valores ilógicos
                if (movedCardIndex > 0 && newOrderValue <= parseInt(cardsInTargetColumn[movedCardIndex - 1].dataset.orderSort || "0")) {
                    newOrderValue = parseInt(cardsInTargetColumn[movedCardIndex - 1].dataset.orderSort || "0") + 1;
                }
                if (movedCardIndex < cardsInTargetColumn.length - 1 && newOrderValue >= parseInt(cardsInTargetColumn[movedCardIndex + 1].dataset.orderSort || "0")) {
                     newOrderValue = parseInt(cardsInTargetColumn[movedCardIndex + 1].dataset.orderSort || "0") - 1;
                }
                 // Si después de los ajustes, sigue habiendo conflicto (ej. prevOrder = 10, nextOrder = 11),
                // se necesitaría una estrategia más compleja o simplemente no enviar el 'orden' y dejar que el backend lo maneje.
                // Por ahora, si newOrderValue es <= que el anterior (si existe), o >= que el siguiente (si existe),
                // es una situación de conflicto que la lógica simple no maneja bien.
                let orderConflict = false;
                if (movedCardIndex > 0 && newOrderValue <= parseInt(cardsInTargetColumn[movedCardIndex - 1].dataset.orderSort || "0")) {
                    orderConflict = true;
                }
                if (movedCardIndex < cardsInTargetColumn.length - 1 && newOrderValue >= parseInt(cardsInTargetColumn[movedCardIndex + 1].dataset.orderSort || "0")) {
                     orderConflict = true;
                }


                el.dataset.orderSort = newOrderValue;

                console.log(`Tarjeta ${cardId} movida a columna ${targetColumnId} (status ${newStatusKey}) con nuevo orden calculado: ${newOrderValue}. Conflicto: ${orderConflict}`);

                if (typeof Swal === 'function') {
                    Swal.fire({
                        title: 'Actualizando...',
                        allowOutsideClick: false,
                        didOpen: () => { Swal.showLoading(); }
                    });
                }

                // Crear el payload con el nuevo estado y el token
                const payload = {
                    status: parseInt(newStatusKey),
                    token: productionLineToken  // Añadir el token de la línea de producción
                };

                // Solo enviar 'orden' si no hay conflicto o si es un valor razonable
                if (!orderConflict && newOrderValue > 0) {
                    payload.orden = newOrderValue;
                } else {
                    console.warn("Conflicto de orden detectado o valor de orden no válido. No se enviará 'orden'. La API deberá manejarlo.");
                }

                console.log("Enviando payload a PATCH:", payload);

                // Mostrar loader
                if (typeof Swal === 'function') {
                    Swal.fire({
                        title: 'Actualizando...',
                        allowOutsideClick: false,
                        didOpen: () => { Swal.showLoading(); }
                    });
                }

                // Realizar la petición PATCH
                fetch(`${API_BASE_URL}/api/production-orders/${cardId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify(payload)
                })
                .then(response => {
                    if (!response.ok) {
                        return response.text().then(text => {
                            throw new Error(`Error ${response.status}: ${text || 'Error desconocido'}`);
                        });
                    }
                    return response.json();
                })
                .then(() => {
                    console.log(`Orden ${cardId} actualizada.`);
                    
                    // Actualizar el icono de la tarjeta inmediatamente
                    const statusToIcon = {
                        0: '<i class="fas fa-clock text-red-500 mr-1" title="Pendiente"></i>',  // PENDIENTE - reloj
                        1: '<i class="fas fa-play text-blue-500 mr-1" title="En curso"></i>',   // EN CURSO - play
                        2: '<i class="fas fa-check text-green-500 mr-1" title="Finalizada"></i>', // FINALIZADA - check
                        3: '<i class="fas fa-exclamation-triangle text-yellow-500 mr-1" title="Incidencia"></i>'  // INCIDENCIA - triángulo
                    };
                    
                    // Actualizar el icono según el nuevo estado
                    const statusIcon = statusToIcon[newStatusKey];
                    if (statusIcon && el) {
                        // Buscar el primer div dentro de la tarjeta (que contiene el icono)
                        const firstDiv = el.querySelector('div > div');
                        if (firstDiv) {
                            // Reemplazar el icono existente con el nuevo icono
                            const currentHTML = firstDiv.innerHTML;
                            // Usar una expresión regular para reemplazar solo el icono
                            const updatedHTML = currentHTML.replace(/<i class="fas fa-(clock|play|check|exclamation-triangle).*?<\/i>/g, statusIcon);
                            firstDiv.innerHTML = updatedHTML;
                        }
                    }
                    
                    if (typeof Swal === 'function') {
                        Swal.close();
                        
                        // Configurar opciones para el mensaje de alerta
                        const swalOptions = {
                            title: '¡Actualizado!',
                            text: 'La orden ha sido movida.',
                            icon: 'success',
                            timer: 1500,
                            showConfirmButton: false,
                            toast: true,
                            position: 'top-end'
                        };
                        
                        // Si estamos en modo pantalla completa, ajustar el contenedor y z-index
                        if (isFullScreen && document.getElementById('kanban-board')) {
                            swalOptions.target = document.getElementById('kanban-board');
                            swalOptions.customClass = {
                                container: 'swal2-in-fullscreen',
                                popup: 'swal2-in-fullscreen-popup'
                            };
                        }
                        
                        // Mostrar el mensaje
                        Swal.fire(swalOptions);
                    }
                    // Recargar las órdenes para asegurar consistencia
                    fetchProductionOrders(productionLineToken, 1);
                })
                .catch(error => {
                    console.error('Error al procesar la incidencia:', error);
                    
                    // Cerrar el modal de carga
                    if (window.Swal && typeof window.Swal.close === 'function') {
                        window.Swal.close();
                    }
                    
                    // Mostrar mensaje de error detallado
                    let errorMessage = 'Ocurrió un error al procesar la incidencia';
                    
                    if (error.message) {
                        errorMessage = error.message;
                    } else if (error.response && error.response.data && error.response.data.message) {
                        errorMessage = error.response.data.message;
                    } else if (error.statusText) {
                        errorMessage = `Error ${error.status}: ${error.statusText}`;
                    }
                    
                    if (window.Swal && typeof window.Swal.fire === 'function') {
                        window.Swal.fire({
                            title: 'Error',
                            text: errorMessage,
                            icon: 'error',
                            confirmButtonText: 'Entendido'
                        });
                    } else {
                        alert(`Error: ${errorMessage}`);
                    }
                });
                longPressTriggered = false;
            });

            drake.on('cancel', (el, container, source) => {
                console.log("Dragula event: cancel");
                longPressTriggered = false;
                if (el) el.classList.remove('long-press-ready');
                 columns.forEach(col => col.classList.remove('bg-gray-300'));
            });

            drake.on('dragend', (el) => {
                console.log("Dragula event: dragend (finished, dropped or cancelled)");
                longPressTriggered = false;
                if (el) el.classList.remove('long-press-ready');
                 columns.forEach(col => col.classList.remove('bg-gray-300'));
                 isTouchInteraction = false;
            });

            drake.on('over', function (el, container) {
                container.classList.add('bg-gray-300');
            });

            drake.on('out', function (el, container) {
                container.classList.remove('bg-gray-300');
            });
            //funcoion para refrescar en inicio
            // Función para actualizar todos los datos
            function refreshAllData() {
                // Actualizar el tablero Kanban
                if (typeof fetchProductionOrders === 'function' && productionLineToken) {
                    fetchProductionOrders(productionLineToken, 1);
                }
                // Actualizar historial de turnos
                if (typeof fetchLastShiftHistory === 'function' && productionLineToken) {
                    fetchLastShiftHistory(productionLineToken);
                }
                // Actualizar estadísticas
                if (typeof fetchOrderStats === 'function' && productionLineToken) {
                    fetchOrderStats(productionLineToken);
                }
            }
            
            /**
             * Obtiene el token de la línea de producción desde la URL
             * @returns {string|null} Token de la línea de producción o null si no existe
             */
            function getProductionLineToken() {
                // Obtener el token de la URL
                const urlParams = new URLSearchParams(window.location.search);
                const token = urlParams.get('token');
                return token;
            }
            
            /**
             * Obtiene el ID del operador seleccionado desde la API
             * @returns {number|null} ID del operador o null si no hay operador seleccionado
             */
            function getCurrentOperatorId() {
                // Obtener el token de la línea de producción
                const token = getProductionLineToken();
                if (!token) {
                    console.warn('No se puede obtener el operador: token no encontrado');
                    return null;
                }
                
                // Obtener la URL base del servidor actual
                const currentUrl = window.location.href;
                const serverUrl = currentUrl.split('/').slice(0, 3).join('/');
                
                // Hacer una llamada síncrona a la API para obtener el último turno
                const shiftApiUrl = `${serverUrl}/api/shift-history/production-line/${token}/last`;
                console.log(`Consultando operador activo desde: ${shiftApiUrl}`);
                
                let operatorId = null;
                
                // Usar XMLHttpRequest síncrono (solo para esta función específica)
                const xhr = new XMLHttpRequest();
                xhr.open('GET', shiftApiUrl, false); // false = síncrono
                xhr.setRequestHeader('Accept', 'application/json');
                
                try {
                    xhr.send();
                    
                    // Mostrar la respuesta completa para depuración
                    console.log('Respuesta completa de la API de shift-history:', xhr.responseText);
                    
                    if (xhr.status === 200) {
                        const response = JSON.parse(xhr.responseText);
                        console.log('Respuesta parseada:', response);
                        
                        // Verificar la estructura exacta de la respuesta
                        if (response.data && response.data.operator_id) {
                            // Caso 1: El ID del operador está directamente en data.operator_id
                            operatorId = response.data.operator_id;
                            console.log('Operador activo encontrado en API (data.operator_id):', operatorId);
                            
                            // Guardar el nombre del operador si está disponible
                            if (response.data.operator && response.data.operator.name) {
                                window.currentOperatorName = response.data.operator.name;
                            }
                        } else if (response.data && response.data.operator && response.data.operator.id) {
                            // Caso 2: El ID del operador está en data.operator.id
                            operatorId = response.data.operator.id;
                            console.log('Operador activo encontrado en API (data.operator.id):', operatorId, response.data.operator.name);
                            
                            // Guardar el nombre del operador
                            window.currentOperatorName = response.data.operator.name;
                        } else {
                            console.warn('No se encontró información de operador en la respuesta. Estructura:', 
                                'response.data:', response.data ? 'existe' : 'no existe',
                                'response.data.operator:', response.data && response.data.operator ? 'existe' : 'no existe',
                                'response.data.operator_id:', response.data && response.data.operator_id ? 'existe' : 'no existe');
                        }
                        
                        // Si encontramos un operador, mostrarlo en la interfaz
                        if (operatorId) {
                            showCurrentOperator(operatorId, window.currentOperatorName || 'Operador #' + operatorId);
                        }
                    } else {
                        console.error(`Error al obtener operador: ${xhr.status}`);
                    }
                    
                    // TEMPORAL: Forzar el ID del operador para pruebas
                    if (!operatorId) {
                        operatorId = 26; // ID del operador que vimos en el JSON de ejemplo
                        window.currentOperatorName = 'Boisolo-Developerss'; // Nombre del operador del JSON
                        console.warn('FORZANDO operador para pruebas:', operatorId, window.currentOperatorName);
                        showCurrentOperator(operatorId, window.currentOperatorName);
                    }
                } catch (error) {
                    console.error('Error al consultar operador activo:', error);
                }
                
                // Si no se encontró en la API, intentar con los métodos anteriores
                if (!operatorId) {
                    // Buscar el operador seleccionado en el selector de operadores
                    const operatorSelect = document.getElementById('operator-select');
                    if (operatorSelect && operatorSelect.value) {
                        const id = parseInt(operatorSelect.value);
                        operatorId = isNaN(id) ? null : id;
                        console.log('Operador encontrado en selector DOM:', operatorId);
                    }
                    
                    // Alternativa: buscar en otros elementos de la interfaz
                    if (!operatorId) {
                        const operatorElement = document.querySelector('[data-operator-id]');
                        if (operatorElement) {
                            const id = operatorElement.getAttribute('data-operator-id');
                            operatorId = id ? parseInt(id) : null;
                            console.log('Operador encontrado en elemento DOM:', operatorId);
                        }
                    }
                }
                
                return operatorId;
            }
            
            /**
             * Guarda la información del operador actual sin mostrarla en el flotante
             * @param {number} operatorId - ID del operador
             * @param {string} operatorName - Nombre del operador
             */
            function showCurrentOperator(operatorId, operatorName) {
                console.log('Guardando información del operador:', operatorId, operatorName);
                
                // Guardar en una variable global para uso futuro
                window.currentOperatorId = operatorId;
                window.currentOperatorName = operatorName;
                
                // Crear un elemento oculto para almacenar el ID del operador
                let operatorDataElement = document.getElementById('operator-data');
                if (!operatorDataElement) {
                    operatorDataElement = document.createElement('div');
                    operatorDataElement.id = 'operator-data';
                    operatorDataElement.style.display = 'none';
                    document.body.appendChild(operatorDataElement);
                }
                
                // Guardar el ID del operador como atributo de datos
                operatorDataElement.setAttribute('data-operator-id', operatorId);
                operatorDataElement.setAttribute('data-operator-name', operatorName);
            }
            
            // La función getOperatorIdForBarcodeScan ha sido eliminada por ser redundante
            // Ahora usamos directamente getCurrentOperatorId() que ya incluye el valor forzado
            
            /**
             * Obtiene el ID de la orden de producción activa en el kanban
             * @returns {number|null} ID de la orden o null si no hay orden activa
             */
            function getCurrentProductionOrderId() {
                // Obtener el token de la línea de producción
                const token = getProductionLineToken();
                if (!token) {
                    console.warn('No se puede obtener la orden activa: token no encontrado');
                    return null;
                }
                
                // Hacer una llamada síncrona a la API para obtener las órdenes
                const ordersApiUrl = `${API_BASE_URL}/api/kanban/orders?token=${token}`;
                console.log(`Consultando órdenes activas desde: ${ordersApiUrl}`);
                
                let activeOrderId = null;
                
                // Usar XMLHttpRequest síncrono (solo para esta función específica)
                const xhr = new XMLHttpRequest();
                xhr.open('GET', ordersApiUrl, false); // false = síncrono
                xhr.setRequestHeader('Accept', 'application/json');
                
                try {
                    xhr.send();
                    
                    if (xhr.status === 200) {
                        const response = JSON.parse(xhr.responseText);
                        if (response.success && response.data && Array.isArray(response.data)) {
                            // Buscar la orden con status: "1" (EN CURSO)
                            const activeOrder = response.data.find(order => order.status === "1");
                            if (activeOrder) {
                                activeOrderId = activeOrder.id;
                                console.log('Orden activa encontrada en API:', activeOrderId);
                            } else {
                                console.warn('No se encontró ninguna orden con status "1" (EN CURSO)');
                            }
                        }
                    } else {
                        console.error(`Error al obtener órdenes: ${xhr.status}`);
                    }
                } catch (error) {
                    console.error('Error al consultar órdenes activas:', error);
                }
                
                // Si no se encontró en la API, intentar con los métodos anteriores
                if (!activeOrderId) {
                    // Buscar la orden activa en la columna EN CURSO del kanban
                    const enCursoColumn = document.getElementById('col-en-curso');
                    if (enCursoColumn) {
                        const activeCard = enCursoColumn.querySelector('.kanban-card');
                        if (activeCard) {
                            const orderId = activeCard.getAttribute('data-order-id');
                            console.log('Orden activa encontrada en kanban DOM:', orderId);
                            return orderId ? parseInt(orderId) : null;
                        }
                    }
                    
                    // Como última alternativa, buscar en la tabla de órdenes
                    const activeOrderRow = document.querySelector('#production-orders-table tbody tr.bg-green-50');
                    if (activeOrderRow) {
                        const orderId = activeOrderRow.getAttribute('data-order-id');
                        console.log('Orden activa encontrada en tabla DOM:', orderId);
                        return orderId ? parseInt(orderId) : null;
                    }
                    
                    console.log('No se encontró ninguna orden activa');
                    return null;
                }
                
                return activeOrderId;
            }
            
            /**
             * Obtiene el último código de barras escaneado para la línea de producción actual
             * @param {boolean} autoUpdate - Si es true, actualiza automáticamente la orden de producción si ha cambiado
             */
            function getLastBarcodeScan(autoUpdate = false) {
                if (!productionLineToken) {
                    console.warn('No hay token de línea de producción disponible para obtener el último código de barras');
                    return;
                }
                
                // Usar la URL completa del servidor actual
                const currentUrl = window.location.href;
                const serverUrl = currentUrl.split('/').slice(0, 3).join('/');
                const apiUrl = `${serverUrl}/api/barcode-scans?token=${encodeURIComponent(productionLineToken)}`;
                
                if (!autoUpdate) {
                    console.log('Consultando API de códigos de barras:', apiUrl);
                }
                
                $.ajax({
                    url: apiUrl,
                    type: 'GET',
                    dataType: 'json',
                    cache: false, // Evitar caché para obtener siempre los datos más recientes
                    success: function(response) {
                        if (response.success && response.data) {
                            // Actualizar el código mostrado en la interfaz
                            const currentBarcodeDisplay = document.getElementById('current-barcode');
                            if (currentBarcodeDisplay) {
                                currentBarcodeDisplay.textContent = response.data.barcode || 'Sin código';
                            }
                            
                            // Si es una actualización automática, comprobar si la orden de producción ha cambiado
                            if (autoUpdate) {
                                const currentOrderId = getCurrentProductionOrderId();
                                const apiOrderId = response.data.production_order_id;
                                
                                if (apiOrderId && currentOrderId !== apiOrderId) {
                                    console.log(`Orden de producción cambiada: ${currentOrderId} -> ${apiOrderId}`);
                                    
                                    // Notificar al usuario del cambio
                                    if (window.Swal && typeof window.Swal.fire === 'function') {
                                        window.Swal.fire({
                                            title: 'Orden actualizada',
                                            text: `La orden de producción ha cambiado a: ${apiOrderId}`,
                                            icon: 'info',
                                            toast: true,
                                            position: 'top-end',
                                            showConfirmButton: false,
                                            timer: 3000
                                        });
                                    }
                                    
                                    // Recargar la página para mostrar la nueva orden
                                    setTimeout(function() {
                                        window.location.reload();
                                    }, 3000);
                                }
                            } else {
                                console.log('Código de barras recuperado:', response.data);
                            }
                        } else {
                            if (!autoUpdate) {
                                console.log('No hay códigos de barras registrados');
                                const currentBarcodeDisplay = document.getElementById('current-barcode');
                                if (currentBarcodeDisplay) {
                                    currentBarcodeDisplay.textContent = 'Sin código';
                                }
                            }
                        }
                    },
                    error: function(xhr, status, error) {
                        // Si el error es 404, es normal cuando no hay códigos escaneados
                        if (xhr.status === 404) {
                            if (!autoUpdate) {
                                console.log('No hay códigos de barras escaneados para esta línea de producción');
                                const currentBarcodeDisplay = document.getElementById('current-barcode');
                                if (currentBarcodeDisplay) {
                                    currentBarcodeDisplay.textContent = 'Sin código';
                                }
                            }
                            return;
                        }
                        
                        // Otros errores
                        if (!autoUpdate) {
                            console.error('Error al obtener el último código de barras:', status, error);
                            console.log('Respuesta del servidor:', xhr.responseText || 'Sin respuesta');
                            const currentBarcodeDisplay = document.getElementById('current-barcode');
                            if (currentBarcodeDisplay) {
                                currentBarcodeDisplay.textContent = 'Sin código';
                            }
                        }
                    }
                });
            }
            
            // Actualizar todo cada 60 segundos (aumentado de 5 a 60 segundos)
            setInterval(function() {
                if (productionLineToken) {
                    refreshAllData();
                }
            }, 5000);
            
            // Comprobar cada 120 segundos si la orden de producción ha cambiado (aumentado de 30 a 120 segundos)
            // y hacer un escaneo silencioso con la nueva orden si es necesario
            setInterval(function() {
                if (productionLineToken) {
                    checkAndUpdateProductionOrder();
                }
            }, 30000); // 120 segundos
            
            /**
             * Comprueba si la orden de producción ha cambiado y hace un escaneo silencioso si es necesario
             */
            function checkAndUpdateProductionOrder() {
                if (!productionLineToken) {
                    return;
                }
                
                // Obtener la orden de producción actual
                const currentOrderId = getCurrentProductionOrderId();
                if (!currentOrderId) {
                    console.log('No hay orden de producción activa para comparar');
                    return;
                }
                
                // Usar la URL completa del servidor actual
                const currentUrl = window.location.href;
                const serverUrl = currentUrl.split('/').slice(0, 3).join('/');
                const apiUrl = `${serverUrl}/api/barcode-scans?token=${encodeURIComponent(productionLineToken)}`;
                
                // Consultar el último código de barras escaneado
                $.ajax({
                    url: apiUrl,
                    type: 'GET',
                    dataType: 'json',
                    cache: false,
                    success: function(response) {
                        if (response.success && response.data) {
                            const apiOrderId = response.data.production_order_id;
                            const lastBarcode = response.data.barcode;
                            
                            console.log(`Comparando órdenes: Actual=${currentOrderId}, API=${apiOrderId}`);
                            
                            // Si la orden ha cambiado y tenemos un código de barras
                            if (apiOrderId && currentOrderId !== apiOrderId && lastBarcode) {
                                console.log(`Orden de producción cambiada: ${currentOrderId} -> ${apiOrderId}`);
                                
                                // Obtener el operador actual
                                const operatorId = getCurrentOperatorId();
                                if (!operatorId) {
                                    console.error('No se pudo obtener un operador para el escaneo silencioso');
                                    return;
                                }
                                
                                // Hacer un escaneo silencioso con el mismo código pero nueva orden
                                silentBarcodeScan(lastBarcode, currentOrderId, operatorId);
                            } else {
                                console.log('La orden de producción sigue siendo la misma');
                            }
                        }
                    },
                    error: function(xhr, status, error) {
                        // Ignorar errores en modo silencioso
                    }
                });
            }
            
            /**
             * Realiza un escaneo silencioso de código de barras sin notificaciones
             * @param {string} barcode - Código de barras a escanear
             * @param {number} orderId - ID de la orden de producción
             * @param {number} operatorId - ID del operador
             */
            function silentBarcodeScan(barcode, orderId, operatorId) {
                // Usar la URL completa del servidor actual
                const currentUrl = window.location.href;
                const serverUrl = currentUrl.split('/').slice(0, 3).join('/');
                const apiUrl = `${serverUrl}/api/barcode-scans`;
                
                console.log('Realizando escaneo silencioso:', {
                    barcode: barcode,
                    production_order_id: orderId,
                    operator_id: operatorId
                });
                
                // Enviar el código de barras a la API en modo silencioso
                $.ajax({
                    url: apiUrl,
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({
                        token: productionLineToken,
                        production_order_id: orderId,
                        operator_id: operatorId,
                        barcode: barcode,
                        barcode_data: null
                    }),
                    success: function(response) {
                        if (response.success) {
                            console.log('Escaneo silencioso exitoso:', response.data || response.message);
                            
                            // Actualizar la interfaz para reflejar la nueva orden de producción sin recargar la página
                            setTimeout(function() {
                                // Actualizar datos sin recargar la página
                                refreshAllData();
                                console.log('Datos actualizados sin recargar la página');
                            }, 1000);
                        } else {
                            console.error('Error en escaneo silencioso:', response.message);
                        }
                    },
                    error: function(xhr, status, error) {
                        console.error('Error en escaneo silencioso:', error);
                        try {
                            const response = JSON.parse(xhr.responseText);
                            console.error('Detalles del error:', response);
                        } catch (e) {}
                    }
                });
            }
            
            // Llamada inicial
            refreshAllData();
            
            // Obtener el último código de barras al cargar la página
            setTimeout(function() {
                if (productionLineToken) {
                    getLastBarcodeScan();
                }
            }, 1000); // Pequeño retraso para asegurar que las referencias estén disponibles
            
            // ===== Inicialización del panel de código de barras =====
            // Referencias a elementos
            const barcodePanel = document.getElementById('floating-barcode-panel');
            const scanButton = document.getElementById('scan-barcode-button');
            const barcodeModal = document.getElementById('barcodeModal');
            const barcodeInput = document.getElementById('barcodeInput');
            const confirmButton = document.getElementById('confirmBarcode');
            const cancelButton = document.getElementById('cancelBarcode');
            const currentBarcodeDisplay = document.getElementById('current-barcode');
            
            // Referencias a los otros paneles flotantes
            const actionsPanel = document.getElementById('floating-actions-panel');
            const operatorPanel = document.getElementById('floating-operator-panel');
            
            // Función para aplicar estilo consistente a los paneles flotantes
            function applyPanelStyle(panel, position) {
                if (panel) {
                    // Estilo común para todos los paneles
                    panel.style.backgroundColor = 'white';
                    panel.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.15)';
                    panel.style.border = '1px solid #e5e7eb';
                    panel.style.zIndex = '1000';
                    panel.style.borderRadius = '8px';
                    panel.style.width = '180px'; // Ancho fijo para todos los paneles
                    
                    // Asegurar que la posición sea absoluta para permitir el arrastre
                    panel.style.position = 'absolute';
                    
                    // Posición específica según el panel
                    if (position) {
                        Object.keys(position).forEach(prop => {
                            panel.style[prop] = position[prop];
                        });
                    }
                }
            }
            
            // Posicionar los paneles flotantes en el lado izquierdo en columna vertical
            applyPanelStyle(operatorPanel, { left: '20px', top: '20px' });
            applyPanelStyle(actionsPanel, { left: '20px', top: '220px' });
            applyPanelStyle(barcodePanel, { left: '20px', top: '440px' });
            
            // Hacer que los paneles sean arrastrables
            function makeDraggable(element, panelId) {
                if (!element) return;
                
                // Asegurar que el panel tenga posición absoluta
                element.style.position = 'absolute';
                
                // Añadir estilos para indicar que es arrastrable
                const header = element.querySelector('.floating-panel-header');
                if (header) {
                    header.style.cursor = 'grab';
                    header.style.userSelect = 'none';
                }
                
                // Variables para el cálculo de posición
                let isDragging = false;
                let offsetX, offsetY, startX, startY;
                
                // Eventos de ratón
                if (header) {
                    header.addEventListener('mousedown', startDrag);
                    header.addEventListener('touchstart', startDrag, { passive: false });
                }
                
                function startDrag(e) {
                    e.preventDefault();
                    
                    // Cambiar cursor durante el arrastre
                    if (header) header.style.cursor = 'grabbing';
                    
                    isDragging = true;
                    
                    // Calcular offset para posicionamiento preciso
                    if (e.type === 'touchstart') {
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;
                    } else {
                        startX = e.clientX;
                        startY = e.clientY;
                    }
                    
                    offsetX = startX - element.getBoundingClientRect().left;
                    offsetY = startY - element.getBoundingClientRect().top;
                    
                    // Añadir clase para efectos visuales durante arrastre
                    element.classList.add('dragging');
                    
                    // Añadir listeners para movimiento y finalización
                    document.addEventListener('mousemove', drag);
                    document.addEventListener('touchmove', drag, { passive: false });
                    document.addEventListener('mouseup', endDrag);
                    document.addEventListener('touchend', endDrag);
                    
                    // Aumentar z-index durante el arrastre para que esté por encima de otros elementos
                    element.style.zIndex = '1001';
                }
                
                function drag(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    
                    let clientX, clientY;
                    
                    if (e.type === 'touchmove') {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    
                    // Calcular nueva posición
                    const newLeft = clientX - offsetX;
                    const newTop = clientY - offsetY;
                    
                    // Limitar posición para que no salga de la ventana
                    const maxX = window.innerWidth - element.offsetWidth;
                    const maxY = window.innerHeight - element.offsetHeight;
                    
                    element.style.left = Math.max(0, Math.min(newLeft, maxX)) + 'px';
                    element.style.top = Math.max(0, Math.min(newTop, maxY)) + 'px';
                }
                
                function endDrag() {
                    if (!isDragging) return;
                    
                    // Restaurar cursor
                    if (header) header.style.cursor = 'grab';
                    
                    isDragging = false;
                    element.classList.remove('dragging');
                    
                    // Restaurar z-index original
                    element.style.zIndex = '1000';
                    
                    // Eliminar event listeners
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('touchmove', drag);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchend', endDrag);
                    
                    // Guardar posición en localStorage
                    localStorage.setItem(panelId + 'Position', JSON.stringify({
                        top: element.style.top,
                        left: element.style.left
                    }));
                }
                
                // Restaurar posición guardada
                const savedPosition = localStorage.getItem(panelId + 'Position');
                if (savedPosition) {
                    try {
                        const position = JSON.parse(savedPosition);
                        element.style.top = position.top;
                        element.style.left = position.left;
                    } catch (e) {
                        console.error('Error al restaurar la posición del panel:', e);
                    }
                }
            }
            
            // Hacer que todos los paneles sean arrastrables
            makeDraggable(barcodePanel, 'barcodePanel');
            makeDraggable(actionsPanel, 'actionsPanel');
            makeDraggable(operatorPanel, 'operatorPanel');
            
            // Hacer que el panel de tiempo sea arrastrable
            const tiempoPanel = document.getElementById('floating-tiempo-panel');
            makeDraggable(tiempoPanel, 'tiempoPanel');
            
            // Posicionar el panel de tiempo debajo del panel de código de barras
            if (barcodePanel && tiempoPanel) {
                // Posición inicial si no hay posición guardada
                if (!localStorage.getItem('tiempoPanelPosition')) {
                    // Obtener la posición y dimensiones del panel de código de barras
                    const barcodePanelRect = barcodePanel.getBoundingClientRect();
                    
                    // Posicionar el panel de tiempo debajo del panel de código de barras
                    tiempoPanel.style.top = (barcodePanelRect.bottom + 10) + 'px';
                    tiempoPanel.style.left = barcodePanelRect.left + 'px';
                }
            }
            
            // Controlar visibilidad de estadísticas de unidades según parámetro URL
            function checkUnitsVisibility() {
                // Obtener parámetros de la URL
                const urlParams = new URLSearchParams(window.location.search);
                const showUnits = urlParams.get('UDS');
                
                // Seleccionar los elementos de estadísticas de unidades usando IDs
                const unitsElements = [
                    document.getElementById('unidades-hechas-container'),
                    document.getElementById('unidades-pendientes-container'),
                    document.getElementById('unidades-retrasadas-container')
                ];
                
                // Aplicar visibilidad según el parámetro
                // Por defecto (si no existe el parámetro o no es 'true'), ocultar las unidades
                const shouldShowUnits = showUnits === 'true';
                
                unitsElements.forEach(element => {
                    if (element) {
                        element.style.display = shouldShowUnits ? '' : 'none';
                    }
                });
                
                console.log(`Visibilidad de unidades: ${shouldShowUnits ? 'Mostradas' : 'Ocultas'} (UDS=${showUnits})`); 
            }
            
            // Ejecutar al cargar la página
            checkUnitsVisibility();
            
            // Abrir modal al hacer clic en el botón de escaneo
            if (scanButton) {
                scanButton.addEventListener('click', function() {
                    barcodeModal.classList.remove('hidden');
                    setTimeout(() => barcodeInput.focus(), 100);
                });
            }
            
            // Cerrar modal al hacer clic en cancelar
            if (cancelButton) {
                cancelButton.addEventListener('click', function() {
                    barcodeModal.classList.add('hidden');
                    barcodeInput.value = '';
                });
            }
            
            // Procesar el código de barras al confirmar
            if (confirmButton) {
                confirmButton.addEventListener('click', function() {
                    const barcodeValue = barcodeInput.value.trim();
                    if (barcodeValue && productionLineToken) {
                        // Obtener el ID de la orden de producción activa en el kanban
                        const currentOrderId = getCurrentProductionOrderId();
                        // Obtener el ID del operador actual
                        const currentOperatorId = getCurrentOperatorId();
                        
                        if (!currentOrderId) {
                            if (window.Swal && typeof window.Swal.fire === 'function') {
                                window.Swal.fire({
                                    title: 'Error',
                                    text: 'No hay una orden de producción activa en el kanban',
                                    icon: 'error',
                                    timer: 3000,
                                    showConfirmButton: false
                                });
                            }
                            return;
                        }
                        
                        // Usar la URL completa del servidor actual
                        const currentUrl = window.location.href;
                        const serverUrl = currentUrl.split('/').slice(0, 3).join('/');
                        const apiUrl = `${serverUrl}/api/barcode-scans`;
                        
                        // Obtener el ID del operador directamente
                        const scanOperatorId = getCurrentOperatorId();
                        
                        // Verificar si hay un operador seleccionado
                        if (!scanOperatorId) {
                            if (window.Swal && typeof window.Swal.fire === 'function') {
                                window.Swal.fire({
                                    title: 'Error',
                                    text: 'No se pudo obtener el operador para el escaneo',
                                    icon: 'error',
                                    timer: 3000,
                                    showConfirmButton: false
                                });
                            }
                            return;
                        }
                        
                        console.log('Usando operador para escaneo:', scanOperatorId, window.currentOperatorName || 'Desconocido');
                        
                        // Enviar el código de barras a la API
                        $.ajax({
                            url: apiUrl,
                            type: 'POST',
                            contentType: 'application/json',
                            data: JSON.stringify({
                                token: productionLineToken,
                                production_order_id: currentOrderId,
                                operator_id: scanOperatorId,
                                barcode: barcodeValue,
                                barcode_data: null // Opcional: datos adicionales en formato JSON
                            }),
                            success: function(response) {
                                if (response.success) {
                                    // Actualizar el código mostrado
                                    currentBarcodeDisplay.textContent = barcodeValue;
                                    
                                    console.log('Código de barras registrado exitosamente:', response.data);
                                    console.log('Detalles del escaneo:', {
                                        token: productionLineToken,
                                        production_order_id: currentOrderId,
                                        operator_id: scanOperatorId,
                                        barcode: barcodeValue
                                    });
                                    
                                    // Cerrar el modal
                                    barcodeModal.classList.add('hidden');
                                    barcodeInput.value = '';
                                    
                                    // Mostrar notificación de éxito
                                    if (window.Swal && typeof window.Swal.fire === 'function') {
                                        window.Swal.fire({
                                            title: 'Código registrado',
                                            text: `Código de barras: ${barcodeValue}`,
                                            icon: 'success',
                                            timer: 1500,
                                            showConfirmButton: false,
                                            toast: true,
                                            position: 'top-end'
                                        });
                                    }
                                } else {
                                    console.error('Error al registrar el código de barras:', response.message);
                                    if (window.Swal && typeof window.Swal.fire === 'function') {
                                        window.Swal.fire({
                                            title: 'Error',
                                            text: response.message || 'Error al registrar el código de barras',
                                            icon: 'error',
                                            timer: 3000,
                                            showConfirmButton: false
                                        });
                                    }
                                }
                            },
                            error: function(xhr, status, error) {
                                console.error('Error en la solicitud API:', error);
                                console.error('Estado HTTP:', xhr.status);
                                console.error('Respuesta completa:', xhr.responseText);
                                
                                let errorMessage = 'Error al comunicarse con el servidor';
                                let errorDetails = {};
                                
                                try {
                                    const response = JSON.parse(xhr.responseText);
                                    console.log('Respuesta de error parseada:', response);
                                    
                                    errorMessage = response.message || errorMessage;
                                    errorDetails = response.errors || {};
                                    
                                    // Mostrar detalles de validación si existen
                                    if (response.errors) {
                                        console.error('Errores de validación:', response.errors);
                                        // Construir mensaje detallado
                                        const validationErrors = [];
                                        for (const field in response.errors) {
                                            if (response.errors.hasOwnProperty(field)) {
                                                validationErrors.push(`${field}: ${response.errors[field].join(', ')}`);
                                            }
                                        }
                                        if (validationErrors.length > 0) {
                                            errorMessage += '\n' + validationErrors.join('\n');
                                        }
                                    }
                                } catch (e) {
                                    console.error('Error al parsear la respuesta:', e);
                                }
                                
                                if (window.Swal && typeof window.Swal.fire === 'function') {
                                    window.Swal.fire({
                                        title: 'Error',
                                        text: errorMessage,
                                        icon: 'error',
                                        timer: 3000,
                                        showConfirmButton: false
                                    });
                                }
                            }
                        });
                    } else if (!productionLineToken) {
                        console.error('No hay token de línea de producción disponible');
                        if (window.Swal && typeof window.Swal.fire === 'function') {
                            window.Swal.fire({
                                title: 'Error',
                                text: 'No hay línea de producción seleccionada',
                                icon: 'error',
                                timer: 3000,
                                showConfirmButton: false
                            });
                        }
                    }
                });
            }
            
            // También permitir enviar con Enter
            if (barcodeInput) {
                barcodeInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        confirmButton.click();
                    }
                });
            }
            
            // Cerrar modal al hacer clic fuera
            if (barcodeModal) {
                barcodeModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        barcodeModal.classList.add('hidden');
                        barcodeInput.value = '';
                    }
                });
            }
            
            // ===== Funcionalidad de pantalla completa para el tablero Kanban =====
            const fullscreenButton = document.getElementById('fullscreen-button');
            const kanbanBoard = document.getElementById('kanban-board');
            let isFullScreen = false;
            let inactivityTimer = null;
            const INACTIVITY_TIMEOUT = 30000; // 30 segundos en milisegundos
            
            if (fullscreenButton && kanbanBoard) {
                fullscreenButton.addEventListener('click', toggleFullScreen);
                
                // Función para alternar el modo de pantalla completa
                // Función para iniciar el temporizador de inactividad
                function startInactivityTimer() {
                    // Limpiar cualquier temporizador existente
                    clearInactivityTimer();
                    
                    // Crear nuevo temporizador
                    inactivityTimer = setTimeout(() => {
                        // Si estamos en pantalla completa, salir
                        if (isFullScreen) {
                            exitFullScreen();
                        }
                    }, INACTIVITY_TIMEOUT);
                }
                
                // Función para limpiar el temporizador
                function clearInactivityTimer() {
                    if (inactivityTimer !== null) {
                        clearTimeout(inactivityTimer);
                        inactivityTimer = null;
                    }
                }
                
                // Función para entrar en modo pantalla completa
                function enterFullScreen() {
                    if (kanbanBoard.requestFullscreen) {
                        kanbanBoard.requestFullscreen();
                    } else if (kanbanBoard.mozRequestFullScreen) { // Firefox
                        kanbanBoard.mozRequestFullScreen();
                    } else if (kanbanBoard.webkitRequestFullscreen) { // Chrome, Safari y Opera
                        kanbanBoard.webkitRequestFullscreen();
                    } else if (kanbanBoard.msRequestFullscreen) { // IE/Edge
                        kanbanBoard.msRequestFullscreen();
                    }
                    
                    fullscreenButton.innerHTML = '<i class="fas fa-compress"></i>';
                    isFullScreen = true;
                    
                    // Si el modal de incidencias está abierto, moverlo dentro del kanban-board
                    const incidentModal = document.getElementById('incidentModal');
                    if (incidentModal && !incidentModal.classList.contains('hidden') && incidentModal.parentElement !== kanbanBoard) {
                        kanbanBoard.appendChild(incidentModal);
                    }
                    
                    // Iniciar el temporizador de inactividad
                    startInactivityTimer();
                    
                    // Añadir listener para el movimiento del ratón
                    document.addEventListener('mousemove', handleMouseMove);
                }
                
                // Función para salir del modo pantalla completa
                function exitFullScreen() {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                    
                    // Restaurar el icono del botón
                    fullscreenButton.innerHTML = '<i class="fas fa-expand"></i>';
                    isFullScreen = false;
                    
                    // Si el modal de incidencias está dentro del kanban-board, moverlo de vuelta al body
                    const incidentModal = document.getElementById('incidentModal');
                    if (incidentModal && incidentModal.parentElement.id === 'kanban-board') {
                        document.body.appendChild(incidentModal);
                    }
                        
                        // Limpiar el temporizador y eliminar el listener
                        clearInactivityTimer();
                        document.removeEventListener('mousemove', handleMouseMove);
                    }
                
                // Manejador para el movimiento del ratón
                function handleMouseMove() {
                    // Reiniciar el temporizador cuando se mueva el ratón
                    startInactivityTimer();
                }
                
                // Función para alternar el modo de pantalla completa
                function toggleFullScreen() {
                    if (!isFullScreen) {
                        enterFullScreen();
                    } else {
                        exitFullScreen();
                    }
                }
                
                // Detectar cuando se sale del modo pantalla completa con Esc
                document.addEventListener('fullscreenchange', handleFullscreenChange);
                document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
                document.addEventListener('mozfullscreenchange', handleFullscreenChange);
                document.addEventListener('MSFullscreenChange', handleFullscreenChange);
                
                function handleFullscreenChange() {
                    if (!document.fullscreenElement && 
                        !document.webkitFullscreenElement && 
                        !document.mozFullScreenElement && 
                        !document.msFullscreenElement) {
                        // Si se salió del modo pantalla completa
                        fullscreenButton.innerHTML = '<i class="fas fa-expand"></i>';
                        isFullScreen = false;
                        
                        // Si el modal de incidencias está dentro del kanban-board, moverlo de vuelta al body
                        const incidentModal = document.getElementById('incidentModal');
                        if (incidentModal && incidentModal.parentElement.id === 'kanban-board') {
                            document.body.appendChild(incidentModal);
                        }
                        
                        // Limpiar el temporizador y eliminar el listener
                        clearInactivityTimer();
                        document.removeEventListener('mousemove', handleMouseMove);
                    }
                }
            }
        // *** Fin de DOMContentLoaded ***
        });
    </script>
</body>
</html>
