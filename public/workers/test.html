<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Kanban - Ocupación y Botones</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <style>
        /* --- Fuentes y Body --- */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior-y: contain;
        }
        /* --- Estilos Círculo de Progreso Dinámico (sin cambios) --- */
        .progress-circle {
            width: 180px; height: 180px; border-radius: 50%; display: grid; place-items: center;
            background: conic-gradient(#4ade80 calc(var(--progress-percent, 0) * 1%), #e5e7eb 0);
            position: relative; font-size: 2.8rem; font-weight: bold; color: #16a34a; transition: background 0.3s ease;
        }
        .progress-circle::before {
            content: ""; position: absolute; border-radius: 50%; inset: 14px; background: #fff; z-index: 1;
        }
        #progress-value { z-index: 2; position: relative; }

        /* --- Estilos Tarjeta Kanban Refactorizados (sin cambios) --- */
        .kanban-card {
            padding: 0.75rem; border-radius: 0.375rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            border-width: 1px; margin-bottom: 0.75rem; cursor: grab;
            font-size: 0.875rem; line-height: 1.25rem; border-style: solid;
            touch-action: manipulation; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
        }
        #col-pendiente .kanban-card { background-color: #fefce8; border-color: #fde68a; }
        #col-en-curso .kanban-card { background-color: #eff6ff; border-color: #bfdbfe; }
        #col-finalizadas .kanban-card { background-color: #f9fafb; border-color: #e5e7eb; }
        #col-incidencias .kanban-card { background-color: #fef2f2; border-color: #fecaca; }

        /* --- Estilos Etiquetas OPE (sin cambios) --- */
         .ope-tag {
            display: inline-block; padding-left: 0.5rem; padding-right: 0.5rem;
            padding-top: 0.125rem; padding-bottom: 0.125rem; border-radius: 0.25rem;
            font-size: 0.75rem; font-weight: 500; margin-right: 0.25rem; margin-bottom: 0.25rem;
            line-height: 1;
        }
        .ope-pendiente { background-color: #fef08a; color: #a16207; }
        .ope-en-curso { background-color: #bfdbfe; color: #1e40af; }
        .ope-finalizada { background-color: #bbf7d0; color: #166534; }
        .ope-incidencia { background-color: #fecaca; color: #991b1b; }
        .ope-default { background-color: #e5e7eb; color: #374151; }

        /* --- Otros estilos (Columnas, Títulos, Dragula, Select2, Hidden) (sin cambios) --- */
        .kanban-column { background-color: #f3f4f6; padding: 1rem; border-radius: 0.5rem; height: 100%; min-height: 200px; }
        .kanban-title { font-weight: 600; color: #374151; margin-bottom: 1rem; text-align: center; }
        .gu-mirror {
            padding: 0.75rem; border-radius: 0.375rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); border-width: 1px; font-size: 0.875rem; line-height: 1.25rem; border-style: solid;
            opacity: 0.8 !important; position: fixed !important; cursor: grabbing !important; z-index: 9999 !important; touch-action: none; margin-bottom: 0;
        }
        #col-pendiente .gu-mirror { background-color: #fefce8; border-color: #fde68a; }
        #col-en-curso .gu-mirror { background-color: #eff6ff; border-color: #bfdbfe; }
        #col-finalizadas .gu-mirror { background-color: #f9fafb; border-color: #e5e7eb; }
        #col-incidencias .gu-mirror { background-color: #fef2f2; border-color: #fecaca; }
        .gu-transit { opacity: 0.5; }
        .long-press-ready { /* Estilo opcional */ }
        .select2-container--default .select2-selection--single { border: 1px solid #d1d5db; border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); height: 2.5rem; }
        .select2-container--default .select2-selection--single .select2-selection__rendered { line-height: 2.5rem; padding-left: 0.75rem; }
        .select2-container--default .select2-selection--single .select2-selection__arrow { height: calc(2.5rem - 2px); }
        .select2-dropdown { border: 1px solid #d1d5db; border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
        .select2-search--dropdown .select2-search__field { border: 1px solid #d1d5db; border-radius: 0.375rem; margin: 0.25rem; }
        .hidden { display: none; }

        /* Estilo base para los iconos de acción */
        #action-buttons-container .action-icon {
           font-size: 3rem; /* Tamaño del icono */
           line-height: 1;
           transition: color 0.15s ease-in-out, opacity 0.15s ease-in-out; /* Transición suave */
           opacity: 0.6; /* Opacidad reducida por defecto */
        }
         /* Estilo base para los botones de acción */
        .action-button {
            width: 64px; /* Ancho */
            height: 64px; /* Alto */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem; /* Esquinas redondeadas (cuadrado) */
            background-color: transparent; /* Sin fondo por defecto */
            box-shadow: none; /* Sin sombra por defecto */
            transition: background-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out; /* Transición suave */
        }

        /* --- Colores de icono por defecto --- */
        /* Icono Play/Resume: Verde por defecto */
        #start-shift-button .action-icon,
        #resume-button .action-icon {
            color: #22c55e; /* green-500 */
        }
        /* Icono Pause: Amarillo por defecto */
        #start-pause-button .action-icon {
            color: #eab308; /* yellow-500 */
        }
        /* Icono Stop: Rojo por defecto */
        #end-shift-button .action-icon,
        #end-pause-button .action-icon {
            color: #ef4444; /* red-500 */
        }

        /* --- Estilo al pasar el ratón por encima (Hover) --- */
        .action-button:hover {
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* Sombra suave */
        }

        /* Icono se vuelve blanco y opaco al pasar el ratón (REGLA CORREGIDA) */
        #start-shift-button:hover .action-icon,
        #resume-button:hover .action-icon,
        #start-pause-button:hover .action-icon,
        #end-shift-button:hover .action-icon,
        #end-pause-button:hover .action-icon {
            color: white !important; /* Icono blanco - Añadido !important por si acaso */
            opacity: 1 !important; /* Opacidad completa - Añadido !important por si acaso */
        }

        /* Fondo del botón aparece al pasar el ratón */
        #start-shift-button:hover, #resume-button:hover { background-color: #22c55e; } /* green-500 */
        #start-pause-button:hover { background-color: #eab308; } /* yellow-500 */
        #end-shift-button:hover, #end-pause-button:hover { background-color: #ef4444; } /* red-500 */

    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      @font-face { font-family: 'LucideIcons'; src: url('https://cdn.jsdelivr.net/npm/lucide-static@latest/font/lucide.ttf') format('truetype'); }
      .lucide { font-family: 'LucideIcons'; font-style: normal; font-weight: normal; font-variant: normal; text-rendering: auto; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; display: inline-block; vertical-align: middle; }
    </style>
</head>
<body class="bg-gray-200 p-8">
    <div class="container mx-auto bg-white p-6 rounded-lg shadow-md">

        <div id="kanban-board" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-6 mb-6">
            <div id="col-pendiente" data-column-name="PENDIENTE" class="kanban-column">
                <h2 class="kanban-title">PENDIENTE</h2>
                <div class="kanban-card" data-card-id="card-1">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003552-02</span>
                        <span class="text-gray-600">CLIENTE 062</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-pendiente">OPE-01</span>
                        <span class="ope-tag ope-pendiente">OPE-02</span>
                        <span class="ope-tag ope-pendiente">OPE-03</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>05/03/2025</span>
                        <span>MATERIAL A0015</span>
                        <span class="font-medium text-gray-700">411 Uds</span>
                    </div>
                </div>
                 <div class="kanban-card" data-card-id="card-2">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-002252-01</span>
                        <span class="text-gray-600">CLIENTE 019</span>
                    </div>
                    <div class="mb-2 flex items-center">
                        <span class="ope-tag ope-pendiente">OPE-01</span>
                        <span class="ope-tag ope-pendiente">OPE-02</span>
                        <span class="ope-tag ope-pendiente">OPE-03</span>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-red-500 ml-1 inline-block align-middle">
                            <path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
                            <path d="M12 9v4"/>
                            <path d="M12 17h.01"/>
                        </svg>
                        </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>04/03/2025</span>
                        <span>MATERIAL A0013</span>
                        <span class="font-medium text-gray-700">244 Uds</span>
                    </div>
                </div>
                 <div class="kanban-card" data-card-id="card-3">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">OTRA-TAREA-01</span>
                        <span class="text-gray-600">CLIENTE XYZ</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-pendiente">OPE-04</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>14/04/2025</span>
                        <span>MATERIAL B0001</span>
                        <span class="font-medium text-gray-700">50 Uds</span>
                    </div>
                </div>
            </div>
            <div id="col-en-curso" data-column-name="EN CURSO" class="kanban-column">
                <h2 class="kanban-title">EN CURSO</h2>
                 <div class="kanban-card" data-card-id="card-4">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003516-02</span>
                        <span class="text-gray-600">CLIENTE 033</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-en-curso">OPE-01</span>
                        <span class="ope-tag ope-en-curso">OPE-02</span>
                        <span class="ope-tag ope-default">OPE-03</span> </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>05/03/2025</span>
                        <span>MATERIAL A00223</span>
                        <span class="font-medium text-gray-700">105 Uds</span>
                    </div>
                </div>
            </div>
            <div id="col-finalizadas" data-column-name="FINALIZADAS" class="kanban-column">
                <h2 class="kanban-title">FINALIZADAS</h2>
                 <div class="kanban-card" data-card-id="card-5">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003552-02</span>
                        <span class="text-gray-600">CLIENTE 0221</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-finalizada">OPE-01</span>
                        <span class="ope-tag ope-default">OPE-02</span>
                        <span class="ope-tag ope-default">OPE-03</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>04/03/2025</span>
                        <span>MATERIAL A0015</span>
                        <span class="font-medium text-gray-700">71 Uds</span>
                    </div>
                </div>
                 <div class="kanban-card" data-card-id="card-6">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003552-02</span>
                        <span class="text-gray-600">CLIENTE 087</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-finalizada">OPE-01</span>
                        <span class="ope-tag ope-default">OPE-02</span>
                        <span class="ope-tag ope-default">OPE-03</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>03/03/2025</span>
                        <span>MATERIAL A0054</span>
                        <span class="font-medium text-gray-700">121 Uds</span>
                    </div>
                </div>
            </div>
            <div id="col-incidencias" data-column-name="INCIDENCIAS" class="kanban-column">
                <h2 class="kanban-title">INCIDENCIAS</h2>
                 <div class="kanban-card" data-card-id="card-7">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-semibold text-gray-800">2025-003552-02</span>
                        <span class="text-gray-600">CLIENTE 091</span>
                    </div>
                    <div class="mb-2">
                        <span class="ope-tag ope-incidencia">OPE-01</span>
                        <span class="ope-tag ope-incidencia">OPE-02</span>
                        <span class="ope-tag ope-incidencia">OPE-03</span>
                    </div>
                    <div class="flex justify-between items-center text-gray-500">
                        <span>05/03/2025</span>
                        <span>MATERIAL A0025</span>
                        <span class="font-medium text-gray-700">41 Uds</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="pause-notification" class="container mx-auto mt-4 hidden">
            <div class="bg-yellow-100 border border-yellow-300 text-yellow-800 px-4 py-3 rounded relative">
                <center>
                    <span class="block sm:inline font-semibold">
                        Estás en pausa. Vuelve a reanudar cuando estés listo.
                    </span>
                </center>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 border-t border-gray-200 pt-6">

             <div class="flex flex-col justify-start space-y-4">
                 <div class="text-sm w-full max-w-sm">
                    <div class="flex justify-between py-1">
                        <span class="text-gray-600">OCUPACIÓN TEÓRICA</span>
                        <span id="ocupacion-teorica-val" class="font-mono font-medium text-gray-800">27:34:24</span> </div>
                    <div class="flex justify-between py-1">
                        <span class="text-gray-600">OCUPACIÓN REAL</span>
                        <span id="ocupacion-real-val" class="font-mono font-medium text-gray-800">29:45:59</span> </div>
                 </div>
                 <div id="action-buttons-container" class="flex items-center justify-start space-x-4">
                     <button id="start-shift-button" class="action-button hidden" data-action-type="start-shift" title="Iniciar Turno/Tarea">
                         <i class="fa fa-play action-icon" aria-hidden="true"></i>
                     </button>
                     <button id="start-pause-button" class="action-button hidden" data-action-type="start-pause" title="Iniciar Parada">
                         <i class="fa fa-pause action-icon" aria-hidden="true"></i>
                     </button>
                     <button id="resume-button" class="action-button hidden" data-action-type="resume-pause" title="Reanudar">
                         <i class="fa fa-play action-icon" aria-hidden="true"></i>
                     </button>
                     <button id="end-shift-button" class="action-button hidden" data-action-type="end-shift" title="Finalizar Turno/Tarea">
                         <i class="fa fa-stop action-icon" aria-hidden="true"></i>
                     </button>
                     <button id="end-pause-button" class="action-button hidden" data-action-type="end-pause" title="Finalizar Parada">
                         <i class="fa fa-stop action-icon" aria-hidden="true"></i>
                     </button>
                 </div>
             </div>

            <div class="flex flex-col justify-start items-center space-y-6">
                 <div class="w-full max-w-sm text-center">
                    <label id="worker-label" for="worker-select" class="block text-sm font-medium text-gray-700 mb-1">OPERARIO</label>
                    <div id="select-container">
                         <select id="worker-select" class="w-full" style="width: 100%"> <option value="">Cargando operarios...</option> </select>
                    </div>
                    <div id="display-container" class="hidden mt-2 flex items-center justify-center space-x-3">
                        <span id="selected-worker-info" class="text-lg text-gray-800 font-medium"></span>
                        <button id="logout-button" title="Cambiar operario" class="text-red-500 hover:text-red-700 focus:outline-none p-1 rounded-full">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="m15 9-6 6"/>
                                <path d="m9 9 6 6"/>
                            </svg>
                        </button>
                    </div>
                </div>
                 <div class="text-sm w-full max-w-sm">
                    <div class="flex justify-between py-1"><span class="text-gray-600">TIEMPO EN PARADA</span><span class="font-mono font-medium text-gray-800">00:00:00</span></div>
                    <div class="flex justify-between py-1"><span class="text-gray-600">TIEMPO LENTO</span><span class="font-mono font-medium text-gray-800">00:00:00</span></div>
                    <div class="flex justify-between py-1"><span class="text-gray-600">TIEMPO ATRASADO</span><span class="font-mono font-medium text-gray-800">00:00:00</span></div>
                </div>
            </div>

            <div class="flex justify-center items-start">
                 <div id="progress-indicator" class="progress-circle"> <span id="progress-value">0</span> </div>
            </div>
        </div>

        <div class="mt-8 border-t border-gray-200 pt-6">
            <div class="flex justify-between text-sm text-gray-500 mb-1"><span>HORA INICIO</span><span>HORA FIN</span></div>
            <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden"><div class="bg-yellow-400 h-4 rounded-full" style="width: 70%;"></div></div>
             <div class="text-right text-sm text-gray-500 mt-1">SIN DATOS</div>
        </div>

    </div>

    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11" defer onerror="console.error('Error loading SweetAlert2 script:', event)"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" defer onerror="console.error('Error loading Dragula script:', event)"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Configuración ---
            const API_BASE_URL = window.location.origin;
            const REFRESH_INTERVAL_MS = 1000;
            const API_DELAY_MS = 500;
            console.log(`API Base URL set dynamically to: ${API_BASE_URL}`);

            // Verificar librerías principales
            if (typeof $ === 'undefined' || typeof $.fn.select2 === 'undefined') { console.error("Error Crítico: jQuery o Select2 no cargados."); return; }
            if (typeof dragula !== 'function') { console.error("Error Crítico: Dragula no cargado."); return; }
            if (typeof Swal !== 'function') { console.warn("Advertencia: SweetAlert2 (Swal) no cargado."); }

            // --- Elementos del DOM ---
            const workerLabel = $('#worker-label');
            const workerSelect = $('#worker-select');
            const selectContainer = $('#select-container');
            const displayContainer = $('#display-container');
            const selectedWorkerInfo = $('#selected-worker-info');
            const logoutButton = $('#logout-button');
            const actionButtonsContainer = document.getElementById('action-buttons-container');
            const progressIndicator = document.getElementById('progress-indicator');
            const progressValue = document.getElementById('progress-value');
            let currentWorker = null;
            let currentShiftState = { type: null, action: null };
            let shiftHistoryTimeoutId = null;
            let productionLineToken = null;
            let isSelectOpen = false;
            let isProcessingLogin = false;

            // --- Función de utilidad para Delay ---
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

            // --- Función para mostrar alerta de operario requerido ---
            function showWorkerRequiredAlert() {
                 if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Acción no permitida', text: 'Por favor, selecciona un operario primero.', confirmButtonColor: '#3085d6' }); }
                 else { alert('Por favor, selecciona un operario primero.'); }
            }

             // --- Función para mostrar confirmación genérica ---
             function showActionConfirmation(actionDescription, callback) {
                 const isLogoutAction = actionDescription.includes("finalizar el turno/tarea");
                 // Permitir logout aunque no haya trabajador seleccionado (si el botón está visible)
                 // Permitir otras acciones solo si hay trabajador seleccionado
                 if (!isLogoutAction && !currentWorker) { showWorkerRequiredAlert(); return; }

                 if (typeof Swal === 'function') {
                    Swal.fire({
                        title: 'Confirmar Acción', text: `Estás a punto de ${actionDescription}. ¿Estás seguro?`,
                        icon: 'question', showCancelButton: true, confirmButtonColor: '#3085d6',
                        cancelButtonColor: '#d33', confirmButtonText: 'Sí', cancelButtonText: 'Cancelar'
                    }).then((result) => {
                        if (result.isConfirmed) {
                            if (!isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' confirmada por ${currentWorker.name}`); }
                            else if (isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada por ${currentWorker.name}`); }
                            else if (isLogoutAction && !currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada sin operario activo.`); }
                            callback();
                        } else { console.log(`Acción '${actionDescription}' cancelada.`); }
                    });
                 } else { /* Fallback */
                     if (confirm(`Estás a punto de ${actionDescription}. ¿Estás seguro?`)) {
                         if (!isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' confirmada por ${currentWorker.name}`); }
                         else if (isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada por ${currentWorker.name}`); }
                         else if (isLogoutAction && !currentWorker) { console.log(`Acción '${actionDescription}' (logout) confirmada sin operario activo.`); }
                         callback();
                     } else { console.log(`Acción '${actionDescription}' cancelada.`); }
                 }
             }

            // --- Función para enviar evento de turno a la API ---
            function postShiftEvent(eventName) {
                // Permitir 'final_trabajo' incluso sin currentWorker, ya que el botón puede estar visible después de un error
                if (eventName !== 'final_trabajo' && (!productionLineToken || !currentWorker || !currentWorker.id)) {
                    console.error("Falta token o ID de operario para enviar evento:", eventName);
                    showWorkerRequiredAlert();
                    return Promise.reject("Faltan datos para enviar evento");
                }
                 // Para 'final_trabajo', si no hay currentWorker, intentamos enviarlo sin operator_id (la API debería manejarlo o usar el token)
                const payload = { production_line_token: productionLineToken, event: eventName };
                if (currentWorker && currentWorker.id) {
                    payload.operator_id = currentWorker.id;
                } else if (eventName !== 'final_trabajo') {
                    // Si no es final_trabajo y no hay operario, es un error real
                     console.error("Intento de enviar evento sin operario (no permitido para este evento):", eventName);
                     showWorkerRequiredAlert();
                     return Promise.reject("Falta operario para este evento");
                }

                const eventEndpoint = '/api/shift-event';
                const eventApiUrl = `${API_BASE_URL}${eventEndpoint}`;
                console.log(`Posting shift event: ${eventName} to ${eventApiUrl}`, payload);

                return fetch(eventApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify(payload) })
                .then(response => {
                    if (!response.ok) { return response.json().catch(() => null).then(errorBody => { console.error(`Error en API ${eventName}: ${response.status}`, errorBody); throw new Error(`Error ${response.status} al ${eventName}`); }); }
                    return response.text().then(text => text ? JSON.parse(text) : {});
                })
                .then(data => {
                    console.log(`Evento ${eventName} enviado con éxito. Respuesta:`, data);
                    // Forzar refresco inmediato para ver el cambio de estado de botones
                    if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                    fetchLastShiftHistory(productionLineToken); // Actualiza estado inmediatamente
                    // Opcional: Actualizar también el progreso si es relevante
                    // fetchProgressData();
                    return data;
                })
                .catch(error => {
                    console.error(`Fallo al enviar evento ${eventName}:`, error);
                    if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo ${eventName}. ${error.message || ''}`, 'error'); }
                    else { alert(`Error al ${eventName}.`); }
                    throw error; // Propagar error
                });
            }

            // --- Función para actualizar el círculo de progreso ---
            function updateProgress(percent) {
                const clampedPercent = Math.max(0, Math.min(100, percent));
                if (progressIndicator && progressValue) { progressIndicator.style.setProperty('--progress-percent', clampedPercent); progressValue.textContent = Math.round(clampedPercent); }
                else { console.error("Elementos del círculo de progreso no encontrados."); }
            }

            // --- Función para obtener datos de progreso desde API ---
            function fetchProgressData() {
                const progressEndpoint = '/api/datos-progreso'; // EJEMPLO
                const progressApiUrl = `${API_BASE_URL}${progressEndpoint}`;
                fetch(progressApiUrl)
                    .then(response => response.ok ? response.json() : Promise.reject(`HTTP error! status: ${response.status}`))
                    .then(data => { if (data && typeof data.percentage !== 'undefined') { updateProgress(data.percentage); } else { updateProgress(0); } })
                    .catch(error => { /* console.error('Error fetching progress data:', error); */ updateProgress(0); });
            }

            // --- Inicializar Select2 ---
            workerSelect.select2({ placeholder: "Selecciona un operario...", allowClear: true, language: "es" });

            // --- Función para cargar operarios ---
            function loadWorkers() {
                const workersEndpoint = '/api/workers/list-all2';
                const apiUrl = `${API_BASE_URL}${workersEndpoint}`;
                console.log("Fetching workers...");
                fetch(apiUrl)
                    .then(response => response.ok ? response.json() : Promise.reject(`HTTP error! status: ${response.status}`))
                    .then(data => {
                        workerSelect.empty();
                        workerSelect.append(new Option("Selecciona un operario...", "", true, true));
                        if (data && Array.isArray(data.operators) && data.operators.length > 0) {
                            data.operators.forEach(worker => { if (worker && typeof worker.id !== 'undefined' && typeof worker.name !== 'undefined') { workerSelect.append(new Option(worker.name, worker.id)); } });
                        } else { workerSelect.append(new Option("No se encontraron operarios", "", false, true)); }
                        if (currentWorker) { workerSelect.val(currentWorker.id).trigger('change.select2'); }
                        else { workerSelect.val(null).trigger('change'); }
                        console.log("Worker list reloaded.");
                    })
                    .catch(error => { console.error('Error fetching workers:', error); workerSelect.empty().append(new Option("Error al cargar operarios", "", true, true)); if (typeof Swal === 'function') Swal.fire('Error', 'No se pudo cargar la lista de operarios.', 'error'); });
            }

            // --- Pausar/Reanudar polling al abrir/cerrar Select2 ---
            workerSelect.on('select2:opening', function (e) {
                isSelectOpen = true;
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; console.log('Shift history refresh PAUSED.'); }
            });
             workerSelect.on('select2:close', function (e) {
                 isSelectOpen = false;
                 console.log('Select2 closed, restarting history refresh.');
                 if (productionLineToken && !shiftHistoryTimeoutId) { fetchLastShiftHistory(productionLineToken); }
             });

             // --- Función para actualizar botones de acción ---
             function updateActionButtons(type, action) {
                 console.log("Updating buttons for state:", type, action);
                 const buttons = actionButtonsContainer.querySelectorAll('button.action-button'); // Seleccionar solo los botones de acción
                 buttons.forEach(btn => btn.classList.add('hidden')); // Ocultar todos primero

                 if (type === 'shift' && action === 'start') {
                    // Turno iniciado: mostrar Pausar y Finalizar Turno
                    $('#start-pause-button').removeClass('hidden');
                    $('#end-shift-button').removeClass('hidden');
                    $('#pause-notification').addClass('hidden');
                    console.log("Buttons: Start Pause, End Shift");
                 } else if (type === 'stop' && action === 'start') {
                    // Pausa iniciada: mostrar Reanudar y Finalizar Parada
                    $('#resume-button').removeClass('hidden');
                    $('#end-pause-button').removeClass('hidden'); // Mostrar Finalizar Parada
                    $('#pause-notification').removeClass('hidden');
                     console.log("Buttons: Resume, End Pause");
                 } else if (type === 'shift' && action === 'end') {
                    // Turno finalizado: mostrar Iniciar Turno
                    $('#start-shift-button').removeClass('hidden');
                    $('#pause-notification').addClass('hidden');
                     console.log("Buttons: Start Shift");
                 } else if (type === 'stop' && action === 'end') {
                    // Pausa finalizada (implica que el turno sigue activo): mostrar Pausar y Finalizar Turno
                    $('#start-pause-button').removeClass('hidden');
                    $('#end-shift-button').removeClass('hidden');
                    $('#pause-notification').addClass('hidden');
                     console.log("Buttons: Start Pause, End Shift (after pause end)");
                 } else {
                    // Estado inicial o desconocido: mostrar Iniciar Turno
                    $('#start-shift-button').removeClass('hidden');
                    $('#pause-notification').addClass('hidden');
                     console.log("Buttons: Start Shift (Default/Unknown)");
                 }
             }

              // --- Añadir listeners genéricos a los botones de acción ---
              actionButtonsContainer.addEventListener('click', function(event) {
                  const button = event.target.closest('button.action-button'); // Asegurarse que es un botón de acción
                  if (!button) return; // Ignorar clics fuera de los botones de acción
                  const actionType = button.dataset.actionType;
                  let actionDescription = "realizar esta acción";
                  let eventName = null;
                  switch (actionType) {
                      case 'start-shift': actionDescription = "iniciar el turno/tarea"; eventName = "inicio_trabajo"; break;
                      case 'start-pause': actionDescription = "iniciar una parada"; eventName = "inicio_pausa"; break;
                      case 'resume-pause': actionDescription = "reanudar la tarea"; eventName = "final_pausa"; break; // Reanudar es finalizar la pausa
                      case 'end-shift': actionDescription = "finalizar el turno/tarea"; eventName = "final_trabajo"; break;
                      case 'end-pause': actionDescription = "finalizar la parada"; eventName = "final_pausa"; break; // Finalizar parada directamente
                  }
                  if (!eventName) { console.error("Tipo de acción desconocida:", actionType); return; }

                  // Permitir 'end-shift' incluso sin operario seleccionado (botón X o estado recuperado)
                  // Para el resto, requerir operario
                  if (actionType !== 'end-shift' && !currentWorker) {
                      showWorkerRequiredAlert();
                      return;
                  }

                  // Caso especial: Iniciar turno requiere selección previa si no hay nadie logueado
                  if (actionType === 'start-shift' && !currentWorker) {
                      // No mostrar confirmación aquí, la selección del operario ya la pide
                      console.log("Start shift button clicked without worker, relying on Select2 change handler.");
                      // Opcional: indicar al usuario que seleccione un operario
                      if (typeof Swal === 'function') {
                          Swal.fire({ icon: 'info', title: 'Selecciona Operario', text: 'Por favor, selecciona tu nombre en la lista para iniciar el turno.', confirmButtonColor: '#3085d6' });
                      } else {
                          alert('Por favor, selecciona tu nombre en la lista para iniciar el turno.');
                      }
                      return;
                  }


                  showActionConfirmation(actionDescription, () => {
                      postShiftEvent(eventName).catch(err => { console.error(`Error en la acción ${actionType} (API):`, err); });
                  });
              });

             // --- Función para procesar datos del historial de turno ---
             function processShiftData(shiftData) {
                 let operator = null; let type = null; let action = null;
                 let previousState = {...currentShiftState};
                 if (shiftData && shiftData.data) { operator = shiftData.data.operator; type = shiftData.data.type; action = shiftData.data.action; }
                 else if (shiftData === null) { // Caso 404 o sin historial
                     type = 'shift'; action = 'end'; // Asumir turno finalizado
                     console.log("No shift data received (or 404), assuming shift ended.");
                 }

                 const isShiftEnded = (type === 'shift' && action === 'end');

                 // Actualizar estado global SOLO si ha cambiado
                 if (!previousState.type || previousState.type !== type || previousState.action !== action) {
                    currentShiftState = { type, action };
                    console.log("Processing shift data. New state:", currentShiftState);
                    updateActionButtons(type, action); // Actualizar botones basado en el nuevo estado
                 } else {
                    console.log("Shift state unchanged:", currentShiftState);
                    // Aunque el estado no cambie, asegurarse que los botones son correctos
                    // Esto es útil si hubo un error previo y los botones quedaron mal
                    updateActionButtons(currentShiftState.type, currentShiftState.action);
                 }

                 // Lógica para mostrar/ocultar selector de operario
                 if (isShiftEnded && !isProcessingLogin) {
                     // Si el turno terminó, desloguear operario y mostrar selector
                     if (currentWorker) {
                         console.log("Shift ended, logging out current worker:", currentWorker.name);
                         currentWorker = null;
                     }
                     displayContainer.addClass('hidden');
                     workerLabel.removeClass('hidden');
                     selectContainer.removeClass('hidden');
                     workerSelect.val(null).trigger('change.select2'); // Resetear select

                 } else if (operator && !isProcessingLogin) {
                     // Si hay operario en la API, mostrarlo (auto-login o refresco)
                     if (!currentWorker || currentWorker.id != operator.id) {
                        console.log("Operator found in API. Auto-displaying/updating:", operator.name);
                        currentWorker = { id: operator.id, name: operator.name };
                        selectedWorkerInfo.text(currentWorker.name);
                        workerSelect.val(currentWorker.id).trigger('change.select2'); // Sincronizar select
                     }
                     workerLabel.addClass('hidden');
                     selectContainer.addClass('hidden');
                     displayContainer.removeClass('hidden');

                 } else if (!operator && currentWorker && !isProcessingLogin) {
                     // Si no hay operario en API pero sí localmente (error?), forzar logout local
                     console.warn("No operator in API, but worker logged in locally. Forcing local logout.");
                     currentWorker = null;
                     displayContainer.addClass('hidden');
                     workerLabel.removeClass('hidden');
                     selectContainer.removeClass('hidden');
                     workerSelect.val(null).trigger('change.select2'); // Resetear select

                 } else if (!operator && !currentWorker && !isProcessingLogin) {
                      // Si no hay operario ni local ni en API, asegurar que el selector está visible
                     if (selectContainer.hasClass('hidden')) {
                         console.log("No worker manually logged in and no operator in API. Ensuring selector is visible.");
                         displayContainer.addClass('hidden');
                         workerLabel.removeClass('hidden');
                         selectContainer.removeClass('hidden');
                         workerSelect.val(null).trigger('change.select2'); // Resetear select
                     }
                 }
             }

            // --- Función para obtener el último historial de turno (y auto-refrescar) ---
            function fetchLastShiftHistory(token) {
                if (isSelectOpen || isProcessingLogin) {
                    console.log(`Shift history refresh SKIPPED (Select open: ${isSelectOpen}, Processing login: ${isProcessingLogin})`);
                    if (!shiftHistoryTimeoutId) {
                       shiftHistoryTimeoutId = setTimeout(() => fetchLastShiftHistory(token), REFRESH_INTERVAL_MS);
                    }
                    return;
                }

                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; }
                if (!token) {
                    console.error("Token no encontrado en la URL.");
                    processShiftData(null); // Tratar como turno finalizado si no hay token
                    // No reiniciar el timer si no hay token
                    return;
                 }

                const historyEndpoint = `/api/shift-history/production-line/${token}/last`;
                const historyApiUrl = `${API_BASE_URL}${historyEndpoint}`;
                console.log("Fetching last shift history...");

                fetch(historyApiUrl)
                    .then(response => {
                        if (!response.ok) {
                            if (response.status === 404) {
                                console.log("No shift history found (404). Treating as 'shift ended'.");
                                return null; // Devolver null para que processShiftData lo maneje
                            }
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        processShiftData(data);
                    })
                    .catch(error => {
                        console.error('Error fetching shift history:', error);
                        processShiftData(null); // Asumir turno finalizado en caso de error de red/API
                    })
                    .finally(() => {
                        // Volver a programar el refresco solo si hay token y no hay interrupciones
                        if (token && !isSelectOpen && !isProcessingLogin) {
                            shiftHistoryTimeoutId = setTimeout(() => fetchLastShiftHistory(token), REFRESH_INTERVAL_MS);
                        } else {
                            console.log("Shift history refresh loop paused.");
                        }
                    });
            }

            // --- Función para obtener token de URL ---
            function getTokenFromUrl() {
                const params = new URLSearchParams(window.location.search);
                return params.get('token');
            }

            // --- Flujo Inicial ---
            productionLineToken = getTokenFromUrl();
            loadWorkers(); // Cargar lista de operarios
            fetchLastShiftHistory(productionLineToken); // Obtener estado inicial y empezar polling
            fetchProgressData(); // Obtener progreso inicial

            // --- Manejar selección manual de operario ---
            workerSelect.on('change', async function(e) {
                console.log("DEBUG: Select2 'change' event fired!");
                const selectedId = $(this).val();

                // Ignorar si el valor es vacío (causado por allowClear o deselección)
                if (!selectedId || selectedId === "") {
                    console.log("DEBUG: Change event ignored (empty value selected).");
                    // Si había un operario logueado, NO hacer nada aquí. El logout se maneja con el botón X o fin de turno.
                    // Si no había operario, simplemente se queda sin seleccionar.
                    return;
                }

                const selectedName = $(this).find('option:selected').text();

                // Ignorar si se selecciona el mismo operario que ya está logueado
                if (currentWorker && currentWorker.id == selectedId) {
                    console.log("DEBUG: Change event ignored (already selected worker).");
                    // Asegurarse de que la UI está correcta (ocultar selector, mostrar nombre)
                    if (selectContainer.is(':visible')) {
                         workerLabel.addClass('hidden');
                         selectContainer.addClass('hidden');
                         displayContainer.removeClass('hidden');
                         selectedWorkerInfo.text(currentWorker.name);
                    }
                    return;
                }

                // Si ya hay un operario diferente logueado, informar y resetear
                if (currentWorker && currentWorker.id != selectedId) {
                    console.log("DEBUG: Different worker selected. Current worker must logout first.");
                     if (typeof Swal === 'function') {
                        Swal.fire({ icon: 'warning', title: 'Cambio de Operario', text: `Para iniciar sesión como ${selectedName}, primero debes finalizar el turno del operario actual (${currentWorker.name}). Usa el botón (X) o el botón 'Finalizar Turno'.`, confirmButtonColor: '#3085d6' });
                     } else {
                         alert(`Para iniciar sesión como ${selectedName}, primero debes finalizar el turno del operario actual (${currentWorker.name}). Usa el botón (X) o el botón 'Finalizar Turno'.`);
                     }
                     // Resetear el select al operario actual que está logueado
                     workerSelect.val(currentWorker.id).trigger('change.select2');
                     return;
                }

                // Si no hay operario logueado, proceder con la confirmación de inicio de sesión/turno
                const potentialNewWorker = { id: selectedId, name: selectedName };
                console.log("DEBUG: New operator selected in dropdown. Current shift state before Swal:", currentShiftState);

                // Detener el polling mientras se confirma
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; }
                isProcessingLogin = true; // Bloquear refresco automático y otras acciones

                try {
                    if (typeof Swal === 'function') {
                        const swalResult = await Swal.fire({
                                title: 'Confirmar Operario', text: `Estás a punto de iniciar sesión y turno con ${potentialNewWorker.name}. ¿Estás seguro?`,
                                icon: 'question', showCancelButton: true, confirmButtonColor: '#3085d6',
                                cancelButtonColor: '#d33', confirmButtonText: 'Confirmar', cancelButtonText: 'Cancelar'
                            });

                        if (swalResult.isConfirmed) {
                            console.log("DEBUG: Operator selection CONFIRMED via Swal.");
                            currentWorker = potentialNewWorker; // Asignar nuevo operario

                            // Actualizar UI inmediatamente para mostrar el nombre
                            selectedWorkerInfo.text(currentWorker.name);
                            workerLabel.addClass('hidden');
                            selectContainer.addClass('hidden');
                            displayContainer.removeClass('hidden');

                            // Mostrar indicador de carga mientras se llama a la API
                            Swal.fire({ title: 'Procesando inicio de turno...', allowOutsideClick: false, didOpen: () => { Swal.showLoading() } });

                            try {
                                console.log("DEBUG: Attempting: Start Shift for new worker");
                                await postShiftEvent("inicio_trabajo"); // Llamar a la API para iniciar turno
                                // La llamada a postShiftEvent ya incluye fetchLastShiftHistory al final
                                if (Swal.isLoading()) { Swal.close(); } // Cerrar modal de carga si sigue abierto

                                // Mostrar alerta de éxito y forzar refresh al cerrarla
                                Swal.fire({
                                    title: '¡Éxito!',
                                    text: `Turno iniciado para ${currentWorker.name}.`,
                                    icon: 'success',
                                    timer: 2500, // Cerrar automáticamente después de 2.5 segundos
                                    timerProgressBar: true,
                                    didClose: () => { // Usar didClose o then() para ejecutar al cerrar
                                        console.log("Success alert closed, forcing refresh.");
                                        if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId); // Asegurar que no hay timers pendientes
                                        fetchLastShiftHistory(productionLineToken); // Volver a cargar el estado
                                    }
                                });

                            } catch (error) {
                                console.error("DEBUG: Error during start shift sequence:", error);
                                if (Swal.isLoading()) { Swal.close(); } // Cerrar modal de carga
                                Swal.fire('Error', `No se pudo iniciar el turno para ${currentWorker.name}. ${error.message || ''}`, 'error');
                                // Revertir estado: desloguear localmente y mostrar selector
                                currentWorker = null;
                                displayContainer.addClass('hidden');
                                workerLabel.removeClass('hidden');
                                selectContainer.removeClass('hidden');
                                workerSelect.val(null).trigger('change.select2'); // Resetear select
                            }
                        } else if (swalResult.isDismissed) {
                             console.log("DEBUG: Operator selection CANCELLED via Swal.");
                             // Resetear el select a "Selecciona operario"
                             workerSelect.val(null).trigger('change.select2');
                        }
                    } else { // Fallback sin Swal
                        if (confirm(`Estás a punto de iniciar sesión y turno con ${potentialNewWorker.name}. ¿Estás seguro?`)) {
                           console.log("DEBUG: Operator selection CONFIRMED via confirm().");
                           currentWorker = potentialNewWorker;
                           selectedWorkerInfo.text(currentWorker.name);
                           workerLabel.addClass('hidden');
                           selectContainer.addClass('hidden');
                           displayContainer.removeClass('hidden');
                           alert('Procesando inicio de turno...'); // Indicador simple
                           try {
                               await postShiftEvent("inicio_trabajo");
                               alert(`¡Éxito! Turno iniciado para ${currentWorker.name}.`);
                               // Forzar refresh después de la alerta de éxito en el fallback
                               console.log("Fallback success alert closed, forcing refresh.");
                               if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                               fetchLastShiftHistory(productionLineToken);
                           } catch (error) {
                               alert(`Error al iniciar el turno para ${currentWorker.name}. ${error.message || ''}`);
                               currentWorker = null;
                               displayContainer.addClass('hidden');
                               workerLabel.removeClass('hidden');
                               selectContainer.removeClass('hidden');
                               workerSelect.val(null).trigger('change.select2');
                           }
                        } else {
                             console.log("DEBUG: Operator selection CANCELLED via confirm().");
                             workerSelect.val(null).trigger('change.select2');
                        }
                    }
                } finally {
                    // Asegurarse de que el bloqueo se quita y el polling se reanuda
                    isProcessingLogin = false;
                    console.log("DEBUG: Login processing finished.");
                    // Reiniciar el polling (postShiftEvent y el then/didClose de Swal ya lo hacen si tiene éxito,
                    // pero lo hacemos aquí por si acaso se canceló o hubo error antes de Swal)
                    if (!shiftHistoryTimeoutId) {
                        fetchLastShiftHistory(productionLineToken);
                    }
                }
            });

             // --- Manejar clic en botón Logout (X) ---
             logoutButton.on('click', function() {
                 const logoutDescription = "finalizar el turno/tarea actual";
                 const eventName = "final_trabajo";

                 // No requerir currentWorker aquí, ya que el botón X es para desloguear al que esté activo (o forzar si hay inconsistencia)
                 if (!currentWorker) {
                     console.log("Logout button clicked, but no worker seems active locally. Attempting API call anyway.");
                     // Podríamos mostrar una alerta diferente o simplemente intentar la llamada API
                      if (typeof Swal === 'function') {
                          Swal.fire({ icon: 'info', title: 'Finalizar Turno', text: 'Intentando finalizar cualquier turno activo para esta línea...', confirmButtonColor: '#3085d6' });
                      } else {
                          alert('Intentando finalizar cualquier turno activo para esta línea...');
                      }
                 }

                 showActionConfirmation(logoutDescription, () => {
                     // Detener polling temporalmente
                     if (shiftHistoryTimeoutId) clearTimeout(shiftHistoryTimeoutId);
                     isProcessingLogin = true; // Usar el flag para evitar conflictos

                     postShiftEvent(eventName)
                         .then(() => {
                             console.log("Logout API call successful, UI will be updated by fetchLastShiftHistory.");
                             // No necesitamos hacer nada más aquí, fetchLastShiftHistory se llamará al finalizar
                         })
                         .catch(err => {
                             console.error("Logout failed:", err);
                             // Informar al usuario del error
                             if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo finalizar el turno. ${err.message || ''}`, 'error'); }
                             else { alert(`Error al finalizar el turno. ${err.message || ''}`); }
                         })
                         .finally(() => {
                             isProcessingLogin = false;
                             // Reiniciar el polling inmediatamente después del intento de logout
                             fetchLastShiftHistory(productionLineToken);
                         });
                 });
             });

            // --- Lógica Kanban (Dragula) ---
            const columns = Array.from(document.querySelectorAll('.kanban-column'));
            if (columns.length === 0) { console.error("Error: No se encontraron columnas Kanban."); return; }

            let longPressTimer = null; let isTouchInteraction = false; let longPressTriggered = false;
            const longPressDelay = 500; // Milisegundos para considerar long press
            let startX, startY; let currentCard = null;

            // --- Eventos Táctiles para Long Press ---
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
            document.addEventListener('touchcancel', handleTouchEnd); // También maneja cancelaciones

            function handleTouchStart(e) {
                const card = e.target.closest('.kanban-card');
                if (!card) { isTouchInteraction = false; return; } // No iniciar si no es una tarjeta
                currentCard = card; isTouchInteraction = true; longPressTriggered = false;
                startX = e.touches[0].clientX; startY = e.touches[0].clientY;
                // Iniciar temporizador para long press
                clearTimeout(longPressTimer); // Limpiar cualquier timer anterior
                longPressTimer = setTimeout(() => {
                    if (!isTouchInteraction || !currentCard) return; // Si ya se soltó o movió mucho, no hacer nada
                    console.log("Long press triggered!");
                    longPressTriggered = true;
                    currentCard.classList.add('long-press-ready'); // Añadir clase visual (opcional)
                    // Vibrar si es posible (feedback táctil)
                    if (navigator.vibrate) { navigator.vibrate(50); }
                    // IMPORTANTE: No iniciar el drag aquí, Dragula lo hará basado en 'moves'
                }, longPressDelay);
            }

            function handleTouchMove(e) {
                if (!isTouchInteraction || !currentCard) return;
                const currentX = e.touches[0].clientX; const currentY = e.touches[0].clientY;
                const deltaX = Math.abs(currentX - startX); const deltaY = Math.abs(currentY - startY);
                const moveThreshold = 10; // Píxeles de tolerancia antes de cancelar long press

                // Si se mueve más allá del umbral ANTES de que salte el long press, cancelar el timer
                if (!longPressTriggered && (deltaX > moveThreshold || deltaY > moveThreshold)) {
                    console.log("Movement detected before long press, cancelling timer.");
                    clearTimeout(longPressTimer);
                    if(currentCard) currentCard.classList.remove('long-press-ready');
                    // No establecer isTouchInteraction = false aquí, podría ser scroll
                }

                // Si el long press ya se activó y se está moviendo, podríamos querer prevenir el scroll de la página
                // Sin embargo, preventDefault() puede interferir con Dragula. Probar con cuidado.
                // if (longPressTriggered) {
                //    e.preventDefault(); // Descomentar con precaución
                // }
            }

            function handleTouchEnd(e) {
                clearTimeout(longPressTimer); // Siempre limpiar el timer al soltar
                if (currentCard) { currentCard.classList.remove('long-press-ready'); } // Limpiar clase visual
                // NO resetear longPressTriggered aquí, Dragula lo necesita en 'moves'
                // Se reseteará en dragend o cancel
                isTouchInteraction = false; // Indicar que la interacción táctil directa ha terminado
                currentCard = null; // Limpiar referencia a la tarjeta
            }


            // --- Inicialización de Dragula ---
            const drake = dragula(columns, {
                 moves: function (el, source, handle, sibling) {
                    // Permitir mover con ratón siempre
                    if (!isTouchInteraction) {
                        console.log("Dragula moves check (mouse): allowed");
                        return true;
                    }
                    // Permitir mover con táctil SOLO si se activó el long press
                    console.log("Dragula moves check (touch): longPressTriggered =", longPressTriggered);
                    return longPressTriggered; // Solo permite iniciar drag si longPressTriggered es true
                 },
                 // Opciones adicionales si son necesarias (accepts, invalid, etc.)
             });

            if (!drake) { console.error("Error: Falló la inicialización de Dragula."); return; }

            // --- Eventos de Dragula ---
            drake.on('drag', (el, source) => {
                console.log("Dragula event: drag (started)");
                // Comprobar si hay operario al INICIAR el drag
                if (!currentWorker) {
                    console.log("Drag cancelled: No worker selected.");
                    drake.cancel(true); // Cancelar el drag inmediatamente
                    showWorkerRequiredAlert();
                    return; // Salir del handler
                }
                // Limpiar la clase de long press si aún estuviera por alguna razón
                if (el) el.classList.remove('long-press-ready');
                // Opcional: Añadir una clase al body mientras se arrastra
                // document.body.classList.add('dragging-active');
            });

            drake.on('drop', (el, target, source, sibling) => {
                console.log("Dragula event: drop");
                const sourceColumnName = source.dataset.columnName || source.id;
                const targetColumnName = target.dataset.columnName || target.id;
                const cardId = el.dataset.cardId;
                const cardTitleElement = el.querySelector('.font-semibold'); // Asumiendo que el título está aquí
                const cardTitle = cardTitleElement ? cardTitleElement.innerText : `Tarjeta ${cardId}`; // Texto del título o ID

                // Mensaje para el usuario
                const message = `Moviste la tarjeta "${cardTitle}" de "${sourceColumnName}" a "${targetColumnName}".`;

                // **AQUÍ: Llamada a la API para registrar el movimiento**
                console.log("TODO: Llamar API para registrar movimiento Kanban", {
                    card_id: cardId,
                    target_column: targetColumnName,
                    source_column: sourceColumnName,
                    operator_id: currentWorker ? currentWorker.id : null // Enviar ID del operario
                 });
                 // Ejemplo de llamada API (simulada con fetch)
                 /*
                 const moveEndpoint = '/api/kanban/move';
                 const moveApiUrl = `${API_BASE_URL}${moveEndpoint}`;
                 fetch(moveApiUrl, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                     body: JSON.stringify({
                         card_id: cardId,
                         target_column: targetColumnName,
                         operator_id: currentWorker ? currentWorker.id : null,
                         production_line_token: productionLineToken // Puede ser útil enviar el token también
                     })
                 })
                 .then(response => {
                     if (!response.ok) { throw new Error(`Error ${response.status} al mover tarjeta`); }
                     return response.json();
                 })
                 .then(data => {
                     console.log("Movimiento Kanban registrado en API:", data);
                     // Mostrar confirmación al usuario (ya se hace abajo con Swal/alert)
                 })
                 .catch(error => {
                     console.error("Error al registrar movimiento Kanban en API:", error);
                     // Informar al usuario del error
                     if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo registrar el movimiento de la tarjeta. ${error.message || ''}`, 'error'); }
                     else { alert(`Error al registrar el movimiento. ${error.message || ''}`); }
                     // Opcional: Revertir el movimiento visualmente si falla la API
                     // drake.cancel(true); // Esto puede ser confuso, quizás mejor solo mostrar error
                 });
                 */

                // Mostrar notificación (simulada)
                if (typeof Swal === 'function') {
                    // Usar toast para una notificación menos intrusiva
                    Swal.fire({
                        title: 'Movimiento Registrado (Simulado)',
                        text: message,
                        icon: 'success',
                        timer: 2000, // Desaparece después de 2 segundos
                        timerProgressBar: true,
                        toast: true, // Mostrar como notificación pequeña
                        position: 'top-end', // Posición en la esquina superior derecha
                        showConfirmButton: false // No mostrar botón de confirmación
                    });
                } else {
                    alert(message); // Fallback si Swal no está disponible
                }

                // Resetear estado de long press al finalizar correctamente
                longPressTriggered = false;
            });

            drake.on('cancel', (el, container, source) => {
                console.log("Dragula event: cancel");
                // Resetear estado de long press si se cancela
                longPressTriggered = false;
                if (el) el.classList.remove('long-press-ready');
                // document.body.classList.remove('dragging-active');
            });

            drake.on('dragend', (el) => {
                console.log("Dragula event: dragend (finished, dropped or cancelled)");
                // Resetear estado de long press SIEMPRE al finalizar el drag (sea drop o cancel)
                longPressTriggered = false;
                if (el) el.classList.remove('long-press-ready'); // Asegurarse de limpiar la clase
                // document.body.classList.remove('dragging-active');
            });

            // Opcional: Cambiar fondo de columna al pasar por encima
             drake.on('over', function (el, container) {
                 container.classList.add('bg-gray-300'); // Hacer la columna un poco más oscura
             });
             drake.on('out', function (el, container) {
                 container.classList.remove('bg-gray-300'); // Restaurar color original
             });

        }); // Fin de DOMContentLoaded
    </script>

</body>
</html>
