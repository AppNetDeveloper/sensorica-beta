<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Kanban - Corregido Auto-Display Operario</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <style type="text/tailwindcss">
        @layer utilities {
          /* Estilos personalizados si son necesarios */
        }
        body {
            font-family: 'Inter', sans-serif; /* Usar la fuente Inter */
            overscroll-behavior-y: contain;
        }
        /* --- Estilos Círculo de Progreso Dinámico --- */
        .progress-circle {
            width: 100px; height: 100px; border-radius: 50%; display: grid; place-items: center;
            background: conic-gradient(#4ade80 calc(var(--progress-percent, 0) * 1%), #e5e7eb 0);
            position: relative; font-size: 1.8rem; font-weight: bold; color: #16a34a; transition: background 0.3s ease;
        }
        .progress-circle::before { content: ""; position: absolute; border-radius: 50%; inset: 8px; background: #fff; z-index: 1; }
        #progress-value { z-index: 2; position: relative; }
        /* --- Fin Estilos Círculo --- */

        .kanban-card { @apply bg-white p-3 rounded-md shadow border border-gray-200 mb-3 cursor-grab; touch-action: manipulation; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
        .kanban-column { @apply bg-gray-100 p-4 rounded-lg h-full min-h-[200px]; }
        .kanban-title { @apply font-semibold text-gray-700 mb-4 text-center; }
        .gu-mirror { @apply bg-white p-3 rounded-md shadow-lg border border-blue-300 opacity-80 fixed !important; cursor: grabbing !important; z-index: 9999 !important; touch-action: none; }
        .gu-transit { @apply opacity-50; }
        .long-press-ready { /* @apply ring-2 ring-offset-2 ring-blue-500; */ }
        /* Estilos Select2 */
        .select2-container--default .select2-selection--single { @apply border-gray-300 rounded-md shadow-sm h-10; }
        .select2-container--default .select2-selection--single .select2-selection__rendered { @apply leading-10 pl-3; }
        .select2-container--default .select2-selection--single .select2-selection__arrow { @apply h-9; }
        .select2-dropdown { @apply border-gray-300 rounded-md shadow-sm; }
        .select2-search--dropdown .select2-search__field { @apply border-gray-300 rounded-md m-1; }
        /* Estilo para ocultar elementos */
        .hidden { display: none; }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      @font-face { font-family: 'LucideIcons'; src: url('https://cdn.jsdelivr.net/npm/lucide-static@0.487.0/font/lucide.ttf') format('truetype'); }
      .lucide { font-family: 'LucideIcons'; font-style: normal; font-weight: normal; font-variant: normal; text-rendering: auto; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    </style>
</head>
<body class="bg-gray-200 p-8">

    <div class="container mx-auto bg-white p-6 rounded-lg shadow-md">

        <div id="kanban-board" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-6 mb-6">
             <div id="col-pendiente" data-column-name="PENDIENTE" class="kanban-column"> <h2 class="kanban-title">PENDIENTE</h2> <div class="kanban-card" data-card-id="card-1">Tarea 1</div> <div class="kanban-card flex items-center justify-between" data-card-id="card-2"><span>Tarea 2</span><i class="lucide text-red-500" style="font-size: 16px;">alert-triangle</i></div> <div class="kanban-card" data-card-id="card-3">Tarea 3</div> </div>
            <div id="col-en-curso" data-column-name="EN CURSO" class="kanban-column"> <h2 class="kanban-title">EN CURSO</h2> <div class="kanban-card" data-card-id="card-4">Tarea 4</div> </div>
            <div id="col-finalizadas" data-column-name="FINALIZADAS" class="kanban-column"> <h2 class="kanban-title">FINALIZADAS</h2> <div class="kanban-card" data-card-id="card-5">Tarea 5</div> <div class="kanban-card" data-card-id="card-6">Tarea 6</div> </div>
            <div id="col-incidencias" data-column-name="INCIDENCIAS" class="kanban-column"> <h2 class="kanban-title">INCIDENCIAS</h2> <div class="kanban-card" data-card-id="card-7">Incidencia A</div> </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 border-t border-gray-200 pt-6">
             <div id="action-buttons-container" class="flex items-center justify-start space-x-4">
                 <button id="start-shift-button" class="hidden bg-green-500 hover:bg-green-600 text-white p-3 rounded-full shadow-md transition duration-150 ease-in-out" data-action-type="start-shift" title="Iniciar Turno/Tarea"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347c.75.411.75 1.559 0 1.97l-11.54 6.347c-.75.411-1.667-.13-1.667-.986V5.653Z" /></svg> </button>
                 <button id="start-pause-button" class="hidden bg-yellow-500 hover:bg-yellow-600 text-white p-3 rounded-full shadow-md transition duration-150 ease-in-out" data-action-type="start-pause" title="Iniciar Parada"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 5.25v13.5m-7.5-13.5v13.5" /></svg> </button>
                 <button id="resume-button" class="hidden bg-green-500 hover:bg-green-600 text-white p-3 rounded-full shadow-md transition duration-150 ease-in-out" data-action-type="resume-pause" title="Reanudar"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347c.75.411.75 1.559 0 1.97l-11.54 6.347c-.75.411-1.667-.13-1.667-.986V5.653Z" /></svg> </button>
                 <button id="end-shift-button" class="hidden bg-red-500 hover:bg-red-600 text-white p-3 rounded-full shadow-md transition duration-150 ease-in-out" data-action-type="end-shift" title="Finalizar Turno/Tarea"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"> <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/> <polyline points="16 17 21 12 16 7"/> <line x1="21" x2="9" y1="12" y2="12"/> </svg> </button>
                 <button id="end-pause-button" class="hidden bg-red-500 hover:bg-red-600 text-white p-3 rounded-full shadow-md transition duration-150 ease-in-out" data-action-type="end-pause" title="Finalizar Parada"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="12" x2="12" y1="8" y2="16"/><line x1="8" x2="16" y1="12" y2="12"/></svg> </button>
            </div>

            <div class="flex flex-col justify-start items-center space-y-6">
                 <div class="w-full max-w-sm text-center">
                    <label id="worker-label" for="worker-select" class="block text-sm font-medium text-gray-700 mb-1">OPERARIO</label>
                    <div id="select-container">
                         <select id="worker-select" class="w-full" style="width: 100%"> <option value="">Cargando operarios...</option> </select>
                    </div>
                    <div id="display-container" class="hidden mt-2 flex items-center justify-center space-x-3">
                        <span id="selected-worker-info" class="text-lg text-gray-800 font-medium"></span> <button id="logout-button" title="Cambiar operario" class="text-red-500 hover:text-red-700 focus:outline-none p-1 rounded-full"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block"> <circle cx="12" cy="12" r="10"/>
                                 <path d="m15 9-6 6"/>
                                 <path d="m9 9 6 6"/>
                             </svg>
                        </button>
                    </div>
                </div>
                 <div class="text-sm w-full max-w-sm">
                    <div class="flex justify-between py-1"><span class="text-gray-600">TIEMPO EN PARADA</span><span class="font-mono font-medium text-gray-800">00:00:00</span></div>
                    <div class="flex justify-between py-1"><span class="text-gray-600">TIEMPO LENTO</span><span class="font-mono font-medium text-gray-800">00:00:00</span></div>
                    <div class="flex justify-between py-1"><span class="text-gray-600">TIEMPO ATRASADO</span><span class="font-mono font-medium text-gray-800">00:00:00</span></div>
                </div>
            </div>

            <div class="flex justify-center items-start">
                 <div id="progress-indicator" class="progress-circle" style="--progress-percent: 0;"> <span id="progress-value">0</span> </div>
            </div>
        </div>

        <div class="mt-8 border-t border-gray-200 pt-6">
            <div class="flex justify-between text-sm text-gray-500 mb-1"><span>HORA INICIO</span><span>HORA FIN</span></div>
            <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden"><div class="bg-yellow-400 h-4 rounded-full" style="width: 70%;"></div></div>
             <div class="text-right text-sm text-gray-500 mt-1">SIN DATOS</div>
        </div>

    </div>

    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11" defer onerror="console.error('Error loading SweetAlert2 script:', event)"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" defer onerror="console.error('Error loading Dragula script:', event)"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Configuración ---
            const API_BASE_URL = window.location.origin;
            const REFRESH_INTERVAL_MS = 1000;
            const API_DELAY_MS = 500;
            console.log(`API Base URL set dynamically to: ${API_BASE_URL}`);

            // Verificar librerías principales
            if (typeof $ === 'undefined' || typeof $.fn.select2 === 'undefined') { console.error("Error Crítico: jQuery o Select2 no cargados."); return; }
            if (typeof dragula !== 'function') { console.error("Error Crítico: Dragula no cargado."); return; }
            if (typeof Swal !== 'function') { console.warn("Advertencia: SweetAlert2 (Swal) no cargado."); }

            // --- Elementos del DOM ---
            const workerLabel = $('#worker-label');
            const workerSelect = $('#worker-select');
            const selectContainer = $('#select-container');
            const displayContainer = $('#display-container');
            const selectedWorkerInfo = $('#selected-worker-info');
            const logoutButton = $('#logout-button');
            const actionButtonsContainer = document.getElementById('action-buttons-container');
            const progressIndicator = document.getElementById('progress-indicator');
            const progressValue = document.getElementById('progress-value');
            let currentWorker = null;
            let currentShiftState = { type: null, action: null };
            let shiftHistoryTimeoutId = null;
            let productionLineToken = null;
            let isSelectOpen = false;
            let isProcessingLogin = false;

            // --- Función de utilidad para Delay ---
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

            // --- Función para mostrar alerta de operario requerido ---
            function showWorkerRequiredAlert() {
                 if (typeof Swal === 'function') { Swal.fire({ icon: 'warning', title: 'Acción no permitida', text: 'Por favor, selecciona un operario primero.', confirmButtonColor: '#3085d6' }); }
                 else { alert('Por favor, selecciona un operario primero.'); }
            }

             // --- Función para mostrar confirmación genérica ---
             function showActionConfirmation(actionDescription, callback) {
                 const isLogoutAction = actionDescription.includes("finalizar el turno/tarea");
                 if (!isLogoutAction && !currentWorker) { showWorkerRequiredAlert(); return; }
                 if (isLogoutAction && !currentWorker) { showWorkerRequiredAlert(); return; }

                 if (typeof Swal === 'function') {
                    Swal.fire({ /* ... Config Swal ... */
                        title: 'Confirmar Acción', text: `Estás a punto de ${actionDescription}. ¿Estás seguro?`,
                        icon: 'question', showCancelButton: true, confirmButtonColor: '#3085d6',
                        cancelButtonColor: '#d33', confirmButtonText: 'Sí', cancelButtonText: 'Cancelar'
                    }).then((result) => {
                        if (result.isConfirmed) {
                            if (!isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' confirmada por ${currentWorker.name}`); }
                            callback();
                        } else { console.log(`Acción '${actionDescription}' cancelada.`); }
                    });
                 } else { /* Fallback */
                     if (confirm(`Estás a punto de ${actionDescription}. ¿Estás seguro?`)) {
                         if (!isLogoutAction && currentWorker) { console.log(`Acción '${actionDescription}' confirmada por ${currentWorker.name}`); }
                         callback();
                     } else { console.log(`Acción '${actionDescription}' cancelada.`); }
                 }
             }

            // --- Función para enviar evento de turno a la API ---
            function postShiftEvent(eventName) {
                if (!productionLineToken || !currentWorker || !currentWorker.id) { console.error("Falta token o ID de operario para enviar evento:", eventName); showWorkerRequiredAlert(); return Promise.reject("Faltan datos para enviar evento"); }
                const eventEndpoint = '/api/shift-event';
                const eventApiUrl = `${API_BASE_URL}${eventEndpoint}`;
                const payload = { production_line_token: productionLineToken, event: eventName, operator_id: currentWorker.id };
                console.log(`Posting shift event: ${eventName} to ${eventApiUrl}`, payload);
                return fetch(eventApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify(payload) })
                .then(response => {
                    if (!response.ok) { return response.json().catch(() => null).then(errorBody => { console.error(`Error en API ${eventName}: ${response.status}`, errorBody); throw new Error(`Error ${response.status} al ${eventName}`); }); }
                    return response.text().then(text => text ? JSON.parse(text) : {});
                })
                .then(data => {
                    console.log(`Evento ${eventName} enviado con éxito. Respuesta:`, data);
                    // No refrescar inmediatamente aquí, dejar que el polling lo haga
                    return data;
                })
                .catch(error => {
                    console.error(`Fallo al enviar evento ${eventName}:`, error);
                    if (typeof Swal === 'function') { Swal.fire('Error', `No se pudo ${eventName}. ${error.message || ''}`, 'error'); }
                    else { alert(`Error al ${eventName}.`); }
                    throw error; // Propagar error
                });
            }

            // --- Función para actualizar el círculo de progreso ---
            function updateProgress(percent) {
                const clampedPercent = Math.max(0, Math.min(100, percent));
                if (progressIndicator && progressValue) { progressIndicator.style.setProperty('--progress-percent', clampedPercent); progressValue.textContent = Math.round(clampedPercent); }
                else { console.error("Elementos del círculo de progreso no encontrados."); }
            }

            // --- Función para obtener datos de progreso desde API ---
            function fetchProgressData() {
                const progressEndpoint = '/api/datos-progreso'; // EJEMPLO
                const progressApiUrl = `${API_BASE_URL}${progressEndpoint}`;
                fetch(progressApiUrl)
                    .then(response => response.ok ? response.json() : Promise.reject(`HTTP error! status: ${response.status}`))
                    .then(data => { if (data && typeof data.percentage !== 'undefined') { updateProgress(data.percentage); } else { updateProgress(0); } })
                    .catch(error => { /* console.error('Error fetching progress data:', error); */ updateProgress(0); });
            }

            // --- Inicializar Select2 ---
            workerSelect.select2({ placeholder: "Selecciona un operario...", allowClear: true, language: "es" });

            // --- Función para cargar operarios ---
            function loadWorkers() {
                const workersEndpoint = '/api/workers/list-all';
                const apiUrl = `${API_BASE_URL}${workersEndpoint}`;
                const currentSelectedId = workerSelect.val();
                console.log("Fetching workers...");
                fetch(apiUrl)
                    .then(response => response.ok ? response.json() : Promise.reject(`HTTP error! status: ${response.status}`))
                    .then(data => {
                        workerSelect.empty();
                        workerSelect.append(new Option("Selecciona un operario...", "", true, true));
                        if (data && Array.isArray(data.operators) && data.operators.length > 0) {
                            data.operators.forEach(worker => { if (worker && typeof worker.id !== 'undefined' && typeof worker.name !== 'undefined') { workerSelect.append(new Option(worker.name, worker.id)); } });
                        } else { workerSelect.append(new Option("No se encontraron operarios", "", false, true)); }
                        if (currentWorker) { workerSelect.val(currentWorker.id).trigger('change.select2'); } // Restaurar si hay login
                        // No restaurar currentSelectedId aquí para evitar conflictos
                        else { workerSelect.val(null).trigger('change'); } // Asegurar placeholder si no hay login
                        console.log("Worker list reloaded.");
                    })
                    .catch(error => { console.error('Error fetching workers:', error); workerSelect.empty().append(new Option("Error al cargar operarios", "", true, true))/*.trigger('change')*/; if (typeof Swal === 'function') Swal.fire('Error', 'No se pudo cargar la lista de operarios.', 'error'); });
            }

            // --- Pausar/Reanudar polling al abrir/cerrar Select2 ---
            workerSelect.on('select2:opening', function (e) {
                isSelectOpen = true;
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; console.log('Shift history refresh PAUSED.'); }
                // No llamar a loadWorkers aquí
            });
             workerSelect.on('select2:close', function (e) {
                 isSelectOpen = false;
                 console.log('Select2 closed, restarting history refresh.');
                 if (productionLineToken && !shiftHistoryTimeoutId) { fetchLastShiftHistory(productionLineToken); }
             });


             // --- Función para actualizar botones de acción ---
             function updateActionButtons(type, action) {
                 const buttons = actionButtonsContainer.querySelectorAll('button');
                 buttons.forEach(btn => btn.classList.add('hidden'));
                 if ((type === 'shift' && action === 'start') || (type === 'stop' && action === 'end')) { $('#start-pause-button').removeClass('hidden'); $('#end-shift-button').removeClass('hidden'); }
                 else if (type === 'stop' && action === 'start') { $('#resume-button').removeClass('hidden'); $('#end-pause-button').removeClass('hidden'); }
                 else if (type === 'shift' && action === 'end') { $('#start-shift-button').removeClass('hidden'); }
                 else { $('#start-shift-button').removeClass('hidden'); } // Estado por defecto/desconocido
             }

              // --- Añadir listeners genéricos a los botones de acción ---
              actionButtonsContainer.addEventListener('click', function(event) {
                  const button = event.target.closest('button');
                  if (!button) return;
                  const actionType = button.dataset.actionType;
                  let actionDescription = "realizar esta acción";
                  let eventName = null;
                  switch (actionType) { /* ... descripciones y eventName ... */
                      case 'start-shift': actionDescription = "iniciar el turno/tarea"; eventName = "inicio_trabajo"; break;
                      case 'start-pause': actionDescription = "iniciar una parada"; eventName = "inicio_pausa"; break;
                      case 'resume-pause': actionDescription = "reanudar la tarea"; eventName = "final_pausa"; break;
                      case 'end-shift': actionDescription = "finalizar el turno/tarea"; eventName = "final_trabajo"; break;
                      case 'end-pause': actionDescription = "finalizar la parada"; eventName = "final_pausa"; break;
                  }
                  if (!eventName) { console.error("Tipo de acción desconocida:", actionType); return; }
                  showActionConfirmation(actionDescription, () => { postShiftEvent(eventName).catch(err => { console.error(`Error en la acción ${actionType} (API):`, err); }); });
              });

             // --- Función para procesar datos del historial de turno ---
             function processShiftData(shiftData) {
                 let operator = null; let type = null; let action = null;
                 let previousState = {...currentShiftState};
                 if (shiftData && shiftData.data) { operator = shiftData.data.operator; type = shiftData.data.type; action = shiftData.data.action; }

                 const isShiftEnded = (type === 'shift' && action === 'end');
                 // Actualizar estado global solo si ha cambiado
                 if (previousState.type !== type || previousState.action !== action) {
                    currentShiftState = { type, action };
                    console.log("Processing shift data. New state:", currentShiftState);
                    updateActionButtons(type, action); // Actualizar botones solo si el estado cambió
                 }

                 // Lógica de UI de Operario (Simplificada)
                 // *** CORREGIDO: Lógica para mostrar/ocultar selector ***
                 if (isShiftEnded && !isProcessingLogin) {
                     // Turno finalizado -> Mostrar selector, limpiar operario actual si lo había
                     if (currentWorker) {
                         console.log("Shift ended, logging out current worker:", currentWorker.name);
                         currentWorker = null;
                         displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden');
                         workerSelect.val(null).trigger('change.select2');
                     } else if (selectContainer.hasClass('hidden')) { // Asegurar que se muestra el select si no había nadie
                          displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden');
                          workerSelect.val(null).trigger('change.select2');
                     }
                 } else if (operator && !currentWorker && !isProcessingLogin) {
                     // Hay operario en API y nadie logueado manualmente -> Mostrar operario API y ocultar selector
                     // *** ESTA ES LA LÓGICA DE AUTO-DISPLAY ***
                     console.log("Operator found in API, no manual login. Auto-displaying:", operator.name);
                     currentWorker = { id: operator.id, name: operator.name }; // Asignar como actual
                     selectedWorkerInfo.text(currentWorker.name);
                     workerLabel.addClass('hidden');
                     selectContainer.addClass('hidden');
                     displayContainer.removeClass('hidden');
                     workerSelect.val(currentWorker.id).trigger('change.select2'); // Sincronizar select interno
                 } else if (!operator && currentWorker && !isProcessingLogin) {
                     // No hay operario en API pero sí logueado manualmente -> Forzar logout manual
                     console.log("No operator in API, but worker logged in manually. Forcing logout.");
                     currentWorker = null;
                     displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden');
                     workerSelect.val(null).trigger('change.select2');
                 } else if (!operator && !currentWorker && !isProcessingLogin) {
                     // No hay operario en API ni manual -> Asegurar que se muestra el selector
                     if (selectContainer.hasClass('hidden')) {
                         console.log("No worker manually logged in. Ensuring selector is visible.");
                         displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden');
                     }
                 }
                 // Si hay un currentWorker (manual), esta función ya no lo toca a menos que isShiftEnded sea true (y no estemos procesando login)
             }


            // --- Función para obtener el último historial de turno (y auto-refrescar) ---
            function fetchLastShiftHistory(token) {
                if (isSelectOpen) { if (!shiftHistoryTimeoutId) { shiftHistoryTimeoutId = setTimeout(() => fetchLastShiftHistory(token), REFRESH_INTERVAL_MS); } return; }
                if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; }
                if (!token) { console.error("Token no encontrado en la URL."); updateActionButtons(null, null); return; }
                const historyEndpoint = `/api/shift-history/production-line/${token}/last`;
                const historyApiUrl = `${API_BASE_URL}${historyEndpoint}`;
                fetch(historyApiUrl)
                    .then(response => { if (!response.ok) { if (response.status === 404) { return null; } throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); })
                    .then(data => { processShiftData(data); }) // Procesar datos (o null)
                    .catch(error => { console.error('Error fetching shift history:', error); updateActionButtons(null, null); }) // Resetear botones en error
                    .finally(() => { if (!isSelectOpen) { shiftHistoryTimeoutId = setTimeout(() => fetchLastShiftHistory(token), REFRESH_INTERVAL_MS); } else { console.log("Select is open after fetch completed, refresh paused."); } });
            }

            // --- Función para obtener token de URL ---
            function getTokenFromUrl() {
                const params = new URLSearchParams(window.location.search);
                return params.get('token');
            }

            // --- Flujo Inicial ---
            productionLineToken = getTokenFromUrl();
            loadWorkers(); // Carga inicial de operarios
            fetchLastShiftHistory(productionLineToken); // Obtener estado inicial Y empezar polling
            fetchProgressData(); // Obtener progreso inicial

            // --- Manejar selección manual de operario ---
            workerSelect.on('change', async function(e) { // Convertido a async para usar await
                console.log("DEBUG: Select2 'change' event fired!");
                const selectedId = $(this).val();
                const selectedName = $(this).find('option:selected').text();

                if (!selectedId || selectedId === "") { console.log("DEBUG: Change event ignored (empty value)."); return; }
                if (currentWorker && currentWorker.id == selectedId) { console.log("DEBUG: Change event ignored (already selected worker)."); return; }

                const potentialNewWorker = { id: selectedId, name: selectedName };
                const stateBeforeConfirmation = {...currentShiftState}; // Capturar estado ANTES
                console.log("DEBUG: Operator selected in dropdown. State captured before Swal:", stateBeforeConfirmation);

                // *** RESTAURAR CONFIRMACIÓN SWAL PARA LOGIN ***
                if (typeof Swal === 'function') {
                    const swalResult = await Swal.fire({ // Usar await
                            title: 'Confirmar Operario', text: `Estás a punto de hacer login con ${potentialNewWorker.name}. ¿Estás seguro?`,
                            icon: 'question', showCancelButton: true, confirmButtonColor: '#3085d6',
                            cancelButtonColor: '#d33', confirmButtonText: 'Confirmar', cancelButtonText: 'Cancelar'
                        });

                    if (swalResult.isConfirmed) {
                        console.log("DEBUG: Operator selection CONFIRMED via Swal.");
                        currentWorker = potentialNewWorker; // Actualizar operario logueado ANTES de llamar a API
                        selectedWorkerInfo.text(currentWorker.name);
                        workerLabel.addClass('hidden'); selectContainer.addClass('hidden'); displayContainer.removeClass('hidden');
                        // Quitar Swal de éxito inmediato, esperar a secuencia API

                        // Usar estado capturado ANTES de Swal para decidir acciones
                        const isShiftEndedOrNotFound = (!stateBeforeConfirmation.type || (stateBeforeConfirmation.type === 'shift' && stateBeforeConfirmation.action === 'end'));
                        const isPaused = (stateBeforeConfirmation.type === 'stop' && stateBeforeConfirmation.action === 'start');
                        const isActive = !isShiftEndedOrNotFound && !isPaused;
                        console.log("DEBUG: Checking shift actions. State at selection time:", stateBeforeConfirmation, "isShiftEndedOrNotFound:", isShiftEndedOrNotFound, "isPaused:", isPaused, "isActive:", isActive);

                        let sequenceSuccess = false;
                        isProcessingLogin = true; // *** Activar flag ANTES de secuencia ***
                        try {
                            // Mostrar Swal de procesamiento ANTES de las llamadas API
                            Swal.fire({ title: 'Procesando cambio...', allowOutsideClick: false, didOpen: () => { Swal.showLoading() } });

                            if (isShiftEndedOrNotFound) {
                                console.log("DEBUG: Attempting: Start Shift");
                                await postShiftEvent("inicio_trabajo");
                                sequenceSuccess = true;

                            } else if (isPaused) {
                                console.log("DEBUG: Attempting: Resume Pause -> End Shift -> Start Shift");
                                await postShiftEvent("final_pausa");
                                await delay(API_DELAY_MS);
                                await postShiftEvent("final_trabajo");
                                await delay(API_DELAY_MS);
                                await postShiftEvent("inicio_trabajo");
                                sequenceSuccess = true;

                            } else if (isActive) {
                                console.log("DEBUG: Attempting: End Shift -> Start Shift");
                                await postShiftEvent("final_trabajo");
                                await delay(API_DELAY_MS);
                                await postShiftEvent("inicio_trabajo");
                                sequenceSuccess = true;
                            }

                            // Cerrar Swal de procesamiento y mostrar éxito si la secuencia terminó bien
                            if (sequenceSuccess) {
                                Swal.fire('¡Éxito!', `Operaciones de turno completadas para ${currentWorker.name}.`, 'success');
                            } else { Swal.close(); } // Cerrar 'procesando' si no se hizo nada

                        } catch (error) {
                            console.error("DEBUG: Error during shift change sequence:", error);
                            if (Swal.isLoading()) { Swal.close(); } // Cerrar 'procesando'
                            // Opcional: Revertir UI login si falla secuencia? Podría ser confuso.
                            // currentWorker = null; displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden'); workerSelect.val(null).trigger('change.select2');
                        } finally {
                             isProcessingLogin = false; // *** Desactivar flag al final ***
                             console.log("DEBUG: Login processing finished.");
                             // Forzar un refresco después de procesar para asegurar estado final
                             if (shiftHistoryTimeoutId) { clearTimeout(shiftHistoryTimeoutId); shiftHistoryTimeoutId = null; }
                             fetchLastShiftHistory(productionLineToken);
                        }

                    } else if (swalResult.isDismissed) {
                         console.log("DEBUG: Operator selection CANCELLED via Swal.");
                         // Revertir al estado anterior visualmente en el select
                         if (currentWorker) { workerSelect.val(currentWorker.id).trigger('change.select2'); }
                         else { workerSelect.val(null).trigger('change.select2'); }
                    }
                } else { /* Fallback alert */
                   // ... (mantener fallback si es necesario) ...
                }
            });


             // --- Manejar clic en botón Logout (X) ---
             logoutButton.on('click', function() {
                 const logoutDescription = "finalizar el turno/tarea";
                 const eventName = "final_trabajo";
                 if (!currentWorker) { showWorkerRequiredAlert(); return; }

                 showActionConfirmation(logoutDescription, () => {
                     postShiftEvent(eventName)
                         .then(() => {
                             console.log("Logout API call successful, updating UI.");
                             currentWorker = null;
                             displayContainer.addClass('hidden'); workerLabel.removeClass('hidden'); selectContainer.removeClass('hidden');
                             workerSelect.val(null).trigger('change.select2');
                         })
                         .catch(err => { console.error("Logout failed:", err); });
                 });
             });

            // --- Lógica Kanban (Dragula) ---
            const columns = Array.from(document.querySelectorAll('.kanban-column'));
            if (columns.length === 0) { console.error("Error: No se encontraron columnas Kanban."); return; }

            let longPressTimer = null; let isTouchInteraction = false; let longPressTriggered = false;
            const longPressDelay = 500; let startX, startY; let currentCard = null;

            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
            document.addEventListener('touchcancel', handleTouchEnd);

            function handleTouchStart(e) { /* ... lógica táctil ... */
                const card = e.target.closest('.kanban-card'); if (!card) { isTouchInteraction = false; return; }
                currentCard = card; isTouchInteraction = true; longPressTriggered = false;
                startX = e.touches[0].clientX; startY = e.touches[0].clientY; clearTimeout(longPressTimer);
                longPressTimer = setTimeout(() => { if (!isTouchInteraction || !currentCard) return; longPressTriggered = true; currentCard.classList.add('long-press-ready'); if (navigator.vibrate) navigator.vibrate(50); }, longPressDelay);
            }
            function handleTouchMove(e) { /* ... lógica táctil ... */
                if (!isTouchInteraction || !currentCard) return; const currentX = e.touches[0].clientX; const currentY = e.touches[0].clientY;
                const deltaX = Math.abs(currentX - startX); const deltaY = Math.abs(currentY - startY); const moveThreshold = 10;
                if (!longPressTriggered && (deltaX > moveThreshold || deltaY > moveThreshold)) { clearTimeout(longPressTimer); if(currentCard) currentCard.classList.remove('long-press-ready'); }
            }
            function handleTouchEnd(e) { /* ... lógica táctil ... */
                clearTimeout(longPressTimer); if (currentCard) currentCard.classList.remove('long-press-ready');
                isTouchInteraction = false; longPressTriggered = false; currentCard = null;
            }

            const drake = dragula(columns);
            if (!drake) { console.error("Error: Falló la inicialización de Dragula."); return; }

            // --- Eventos Dragula ---
            drake.on('drag', (el, source) => {
                // *** VALIDACIÓN DE OPERARIO ***
                if (!currentWorker) { drake.cancel(true); showWorkerRequiredAlert(); return; }
                // --- FIN VALIDACIÓN ---
                if (isTouchInteraction && !longPressTriggered) { drake.cancel(true); isTouchInteraction = false; longPressTriggered = false; if(currentCard) currentCard.classList.remove('long-press-ready'); currentCard = null; return; }
                if (el) el.classList.remove('long-press-ready');
            });
            drake.on('drop', (el, target, source, sibling) => { /* ... lógica dragula drop ... */
                const sourceColumnName = source.dataset.columnName || source.id; const targetColumnName = target.dataset.columnName || target.id;
                const message = `Moviste la tarjeta "${el.innerText.split('\n')[0]}" de "${sourceColumnName}" a "${targetColumnName}".`;
                // TODO: Aquí debería ir una llamada API para registrar el movimiento de la tarjeta Kanban
                console.log("TODO: Llamar API para registrar movimiento Kanban", { cardId: el.dataset.cardId, targetColumn: targetColumnName });
                if (typeof Swal === 'function') Swal.fire({ title: 'Movimiento Registrado (Simulado)', text: message, icon: 'success', timer: 2000, timerProgressBar: true }); else alert(message);
                isTouchInteraction = false; longPressTriggered = false; if (el) el.classList.remove('long-press-ready'); currentCard = null;
            });
            drake.on('cancel', (el, container, source) => { /* ... lógica dragula cancel ... */ isTouchInteraction = false; longPressTriggered = false; if (el) el.classList.remove('long-press-ready'); currentCard = null; });
            drake.on('dragend', (el) => { /* ... lógica dragula dragend ... */ isTouchInteraction = false; longPressTriggered = false; if (el) el.classList.remove('long-press-ready'); });
            drake.on('dragover', function (el, container) { container.classList.add('bg-gray-200'); });
            drake.on('dragout', function (el, container) { container.classList.remove('bg-gray-200'); });

        }); // Fin de DOMContentLoaded
    </script>

</body>
</html>
