<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabla Trabajadores Ordenada por Primer Puesto</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        @media print {
            .no-print { display: none !important; }
            body { padding: 0; }
            .container { box-shadow: none; margin: 0; max-width: 100%; }
        }
        .live-cajas-hora {
            /* Puedes añadir un estilo sutil si quieres indicar que se actualiza, ej:
            font-style: italic;
            color: #2563eb; */
        }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

<div class="container mx-auto bg-white rounded-lg shadow-md overflow-hidden">
    <div class="p-4 md:p-6 border-b border-gray-200">
        <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-4 gap-4">
             <h1 class="text-2xl font-bold text-gray-700 mb-2 sm:mb-0">Listado de Trabajadores y Puestos</h1>
             <div class="flex flex-col sm:flex-row sm:items-center gap-4 no-print">
                 <div class="flex items-center space-x-2">
                     <label for="dateRangeSelect" class="text-sm font-medium text-gray-700">Periodo:</label>
                     <select id="dateRangeSelect" name="dateRange" class="block w-full sm:w-auto pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 rounded-md shadow-sm">
                         <option value="today" selected>Hoy</option>
                         <option value="yesterday">Ayer</option>
                         <option value="day_minus_2">Hace 2 días</option>
                         <option value="day_minus_3">Hace 3 días</option>
                         <option value="day_minus_4">Hace 4 días</option>
                         <option value="day_minus_5">Hace 5 días</option>
                         <option value="day_minus_6">Hace 6 días</option>
                         <option value="day_minus_7">Hace 7 días</option>
                         <option value="last7days">Últimos 7 días (rango)</option>
                         <option value="last30days">Últimos 30 días (rango)</option>
                     </select>
                 </div>
                  <div class="flex items-center">
                    <input id="filterPostsCheckbox" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" checked>
                    <label for="filterPostsCheckbox" class="ml-2 block text-sm text-gray-900">
                        Solo operarios con asignaciones
                    </label>
                </div>
             </div>
        </div>
         <div class="flex justify-end space-x-2 no-print">
            <button id="exportExcelBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                Exportar a Excel
            </button>
            <button id="printBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors duration-150 ease-in-out">
                Imprimir
            </button>
        </div>
    </div>

    <div class="overflow-x-auto p-4 md:p-6">
        <table id="workersTable" class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Codigo</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nombre</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unidades (Turno)</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Puesto</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Inicio Puesto</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Fin Puesto</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cantidad</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cajas/Hora</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Confeccion</th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200" id="workersTableBody">
                <tr id="loadingRow">
                    <td colspan="9" class="px-4 py-4 text-center text-gray-500">Cargando datos...</td>
                </tr>
                <tr id="errorRow" class="hidden">
                     <td colspan="9" class="px-4 py-4 text-center text-red-500"></td>
                </tr>
                 <tr id="noDataRow" class="hidden">
                     <td colspan="9" class="px-4 py-4 text-center text-gray-500">No se encontraron datos para el periodo seleccionado.</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<script>
    // URL base de la API (sin fechas)
    const apiBaseUrl = '/api/workers/all-list/completed'; // Asegúrate que esta URL sea correcta
    const tableBody = document.getElementById('workersTableBody');
    const loadingRow = document.getElementById('loadingRow');
    const errorRow = document.getElementById('errorRow');
    const errorCell = errorRow.querySelector('td');
    const noDataRow = document.getElementById('noDataRow');
    const exportExcelBtn = document.getElementById('exportExcelBtn');
    const printBtn = document.getElementById('printBtn');
    const dateRangeSelect = document.getElementById('dateRangeSelect');
    const filterPostsCheckbox = document.getElementById('filterPostsCheckbox');

    let originalWorkersData = [];
    let displayedPostRowsCount = 0;
    let liveUpdateIntervalId = null; // ID para el intervalo de actualización en vivo

    const dateTimeFormatOptions = {
        year: 'numeric', month: 'numeric', day: 'numeric',
        hour: 'numeric', minute: 'numeric', second: 'numeric',
        hour12: false
    };
    const dateFormatter = new Intl.DateTimeFormat(navigator.language || 'es-ES', dateTimeFormatOptions);

    // --- Funciones ---

    function formatDateForAPI(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function getDateRange(selectedValue) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        let fromDate = new Date(today);
        let endDate = new Date(today);

        switch (selectedValue) {
            case 'today': break;
            case 'yesterday': fromDate.setDate(today.getDate() - 1); endDate.setDate(today.getDate() - 1); break;
            case 'day_minus_2': fromDate.setDate(today.getDate() - 2); endDate.setDate(today.getDate() - 2); break;
            case 'day_minus_3': fromDate.setDate(today.getDate() - 3); endDate.setDate(today.getDate() - 3); break;
            case 'day_minus_4': fromDate.setDate(today.getDate() - 4); endDate.setDate(today.getDate() - 4); break;
            case 'day_minus_5': fromDate.setDate(today.getDate() - 5); endDate.setDate(today.getDate() - 5); break;
            case 'day_minus_6': fromDate.setDate(today.getDate() - 6); endDate.setDate(today.getDate() - 6); break;
            case 'day_minus_7': fromDate.setDate(today.getDate() - 7); endDate.setDate(today.getDate() - 7); break;
            case 'last7days': fromDate.setDate(today.getDate() - 6); break;
            case 'last30days': fromDate.setDate(today.getDate() - 29); break;
            default: break;
        }
        let apiToDate = new Date(endDate);
        apiToDate.setDate(endDate.getDate() + 1);
        return { from: formatDateForAPI(fromDate), to: formatDateForAPI(apiToDate) };
    }

    /**
     * Calcula el valor de "Cajas/Hora".
     * @param {number|string} count - La cantidad de cajas.
     * @param {string} startTimeStr - La fecha/hora de inicio del puesto (ISO string).
     * @param {string|null} endTimeStr - La fecha/hora de fin del puesto (ISO string) o null si no ha terminado.
     * @returns {string|number} El ratio formateado o 'N/A' o 0.
     */
    function calculateCajasHora(count, startTimeStr, endTimeStr) {
        const quantity = parseFloat(count) || 0;

        if (!startTimeStr) return 'N/A'; // No hay hora de inicio

        const startTime = new Date(startTimeStr);
        if (isNaN(startTime.getTime())) return 'N/A'; // Hora de inicio inválida

        // Si no hay hora de fin, usa la hora actual para el cálculo
        const endTime = endTimeStr ? new Date(endTimeStr) : new Date();
        if (isNaN(endTime.getTime())) return 'N/A'; // Hora de fin inválida (poco probable para new Date())

        // Si la hora de fin es anterior o igual a la de inicio, no se puede calcular una tasa positiva
        if (endTime <= startTime) {
             return quantity > 0 ? 'N/A' : 0; // Si hay cantidad, es N/A, si no, es 0
        }

        const diffMs = endTime.getTime() - startTime.getTime();
        const diffHours = diffMs / (1000 * 60 * 60);

        if (diffHours <= 0) { // Aunque ya cubierto por endTime <= startTime, es una doble verificación
            return quantity > 0 ? 'N/A' : 0;
        }
        
        if (quantity === 0) return '0.00'; // Si no hay cantidad, la tasa es 0

        const rate = quantity / diffHours;
        return rate.toFixed(2); // Formatea a 2 decimales
    }

    /**
     * Actualiza las celdas de "Cajas/Hora" que están marcadas para actualización en vivo.
     */
    function updateLiveCajasHoraCells() {
        const liveCells = document.querySelectorAll('.live-cajas-hora');
        liveCells.forEach(cell => {
            const startTimeStr = cell.dataset.startTime;
            const count = cell.dataset.count;
            // Pasa null como endTimeStr para que calculateCajasHora use la hora actual
            cell.textContent = calculateCajasHora(count, startTimeStr, null);
        });
    }


    function filterDataByCheckbox(data) {
        if (filterPostsCheckbox.checked) {
            return data.filter(worker =>
                worker.operator_posts && worker.operator_posts.some(post => (post.count ?? 0) > 0)
            );
        }
        return data;
    }

    function populateTable(data) {
        if (liveUpdateIntervalId) { // Limpia el intervalo anterior si existe
            clearInterval(liveUpdateIntervalId);
            liveUpdateIntervalId = null;
        }

        tableBody.querySelectorAll('tr:not(#loadingRow):not(#errorRow):not(#noDataRow)').forEach(row => row.remove());
        displayedPostRowsCount = 0;
        const dataToDisplay = filterDataByCheckbox(data);

        if (dataToDisplay.length === 0) {
            if (filterPostsCheckbox.checked && data.length > 0) {
                 noDataRow.querySelector('td').textContent = 'Ningún trabajador con puestos asignados (con cantidad > 0) en este periodo.';
            } else {
                 noDataRow.querySelector('td').textContent = 'No se encontraron datos para el periodo seleccionado.';
            }
            noDataRow.classList.remove('hidden');
            exportExcelBtn.disabled = true;
            return;
        }

        noDataRow.classList.add('hidden');
        let workersWithVisiblePosts = 0;
        let hasLiveCells = false; // Flag para saber si necesitamos iniciar el intervalo

        dataToDisplay.forEach((worker) => {
            let totalQuantitySum = 0;
            if (worker.operator_posts && worker.operator_posts.length > 0) {
                 totalQuantitySum = worker.operator_posts.reduce((sum, post) => {
                    const count = post.count ?? 0;
                    return sum + (count > 0 ? count : 0);
                }, 0);
            }

            const hasVisiblePosts = worker.operator_posts && worker.operator_posts.some(post => (post.count ?? 0) > 0);
            if (filterPostsCheckbox.checked && !hasVisiblePosts) {
                return;
            }
            workersWithVisiblePosts++;

            const workerRow = tableBody.insertRow();
            workerRow.classList.add('bg-blue-50', 'hover:bg-blue-100', 'transition-colors', 'duration-150', 'ease-in-out');
            workerRow.insertCell().textContent = worker.client_id ?? '-';
            workerRow.insertCell().textContent = worker.name ?? 'Sin Nombre';
            workerRow.insertCell().textContent = totalQuantitySum;
            workerRow.insertCell().textContent = ''; // Puesto
            workerRow.insertCell().textContent = ''; // Inicio Puesto
            workerRow.insertCell().textContent = ''; // Fin Puesto
            workerRow.insertCell().textContent = ''; // Cantidad
            workerRow.insertCell().textContent = ''; // Cajas/Hora (vacío para fila de trabajador)
            workerRow.insertCell().textContent = ''; // Confeccion
            Array.from(workerRow.cells).forEach(cell => cell.classList.add('px-4', 'py-3', 'text-sm', 'font-medium', 'text-gray-900', 'whitespace-nowrap'));

             if (worker.operator_posts && worker.operator_posts.length > 0) {
                 const sortedPosts = [...worker.operator_posts].sort((postA, postB) => {
                    const dateA = postA.created_at ? new Date(postA.created_at) : null;
                    const dateB = postB.created_at ? new Date(postB.created_at) : null;
                    if (dateA && dateB) return dateA - dateB;
                    if (dateA) return -1;
                    if (dateB) return 1;
                    return 0;
                 });

                sortedPosts.forEach((post, index) => {
                    if ((post.count ?? 0) > 0) {
                        displayedPostRowsCount++;
                        const postRow = tableBody.insertRow();
                        postRow.classList.add(index % 2 === 0 ? 'bg-white' : 'bg-gray-50', 'hover:bg-gray-100', 'transition-colors', 'duration-150', 'ease-in-out');

                        postRow.insertCell().textContent = ''; // Codigo
                        postRow.insertCell().textContent = ''; // Nombre
                        postRow.insertCell().textContent = ''; // Unidades (Turno)
                        postRow.insertCell().textContent = post.rfid_reading?.name ?? 'N/A'; // Puesto

                        let startDate = '-';
                        if (post.created_at) { try { startDate = dateFormatter.format(new Date(post.created_at)); } catch (e) { console.error("Error formateando fecha inicio:", post.created_at, e); } }
                        let endDate = '-';
                        if (post.finish_at) { try { endDate = dateFormatter.format(new Date(post.finish_at)); } catch (e) { console.error("Error formateando fecha fin:", post.finish_at, e); } }
                        postRow.insertCell().textContent = startDate;
                        postRow.insertCell().textContent = endDate;
                        postRow.insertCell().textContent = post.count ?? 0; // Cantidad

                        // --- Celda Cajas/Hora ---
                        const cajasHoraCell = postRow.insertCell();
                        const cajasHoraValue = calculateCajasHora(post.count, post.created_at, post.finish_at);
                        cajasHoraCell.textContent = cajasHoraValue;

                        // Si no hay fecha de fin y hay fecha de inicio, marcar para actualización en vivo
                        if (!post.finish_at && post.created_at) {
                            cajasHoraCell.classList.add('live-cajas-hora');
                            cajasHoraCell.dataset.startTime = post.created_at;
                            cajasHoraCell.dataset.count = post.count ?? 0;
                            hasLiveCells = true; // Indicamos que hay celdas para actualizar
                        }
                        // --- Fin Celda Cajas/Hora ---

                        postRow.insertCell().textContent = post.product_list?.name ?? 'N/A'; // Confeccion

                        Array.from(postRow.cells).forEach(cell => cell.classList.add('px-4', 'py-3', 'text-sm', 'text-gray-600', 'whitespace-nowrap'));
                        postRow.cells[3].classList.add('pl-8');
                    }
                });
            }
        });

        if (workersWithVisiblePosts === 0) {
             if (filterPostsCheckbox.checked) {
                 noDataRow.querySelector('td').textContent = 'Ningún trabajador cumple los criterios de filtro (con puestos y cantidad > 0).';
             } else {
                 noDataRow.querySelector('td').textContent = 'No se encontraron datos para el periodo seleccionado.';
             }
             noDataRow.classList.remove('hidden');
             exportExcelBtn.disabled = true;
        } else {
             exportExcelBtn.disabled = false;
        }

        // Inicia el intervalo de actualización solo si hay celdas que lo necesiten
        if (hasLiveCells) {
            liveUpdateIntervalId = setInterval(updateLiveCajasHoraCells, 5000); // Actualiza cada 5 segundos
        }
    }

    /**
     * Exporta los datos visibles a Excel.
     * Los datos ya estarán ordenados según el primer puesto del trabajador.
     * Incluye la columna renombrada 'Puesto'.
     * Calcula la suma de cantidades para la columna "Unidades Turno".
     * Calcula "Cajas/Hora" para cada puesto.
     */
    function exportToExcel() {
        const dataFilteredByCheckbox = filterDataByCheckbox(originalWorkersData);
        if (!dataFilteredByCheckbox || dataFilteredByCheckbox.length === 0) {
            alert("No hay datos que coincidan con el filtro para exportar.");
            return;
        }

        const flattenedData = [];
        dataFilteredByCheckbox.forEach(worker => {
            let totalQuantitySum = 0;
            if (worker.operator_posts && worker.operator_posts.length > 0) {
                 totalQuantitySum = worker.operator_posts.reduce((sum, post) => {
                    const count = post.count ?? 0;
                    return sum + (count > 0 ? count : 0);
                }, 0);
            }

            const workerHasVisiblePosts = worker.operator_posts && worker.operator_posts.some(post => (post.count ?? 0) > 0);
            if (filterPostsCheckbox.checked && !workerHasVisiblePosts) {
                return; // Saltar al siguiente trabajador si el filtro está activo y no tiene puestos visibles
            }

            if (worker.operator_posts && worker.operator_posts.length > 0) {
                 const sortedPostsExcel = [...worker.operator_posts].sort((postA, postB) => {
                    const dateA = postA.created_at ? new Date(postA.created_at) : null;
                    const dateB = postB.created_at ? new Date(postB.created_at) : null;
                    if (dateA && dateB) return dateA - dateB;
                    if (dateA) return -1; if (dateB) return 1; return 0;
                 });

                sortedPostsExcel.forEach(post => {
                    if ((post.count ?? 0) > 0) { // Solo incluir puestos con cantidad > 0
                        let startDateExcel = '-';
                        if (post.created_at) { try { startDateExcel = dateFormatter.format(new Date(post.created_at)); } catch (e) {/* ignore */} }
                        let endDateExcel = '-';
                        if (post.finish_at) { try { endDateExcel = dateFormatter.format(new Date(post.finish_at)); } catch (e) {/* ignore */} }

                        const cajasHoraExcelValue = calculateCajasHora(post.count, post.created_at, post.finish_at);

                        flattenedData.push({
                            'Codigo': worker.client_id ?? '-',
                            'Nombre Trabajador': worker.name ?? 'Sin Nombre',
                            'Unidades Turno': totalQuantitySum,
                            'Puesto': post.rfid_reading?.name ?? 'N/A',
                            'Inicio Puesto': startDateExcel,
                            'Fin Puesto': endDateExcel,
                            'Cantidad Puesto': post.count ?? 0,
                            'Cajas/Hora': cajasHoraExcelValue,
                            'Confeccion': post.product_list?.name ?? 'N/A'
                        });
                    }
                });
             }
        });

        if (flattenedData.length === 0) {
             alert("No hay detalles de puestos con cantidad mayor que 0 para exportar (según los filtros aplicados).");
             return;
        }

        // Definir el orden de las columnas para el Excel
        const columnOrder = [
            'Codigo', 'Nombre Trabajador', 'Unidades Turno', 'Puesto',
            'Inicio Puesto', 'Fin Puesto', 'Cantidad Puesto', 'Cajas/Hora', 'Confeccion'
        ];

        // Reordenar los datos para asegurar que las columnas estén en el orden deseado
        // y que todos los objetos tengan las mismas claves.
        const reorderedData = flattenedData.map(row => {
            const newRow = {};
            columnOrder.forEach(colName => {
                newRow[colName] = row[colName] !== undefined ? row[colName] : ''; // Usar '' para valores undefined
            });
            return newRow;
        });

        // Crear la hoja de cálculo usando los datos reordenados y el array columnOrder como encabezado
        const worksheet = XLSX.utils.json_to_sheet(reorderedData, { header: columnOrder });

        // Ajustar el ancho de las columnas
        const colWidths = columnOrder.map(key => {
            const maxContentWidth = reorderedData.reduce((w, r) => Math.max(w, (r[key]?.toString() ?? '').length), 0);
            const headerWidth = key.length;
            return { wch: Math.max(headerWidth, maxContentWidth) + 2 }; // +2 para un poco de padding
        });
        worksheet["!cols"] = colWidths;

        // Crear un nuevo libro de trabajo y añadir la hoja
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "TrabajadoresDetalle");

        // Generar nombre del archivo y descargar
        const selectedOptionText = dateRangeSelect.options[dateRangeSelect.selectedIndex].text;
        const fileNameDate = selectedOptionText.replace(/ /g, '_');
        const filterSuffix = filterPostsCheckbox.checked ? '_ConPuestos_SumaCant' : '_SumaCant';
        const fileName = `Informe_Trabajadores_${fileNameDate}${filterSuffix}.xlsx`;

        XLSX.writeFile(workbook, fileName);
    }


    function printTable() {
        window.print();
    }

    function fetchData(fromDate, toDate) {
        const apiUrl = `${apiBaseUrl}?from_date=${fromDate}&to_date=${toDate}`;

        loadingRow.classList.remove('hidden');
        errorRow.classList.add('hidden');
        noDataRow.classList.add('hidden');
        tableBody.querySelectorAll('tr:not(#loadingRow):not(#errorRow):not(#noDataRow)').forEach(row => row.remove());
        exportExcelBtn.disabled = true;
        originalWorkersData = [];

        if (liveUpdateIntervalId) {
            clearInterval(liveUpdateIntervalId);
            liveUpdateIntervalId = null;
        }

        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                     return response.text().then(text => {
                         throw new Error(`Error HTTP: ${response.status} - ${response.statusText}. Respuesta: ${text || '(sin cuerpo)'}`);
                     });
                }
                return response.json();
            })
            .then(apiResponse => {
                loadingRow.classList.add('hidden');
                if (apiResponse.success && Array.isArray(apiResponse.data)) {
                    originalWorkersData = apiResponse.data;
                    originalWorkersData.sort((workerA, workerB) => {
                        const findFirstActivePost = (worker) => {
                            if (!worker.operator_posts || worker.operator_posts.length === 0) return null;
                            const activePosts = worker.operator_posts
                                .filter(p => (p.count ?? 0) > 0 && p.created_at)
                                .map(p => ({ ...p, createdAtDate: new Date(p.created_at) }))
                                .filter(p => !isNaN(p.createdAtDate));
                            if (activePosts.length === 0) return null;
                            activePosts.sort((a, b) => a.createdAtDate - b.createdAtDate);
                            return activePosts[0];
                        };
                        const firstPostA = findFirstActivePost(workerA);
                        const firstPostB = findFirstActivePost(workerB);
                        const puestoNameA = firstPostA?.rfid_reading?.name ?? null;
                        const puestoNameB = firstPostB?.rfid_reading?.name ?? null;

                        if (puestoNameA && puestoNameB) {
                            const nameComparison = puestoNameA.localeCompare(puestoNameB);
                            if (nameComparison !== 0) return nameComparison;
                            return (workerA.name ?? '').localeCompare(workerB.name ?? '');
                        } else if (puestoNameA) return -1;
                        else if (puestoNameB) return 1;
                        else return (workerA.name ?? '').localeCompare(workerB.name ?? '');
                    });
                    populateTable(originalWorkersData);
                }
                else if (apiResponse.success && (!Array.isArray(apiResponse.data) || apiResponse.data.length === 0)) {
                    originalWorkersData = [];
                    populateTable(originalWorkersData);
                } else {
                    errorCell.textContent = `Error: Respuesta inesperada de la API. Mensaje: ${apiResponse.message || 'No especificado'}`;
                    errorRow.classList.remove('hidden');
                    exportExcelBtn.disabled = true;
                }
            })
            .catch(error => {
                console.error("Error detallado en fetch:", error);
                loadingRow.classList.add('hidden');
                errorCell.textContent = `Error al cargar datos: ${error.message}`;
                errorRow.classList.remove('hidden');
                exportExcelBtn.disabled = true;
            });
    }

    // --- Lógica Principal (Event Listeners e Inicialización) ---
    exportExcelBtn.disabled = true;
    exportExcelBtn.addEventListener('click', exportToExcel);
    printBtn.addEventListener('click', printTable);

    dateRangeSelect.addEventListener('change', (event) => {
        const selectedRange = event.target.value;
        const { from, to } = getDateRange(selectedRange);
        fetchData(from, to);
    });

    filterPostsCheckbox.addEventListener('change', () => {
        populateTable(originalWorkersData);
    });

    function loadInitialData() {
         const initialRangeValue = dateRangeSelect.value;
         const { from, to } = getDateRange(initialRangeValue);
         fetchData(from, to);
    }

    document.addEventListener('DOMContentLoaded', loadInitialData);
</script>

</body>
</html>
