<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabla Trabajadores Ordenada por Primer Puesto</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        @media print {
            .no-print { display: none !important; }
            body { padding: 0; }
            .container { box-shadow: none; margin: 0; max-width: 100%; }
        }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

<div class="container mx-auto bg-white rounded-lg shadow-md overflow-hidden">
    <div class="p-4 md:p-6 border-b border-gray-200">
        <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-4 gap-4">
             <h1 class="text-2xl font-bold text-gray-700 mb-2 sm:mb-0">Listado de Trabajadores y Puestos</h1>
             <div class="flex flex-col sm:flex-row sm:items-center gap-4 no-print">
                 <div class="flex items-center space-x-2">
                     <label for="dateRangeSelect" class="text-sm font-medium text-gray-700">Periodo:</label>
                     <select id="dateRangeSelect" name="dateRange" class="block w-full sm:w-auto pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 rounded-md shadow-sm">
                         <option value="today" selected>Hoy</option>
                         <option value="yesterday">Ayer</option>
                         <option value="day_minus_2">Hace 2 días</option>
                         <option value="day_minus_3">Hace 3 días</option>
                         <option value="day_minus_4">Hace 4 días</option>
                         <option value="day_minus_5">Hace 5 días</option>
                         <option value="day_minus_6">Hace 6 días</option>
                         <option value="day_minus_7">Hace 7 días</option>
                         <option value="last7days">Últimos 7 días (rango)</option>
                         <option value="last30days">Últimos 30 días (rango)</option>
                     </select>
                 </div>
                  <div class="flex items-center">
                    <input id="filterPostsCheckbox" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" checked>
                    <label for="filterPostsCheckbox" class="ml-2 block text-sm text-gray-900">
                        Solo operarios con asignaciones
                    </label>
                </div>
             </div>
        </div>
         <div class="flex justify-end space-x-2 no-print">
            <button id="exportExcelBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                Exportar a Excel
            </button>
            <button id="printBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors duration-150 ease-in-out">
                Imprimir
            </button>
        </div>
    </div>

    <div class="overflow-x-auto p-4 md:p-6">
        <table id="workersTable" class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Codigo Trabajador</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nombre</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unidades (Turno)</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Puesto</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Inicio Puesto</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Fin Puesto</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cantidad</th>
                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Confeccion</th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200" id="workersTableBody">
                <tr id="loadingRow">
                    <td colspan="8" class="px-4 py-4 text-center text-gray-500">Cargando datos...</td>
                </tr>
                <tr id="errorRow" class="hidden">
                     <td colspan="8" class="px-4 py-4 text-center text-red-500"></td>
                </tr>
                 <tr id="noDataRow" class="hidden">
                     <td colspan="8" class="px-4 py-4 text-center text-gray-500">No se encontraron datos para el periodo seleccionado.</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<script>
    // URL base de la API (sin fechas)
    const apiBaseUrl = '/api/workers/all-list/completed'; // Asegúrate que esta URL sea correcta
    const tableBody = document.getElementById('workersTableBody');
    const loadingRow = document.getElementById('loadingRow');
    const errorRow = document.getElementById('errorRow');
    const errorCell = errorRow.querySelector('td');
    const noDataRow = document.getElementById('noDataRow');
    const exportExcelBtn = document.getElementById('exportExcelBtn');
    const printBtn = document.getElementById('printBtn');
    const dateRangeSelect = document.getElementById('dateRangeSelect');
    const filterPostsCheckbox = document.getElementById('filterPostsCheckbox');

    // Variable para almacenar los datos originales (sin filtrar por checkbox) una vez cargados
    let originalWorkersData = [];
    // Variable para contar cuántas filas de puestos se muestran realmente
    let displayedPostRowsCount = 0;

    // Opciones para formatear la fecha y hora localmente para visualización
    const dateTimeFormatOptions = {
        year: 'numeric', month: 'numeric', day: 'numeric',
        hour: 'numeric', minute: 'numeric', second: 'numeric',
        hour12: false // Formato de 24 horas
    };
    const dateFormatter = new Intl.DateTimeFormat(navigator.language || 'es-ES', dateTimeFormatOptions);

    // --- Funciones ---

    /**
     * Formatea un objeto Date a 'YYYY-MM-DD' para la API.
     * @param {Date} date - La fecha a formatear.
     * @returns {string} La fecha formateada.
     */
    function formatDateForAPI(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    /**
     * Calcula las fechas de inicio y fin para la API según la opción seleccionada.
     * @param {string} selectedValue - El valor del select de rango de fechas.
     * @returns {{from: string, to: string}} Las fechas de inicio y fin formateadas.
     */
    function getDateRange(selectedValue) {
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Asegura que la hora sea 00:00:00

        let fromDate = new Date(today);
        let endDate = new Date(today); // Por defecto es hoy

        switch (selectedValue) {
            case 'today': break;
            case 'yesterday': fromDate.setDate(today.getDate() - 1); endDate.setDate(today.getDate() - 1); break;
            case 'day_minus_2': fromDate.setDate(today.getDate() - 2); endDate.setDate(today.getDate() - 2); break;
            case 'day_minus_3': fromDate.setDate(today.getDate() - 3); endDate.setDate(today.getDate() - 3); break;
            case 'day_minus_4': fromDate.setDate(today.getDate() - 4); endDate.setDate(today.getDate() - 4); break;
            case 'day_minus_5': fromDate.setDate(today.getDate() - 5); endDate.setDate(today.getDate() - 5); break;
            case 'day_minus_6': fromDate.setDate(today.getDate() - 6); endDate.setDate(today.getDate() - 6); break;
            case 'day_minus_7': fromDate.setDate(today.getDate() - 7); endDate.setDate(today.getDate() - 7); break;
            case 'last7days': fromDate.setDate(today.getDate() - 6); break;
            case 'last30days': fromDate.setDate(today.getDate() - 29); break;
            default: break;
        }

        // La API espera que 'to_date' sea el día *después* del último día que quieres incluir
        let apiToDate = new Date(endDate);
        apiToDate.setDate(endDate.getDate() + 1);

        return {
            from: formatDateForAPI(fromDate),
            to: formatDateForAPI(apiToDate)
        };
    }

    /**
     * Filtra los datos según el estado del checkbox "Mostrar solo con puestos".
     * @param {Array} data - Los datos originales de los trabajadores.
     * @returns {Array} Los datos filtrados.
     */
    function filterDataByCheckbox(data) {
        if (filterPostsCheckbox.checked) {
            // Filtra trabajadores que tengan al menos un puesto con cantidad > 0
            return data.filter(worker =>
                worker.operator_posts && worker.operator_posts.some(post => (post.count ?? 0) > 0)
            );
        }
        return data; // Devuelve todos si el checkbox no está marcado
    }

    /**
     * Rellena la tabla HTML con los datos de los trabajadores y sus puestos.
     * Filtra los puestos con cantidad 0.
     * Calcula la suma de cantidades para la columna "Unidades (Turno)".
     * @param {Array} data - Los datos de los trabajadores (ya filtrados por checkbox y ordenados).
     */
    function populateTable(data) {
        // Limpia filas existentes excepto las de estado
        tableBody.querySelectorAll('tr:not(#loadingRow):not(#errorRow):not(#noDataRow)').forEach(row => row.remove());
        displayedPostRowsCount = 0; // Resetea contador de filas de puestos
        // Aplica filtro de checkbox a los datos ya ordenados
        const dataToDisplay = filterDataByCheckbox(data);

        // Si no hay datos para mostrar después del filtro
        if (dataToDisplay.length === 0) {
            if (filterPostsCheckbox.checked && data.length > 0) {
                 noDataRow.querySelector('td').textContent = 'Ningún trabajador con puestos asignados (con cantidad > 0) en este periodo.';
            } else {
                 noDataRow.querySelector('td').textContent = 'No se encontraron datos para el periodo seleccionado.';
            }
            noDataRow.classList.remove('hidden'); // Muestra mensaje "Sin datos"
            exportExcelBtn.disabled = true; // Deshabilita exportar
            return; // Termina la función
        }

        noDataRow.classList.add('hidden'); // Oculta mensaje "Sin datos"
        let workersWithVisiblePosts = 0; // Contador de trabajadores que se mostrarán

        // Itera sobre cada trabajador en los datos filtrados Y ORDENADOS
        dataToDisplay.forEach((worker) => {
            let totalQuantitySum = 0; // Suma de cantidades para este trabajador

            // Calcula la suma total de cantidades de los puestos del trabajador
            if (worker.operator_posts && worker.operator_posts.length > 0) {
                 totalQuantitySum = worker.operator_posts.reduce((sum, post) => {
                    const count = post.count ?? 0; // Obtiene cantidad del puesto (o 0 si es null/undefined)
                    return sum + (count > 0 ? count : 0); // Suma solo si la cantidad es mayor que 0
                }, 0);
            }

            // Esta comprobación es redundante si filterDataByCheckbox ya se aplicó,
            // pero la dejamos por seguridad.
            const hasVisiblePosts = worker.operator_posts && worker.operator_posts.some(post => (post.count ?? 0) > 0);
            if (filterPostsCheckbox.checked && !hasVisiblePosts) {
                return; // Saltar al siguiente trabajador
            }

            workersWithVisiblePosts++; // Incrementa contador de trabajadores mostrados

            // --- Crear fila del trabajador ---
            const workerRow = tableBody.insertRow();
            workerRow.classList.add('bg-blue-50', 'hover:bg-blue-100', 'transition-colors', 'duration-150', 'ease-in-out');
            // Celdas del trabajador
            workerRow.insertCell().textContent = worker.client_id ?? '-';
            workerRow.insertCell().textContent = worker.name ?? 'Sin Nombre';
            workerRow.insertCell().textContent = totalQuantitySum; // Muestra la suma calculada
            // Celdas vacías para alinear con las columnas de puesto
            workerRow.insertCell().textContent = ''; // Puesto
            workerRow.insertCell().textContent = ''; // Inicio Puesto
            workerRow.insertCell().textContent = ''; // Fin Puesto
            workerRow.insertCell().textContent = ''; // Cantidad
            workerRow.insertCell().textContent = ''; // Confeccion
            // Aplica estilos a las celdas de la fila del trabajador
            Array.from(workerRow.cells).forEach(cell => cell.classList.add('px-4', 'py-3', 'text-sm', 'font-medium', 'text-gray-900', 'whitespace-nowrap'));

            // --- Crear filas de los puestos (si existen y tienen cantidad > 0) ---
             if (worker.operator_posts && worker.operator_posts.length > 0) {
                 // Ordena los puestos de ESTE trabajador por fecha de creación para mostrar en orden cronológico
                 const sortedPosts = [...worker.operator_posts].sort((postA, postB) => {
                    const dateA = postA.created_at ? new Date(postA.created_at) : null;
                    const dateB = postB.created_at ? new Date(postB.created_at) : null;
                    if (dateA && dateB) return dateA - dateB;
                    if (dateA) return -1; // Pone los que tienen fecha antes
                    if (dateB) return 1;
                    return 0; // Si ninguno tiene fecha, mantiene orden relativo
                 });

                sortedPosts.forEach((post, index) => {
                    // Solo muestra la fila del puesto si su cantidad es mayor que 0
                    if ((post.count ?? 0) > 0) {
                        displayedPostRowsCount++; // Incrementa contador de filas de puestos mostradas
                        const postRow = tableBody.insertRow();
                        // Alterna color de fondo para las filas de puestos
                        postRow.classList.add(index % 2 === 0 ? 'bg-white' : 'bg-gray-50', 'hover:bg-gray-100', 'transition-colors', 'duration-150', 'ease-in-out');

                        // Celdas vacías para alinear con las columnas de trabajador
                        postRow.insertCell().textContent = ''; // Codigo Trabajador
                        postRow.insertCell().textContent = ''; // Nombre
                        postRow.insertCell().textContent = ''; // Unidades (Turno)

                        // *** CELDA PUESTO ***
                        const puestoCell = postRow.insertCell();
                        puestoCell.textContent = post.rfid_reading?.name ?? 'N/A';

                        // Celdas de Inicio y Fin Puesto (formateadas)
                        let startDate = '-';
                        if (post.created_at) { try { startDate = dateFormatter.format(new Date(post.created_at)); } catch (e) { console.error("Error formateando fecha inicio:", post.created_at, e); } }
                        let endDate = '-';
                        if (post.finish_at) { try { endDate = dateFormatter.format(new Date(post.finish_at)); } catch (e) { console.error("Error formateando fecha fin:", post.finish_at, e); } }
                        postRow.insertCell().textContent = startDate; // Inicio Puesto
                        postRow.insertCell().textContent = endDate;   // Fin Puesto

                        // Celdas de Cantidad y Confección
                        postRow.insertCell().textContent = post.count ?? 0; // Cantidad
                        postRow.insertCell().textContent = post.product_list?.name ?? 'N/A'; // Confeccion

                        // Aplica estilos a las celdas de la fila del puesto
                        Array.from(postRow.cells).forEach(cell => cell.classList.add('px-4', 'py-3', 'text-sm', 'text-gray-600', 'whitespace-nowrap'));
                        // Añade padding izquierdo a la primera celda de datos del puesto (Puesto) para indentar
                        postRow.cells[3].classList.add('pl-8'); // Indentar la celda de Puesto
                    }
                });
            }
        });

        // Comprobación final: si después de iterar, no se mostró ningún trabajador
        if (workersWithVisiblePosts === 0) {
             // Mensaje ajustado por si el filtro de checkbox está activo
             if (filterPostsCheckbox.checked) {
                 noDataRow.querySelector('td').textContent = 'Ningún trabajador cumple los criterios de filtro (con puestos y cantidad > 0).';
             } else {
                 noDataRow.querySelector('td').textContent = 'No se encontraron datos para el periodo seleccionado.';
             }
             noDataRow.classList.remove('hidden');
             exportExcelBtn.disabled = true;
        } else {
             exportExcelBtn.disabled = false; // Habilita exportar si hay datos visibles
        }
    }


    /**
     * Exporta los datos visibles a Excel.
     * Los datos ya estarán ordenados según el primer puesto del trabajador.
     * Incluye la columna renombrada 'Puesto'.
     * Calcula la suma de cantidades para la columna "Unidades Turno".
     */
    function exportToExcel() {
        // Obtiene los datos originales (ya ordenados por fetchData) y aplica el filtro del checkbox
        const dataFilteredByCheckbox = filterDataByCheckbox(originalWorkersData);

        // Verifica si hay datos después de filtrar por checkbox
        if (!dataFilteredByCheckbox || dataFilteredByCheckbox.length === 0) {
            alert("No hay datos que coincidan con el filtro de 'Mostrar solo con puestos' para exportar.");
            return;
        }

        const flattenedData = []; // Array para almacenar los datos aplanados para Excel

        // Itera sobre los trabajadores filtrados Y ORDENADOS
        dataFilteredByCheckbox.forEach(worker => {
            let totalQuantitySum = 0; // Suma para este trabajador

            // Calcula la suma total de cantidades > 0 ANTES de generar filas de Excel
            if (worker.operator_posts && worker.operator_posts.length > 0) {
                 totalQuantitySum = worker.operator_posts.reduce((sum, post) => {
                    const count = post.count ?? 0;
                    return sum + (count > 0 ? count : 0); // Suma solo cantidades > 0
                }, 0);
            }

            // Comprueba si el trabajador tiene al menos un puesto con cantidad > 0 (redundante si se filtró)
            const workerHasVisiblePosts = worker.operator_posts && worker.operator_posts.some(post => (post.count ?? 0) > 0);

            // Si el checkbox está activo y el trabajador no tiene puestos visibles, no lo incluimos en el Excel
            if (filterPostsCheckbox.checked && !workerHasVisiblePosts) {
                return; // Saltar al siguiente trabajador
            }

            // Procesa los puestos del trabajador si debe ser incluido
            if (worker.operator_posts && worker.operator_posts.length > 0) {
                 // Ordena los puestos también para el Excel por consistencia con la tabla
                 const sortedPostsExcel = [...worker.operator_posts].sort((postA, postB) => {
                    const dateA = postA.created_at ? new Date(postA.created_at) : null;
                    const dateB = postB.created_at ? new Date(postB.created_at) : null;
                    if (dateA && dateB) return dateA - dateB;
                    if (dateA) return -1;
                    if (dateB) return 1;
                    return 0;
                 });

                sortedPostsExcel.forEach(post => {
                    // Incluye en Excel solo los puestos con cantidad > 0
                    if ((post.count ?? 0) > 0) {
                        let startDateExcel = '-';
                        if (post.created_at) { try { startDateExcel = dateFormatter.format(new Date(post.created_at)); } catch (e) {} }
                        let endDateExcel = '-';
                        if (post.finish_at) { try { endDateExcel = dateFormatter.format(new Date(post.finish_at)); } catch (e) {} }

                        // Añade una fila al array de datos para Excel
                        flattenedData.push({
                            'Codigo Trabajador': worker.client_id ?? '-',
                            'Nombre Trabajador': worker.name ?? 'Sin Nombre',
                            'Unidades Turno': totalQuantitySum, // Usa la suma calculada
                            'Puesto': post.rfid_reading?.name ?? 'N/A',
                            'Inicio Puesto': startDateExcel,
                            'Fin Puesto': endDateExcel,
                            'Cantidad Puesto': post.count ?? 0,
                            'Confeccion': post.product_list?.name ?? 'N/A'
                        });
                    }
                });
             } else if (!filterPostsCheckbox.checked) {
                 // Opcional: Incluir trabajadores sin puestos si el filtro no está activo
                 // Actualmente se omite para consistencia con la tabla filtrada por count > 0
             }
        });

        // Si después de procesar, no hay filas de detalles de puestos para exportar
        if (flattenedData.length === 0) {
             alert("No hay detalles de puestos con cantidad mayor que 0 para exportar (según los filtros aplicados).");
             return;
        }

        // --- Creación del archivo Excel ---
        const worksheet = XLSX.utils.json_to_sheet(flattenedData);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "TrabajadoresDetalle");

        // Ajusta el ancho de las columnas automáticamente
        const colWidths = Object.keys(flattenedData[0]).map(key => {
            const maxContentWidth = flattenedData.reduce((w, r) => Math.max(w, (r[key]?.toString() ?? '').length), 0);
            const headerWidth = key.length;
            return { wch: Math.max(headerWidth, maxContentWidth) + 2 };
        });
        worksheet["!cols"] = colWidths;

        // Genera el nombre del archivo
        const selectedOptionText = dateRangeSelect.options[dateRangeSelect.selectedIndex].text;
        const fileNameDate = selectedOptionText.replace(/ /g, '_');
        const filterSuffix = filterPostsCheckbox.checked ? '_ConPuestos_SumaCant' : '_SumaCant';
        const fileName = `Informe_Trabajadores_${fileNameDate}${filterSuffix}.xlsx`;

        // Descarga el archivo Excel
        XLSX.writeFile(workbook, fileName);
    }

    /**
     * Activa la función de impresión del navegador.
     */
    function printTable() {
        window.print();
    }

    /**
     * Obtiene y ordena los datos de la API para el rango de fechas especificado.
     * Ordena los trabajadores por el nombre de su primer puesto activo (cantidad > 0).
     * @param {string} fromDate - Fecha de inicio (YYYY-MM-DD).
     * @param {string} toDate - Fecha de fin (YYYY-MM-DD, día siguiente al último deseado).
     */
    function fetchData(fromDate, toDate) {
        const apiUrl = `${apiBaseUrl}?from_date=${fromDate}&to_date=${toDate}`;

        loadingRow.classList.remove('hidden');
        errorRow.classList.add('hidden');
        noDataRow.classList.add('hidden');
        tableBody.querySelectorAll('tr:not(#loadingRow):not(#errorRow):not(#noDataRow)').forEach(row => row.remove());
        exportExcelBtn.disabled = true;
        originalWorkersData = [];

        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                     return response.text().then(text => {
                         throw new Error(`Error HTTP: ${response.status} - ${response.statusText}. Respuesta: ${text || '(sin cuerpo)'}`);
                     });
                }
                return response.json();
            })
            .then(apiResponse => {
                loadingRow.classList.add('hidden');
                if (apiResponse.success && Array.isArray(apiResponse.data)) {
                    originalWorkersData = apiResponse.data;

                    // *** INICIO: Lógica de Ordenación por Primer Puesto Activo ***
                    originalWorkersData.sort((workerA, workerB) => {
                        // Función auxiliar para encontrar el primer puesto activo
                        const findFirstActivePost = (worker) => {
                            if (!worker.operator_posts || worker.operator_posts.length === 0) {
                                return null; // No tiene puestos
                            }
                            // Filtra puestos activos (count > 0) y con fecha válida
                            const activePosts = worker.operator_posts
                                .filter(p => (p.count ?? 0) > 0 && p.created_at)
                                .map(p => ({ ...p, createdAtDate: new Date(p.created_at) })) // Añade fecha parseada
                                .filter(p => !isNaN(p.createdAtDate)); // Filtra fechas inválidas

                            if (activePosts.length === 0) {
                                return null; // No tiene puestos activos con fecha válida
                            }
                            // Ordena por fecha de creación ascendente
                            activePosts.sort((a, b) => a.createdAtDate - b.createdAtDate);
                            return activePosts[0]; // Devuelve el primero
                        };

                        const firstPostA = findFirstActivePost(workerA);
                        const firstPostB = findFirstActivePost(workerB);

                        const puestoNameA = firstPostA?.rfid_reading?.name ?? null;
                        const puestoNameB = firstPostB?.rfid_reading?.name ?? null;

                        // Lógica de comparación
                        if (puestoNameA && puestoNameB) {
                            // Ambos tienen primer puesto, compara nombres
                            const nameComparison = puestoNameA.localeCompare(puestoNameB);
                            if (nameComparison !== 0) return nameComparison;
                            // Si los nombres son iguales, ordena por nombre de trabajador
                            return (workerA.name ?? '').localeCompare(workerB.name ?? '');
                        } else if (puestoNameA) {
                            return -1; // A tiene puesto, B no -> A va primero
                        } else if (puestoNameB) {
                            return 1; // B tiene puesto, A no -> B va primero
                        } else {
                            // Ninguno tiene puesto activo, ordena por nombre de trabajador
                            return (workerA.name ?? '').localeCompare(workerB.name ?? '');
                        }
                    });
                    // *** FIN: Lógica de Ordenación ***

                    populateTable(originalWorkersData); // Rellena la tabla con los datos ordenados
                }
                else if (apiResponse.success && (!Array.isArray(apiResponse.data) || apiResponse.data.length === 0)) {
                    originalWorkersData = [];
                    populateTable(originalWorkersData);
                } else {
                    errorCell.textContent = `Error: Respuesta inesperada de la API. Mensaje: ${apiResponse.message || 'No especificado'}`;
                    errorRow.classList.remove('hidden');
                    exportExcelBtn.disabled = true;
                }
            })
            .catch(error => {
                console.error("Error detallado en fetch:", error);
                loadingRow.classList.add('hidden');
                errorCell.textContent = `Error al cargar datos: ${error.message}`;
                errorRow.classList.remove('hidden');
                exportExcelBtn.disabled = true;
            });
    }

    // --- Lógica Principal (Event Listeners e Inicialización) ---

    exportExcelBtn.disabled = true;
    exportExcelBtn.addEventListener('click', exportToExcel);
    printBtn.addEventListener('click', printTable);

    dateRangeSelect.addEventListener('change', (event) => {
        const selectedRange = event.target.value;
        const { from, to } = getDateRange(selectedRange);
        fetchData(from, to); // fetchData ahora ordena los datos
    });

    filterPostsCheckbox.addEventListener('change', () => {
        // Solo necesita repintar la tabla, los datos en originalWorkersData ya están ordenados
        populateTable(originalWorkersData);
    });

    function loadInitialData() {
         const initialRangeValue = dateRangeSelect.value;
         const { from, to } = getDateRange(initialRangeValue);
         fetchData(from, to); // Carga y ordena los datos iniciales
    }

    document.addEventListener('DOMContentLoaded', loadInitialData);

</script>

</body>
</html>
