<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configuración y Control RFID (Node.js)</title>
    <style>
        :root {
            --primary-color: #3b82f6; /* Azul principal */
            --primary-hover-color: #2563eb;
            --success-color: #10b981; /* Verde para éxito/set */
            --success-hover-color: #059669;
            --start-color: #22c55e; /* Verde más brillante para Start */
            --start-hover-color: #16a34a;
            --stop-color: #ef4444; /* Rojo para Stop/Error */
            --stop-hover-color: #dc2626;
            --status-color: #64748b; /* Gris para Status/Info */
            --status-hover-color: #475569;
            --warning-bg-color: #fef3c7;
            --warning-text-color: #92400e;
            --warning-border-color: #fcd34d;

            --text-primary: #1f2937;
            --text-secondary: #374151;
            --text-muted: #6b7280;
            --bg-color: #f0f2f5;
            --surface-color: #ffffff;
            --border-color: #d1d5db;
            --border-light-color: #e5e7eb;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --border-radius-md: 8px;
            --border-radius-lg: 12px;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0; 
            padding: 10px; 
            background-color: var(--bg-color); 
            color: var(--text-primary); 
            line-height: 1.6; 
        }
        .container { 
            width: 100%; 
            max-width: 1200px; 
            margin: 20px auto; 
            background-color: var(--surface-color); 
            padding: 20px 25px; 
            border-radius: var(--border-radius-lg); 
            box-shadow: var(--shadow-md);
            box-sizing: border-box;
        }
        h1 { 
            color: var(--text-primary); 
            text-align: center; 
            margin-top: 0;
            margin-bottom: 30px;
            font-size: 1.8em; 
            font-weight: 600;
        }
        h2 { 
            color: var(--text-primary); 
            text-align: left; 
            margin-top: 35px; 
            margin-bottom: 20px;
            font-size: 1.4em; 
            font-weight: 600;
            border-bottom: 2px solid var(--primary-color); 
            padding-bottom: 10px;
        }
        h3 { 
            font-size: 1.15em; 
            margin-top: 20px; 
            margin-bottom: 15px; 
            text-align: left;
            color: var(--text-secondary);
            font-weight: 600;
        }

        label { 
            display: block; 
            margin-top: 15px; 
            margin-bottom: 6px; 
            font-weight: 500; /* Ligeramente menos pesado */
            color: var(--text-secondary);  
            font-size: 0.9em;
        }
        .inline-label { 
             display: inline-block; margin-right: 8px; white-space: nowrap; margin-top:0; font-weight: normal;
        }
        input[type="number"], input[type="text"], input[type="password"] { 
            width: 100%; /* Ocupar todo el ancho del contenedor padre */
            padding: 9px 12px; 
            margin-bottom: 12px; 
            border: 1px solid var(--border-color); 
            border-radius: var(--border-radius-md); 
            box-sizing: border-box; 
            font-size: 0.95em;
            background-color: #f9fafb;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        input[type="number"]:focus, input[type="text"]:focus, input[type="password"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            outline: none;
            background-color: var(--surface-color);
        }
        .input-group { display: flex; align-items: center; margin-bottom: 12px;}
        .input-group label { margin-bottom: 0; margin-right: 10px; font-weight: normal; margin-top:0;}
        .input-group input[type="number"] { width: 100px; margin-bottom:0;}


        input[type="checkbox"] { 
            margin-right: 6px; 
            vertical-align: middle; 
            width: 18px; 
            height: 18px; 
            accent-color: var(--primary-color);
        }
        .checkbox-container { 
            display: flex;
            align-items: center;
            margin-top: 12px; 
            margin-bottom: 12px;
            padding: 5px 0;
        }
        .checkbox-container label.inline-label { margin-top:0; margin-bottom: 0; font-weight: 500;} 


        button { 
            padding: 9px 16px; 
            margin-top: 8px; 
            margin-bottom: 8px; 
            margin-left: 4px;
            margin-right: 4px; 
            border: none; 
            border-radius: var(--border-radius-md); 
            cursor: pointer; 
            font-size: 0.9em; 
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; 
            box-shadow: var(--shadow-sm);
        }
        button:hover {
            box-shadow: var(--shadow-md);
        }
        button:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        .btn-get { background-color: var(--primary-color); color: white; }
        .btn-get:hover { background-color: var(--primary-hover-color); }
        .btn-set-all, .btn-action { background-color: var(--success-color); color: white; } 
        .btn-set-all:hover, .btn-action:hover { background-color: var(--success-hover-color); }
        .btn-start { background-color: var(--start-color); color: white; } 
        .btn-start:hover { background-color: var(--start-hover-color); }
        .btn-stop { background-color: var(--stop-color); color: white; } 
        .btn-stop:hover { background-color: var(--stop-hover-color); }
        .btn-status { background-color: var(--status-color); color: white; } 
        .btn-status:hover { background-color: var(--status-hover-color); }

        #statusMessages { 
            margin-top: 15px; 
            margin-bottom: 25px; 
            padding: 12px 15px; 
            border-radius: var(--border-radius-md); 
            text-align: center; 
            font-weight: 500;
            border: 1px solid transparent;
            font-size: 0.95em;
        }
        .status-success { background-color: #d1fae5; color: #065f46; border-color: #6ee7b7;}
        .status-error { background-color: #fee2e2; color: #991b1b; border-color: #fca5a5;}
        .status-info { background-color: #dbeafe; color: #1e40af; border-color: #93c5fd;}
        .status-warning { background-color: var(--warning-bg-color); color: var(--warning-text-color); border-color: var(--warning-border-color);}

        /* Reader Status Styles */
        #readerStatusDisplay {
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }
        
        .status-reading {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }
        
        .status-stopped {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }
        
        .status-error {
            background-color: #fff3cd;
            color: #856404;
            border-color: #ffeeba;
        }
        
        .status-connecting {
            background-color: #e2e3e5;
            color: #383d41;
            border-color: #d6d8db;
        }
        
        .section-group {
            margin-bottom: 35px; 
            padding: 20px;
            border-radius: var(--border-radius-lg);
            background-color: var(--surface-color); /* Fondo blanco para cada sección */
            box-shadow: var(--shadow-md); 
        }
        .section-group:last-child {
            margin-bottom: 10px; /* Menos margen para el último grupo */
        }

        #antennaDataContainer { 
            margin-top: 15px; 
            padding-top: 0; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 18px; 
        }
        .antenna-block { 
            border: 1px solid var(--border-light-color); 
            padding: 18px; 
            border-radius: var(--border-radius-md); 
            background-color: #f9fafb; 
            display: flex; 
            flex-direction: column; 
            box-shadow: var(--shadow-sm);
            flex-basis: calc(50% - 18px); /* Dos columnas, ajustado por el gap */
            box-sizing: border-box;
            min-width: 270px; /* Ancho mínimo antes de envolver */
        }
        .antenna-block h3 { 
            margin-top: 0; 
            margin-bottom: 15px; 
            color: var(--text-primary); 
            font-size: 1.1em; 
            text-align: left; /* Alineado a la izquierda para consistencia */
            border-bottom: 1px solid var(--border-light-color);
            padding-bottom: 8px;
        }
        .antenna-controls-row { 
            display: flex;
            align-items: center; 
            flex-wrap: wrap; 
            gap: 10px; 
        }
        .antenna-controls-row label.inline-label { margin-top: 0; font-size: 0.9em; } 
        .antenna-controls-row input[type="number"] { width: 70px; } /* Más pequeño para potencia */

        #readerStatusDisplay { 
            font-weight: 600; /* Más destacado */
            padding: 10px 15px;
            border-radius: var(--border-radius-md);
            text-align: center;
            margin-bottom: 20px;
            font-size: 1em;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        /* Clases específicas para estado del lector */
        #readerStatusDisplay.status-reading { background-color: var(--success-color); color: white; }
        #readerStatusDisplay.status-not-reading { background-color: var(--status-color); color: white; }
        /* Clases específicas para estado del lector */

        :root {
            --primary-color: #4361ee;
            --secondary-color: #3f37c9;
            --success-color: #4cc9f0;
            --danger-color: #f72585;
            --warning-color: #f8961e;
            --info-color: #4895ef;
            --light-color: #f8f9fa;
            --dark-color: #212529;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f0f2f5;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 15px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1.5rem;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            box-shadow: var(--box-shadow);
        }

        h1 {
            font-size: 2rem;
            margin: 0;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .section-group {
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: var(--transition);
            border-left: 4px solid var(--primary-color);
        }

        .section-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: var(--primary-color);
            font-size: 1.4rem;
            margin-bottom: 1.2rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        h2 i {
            font-size: 1.2em;
        }

        h3 {
            color: #555;
            font-size: 1.1rem;
            margin: 1.2rem 0 0.8rem;
        }

        .status-info {
            padding: 0.8rem 1rem;
            margin: 0.8rem 0;
            border-radius: var(--border-radius);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-success {
            background-color: rgba(76, 201, 240, 0.1);
            color: #0d6efd;
            border-left: 4px solid var(--success-color);
        }

        .status-error {
            background-color: rgba(247, 37, 133, 0.1);
            color: #dc3545;
            border-left: 4px solid var(--danger-color);
        }

        .status-warning {
            background-color: rgba(248, 150, 30, 0.1);
            color: #ffc107;
            border-left: 4px solid var(--warning-color);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        button {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-start { 
            background-color: var(--success-color);
            color: white;
        }

        .btn-stop { 
            background-color: var(--danger-color);
            color: white;
        }

        .btn-status { 
            background-color: var(--info-color);
            color: white;
        }

        .btn-get { 
            background-color: #6c757d;
            color: white;
        }

        .btn-set-all { 
            background-color: var(--primary-color);
            color: white;
        }

        .btn-action {
            background-color: var(--secondary-color);
            color: white;
            padding: 0.7rem 1.5rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 1.2rem;
        }

        label {
            display: block;
            margin-bottom: 0.4rem;
            font-weight: 500;
            color: #555;
            font-size: 0.9rem;
        }

        input[type="text"],
        input[type="number"],
        input[type="password"],
        select {
            width: 100%;
            padding: 0.7rem 1rem;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 0.95rem;
            transition: var(--transition);
        }

        input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(67, 97, 238, 0.25);
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.2rem;
            margin: 1.5rem 0;
        }

        .antenna-controls-row {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.8rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: var(--border-radius);
            transition: var(--transition);
        }

        .antenna-controls-row:hover {
            background-color: #f1f3f5;
        }

        .inline-label {
            display: inline;
            margin: 0 0.5rem 0 0;
            font-weight: normal;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.5rem 0;
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 0.5rem;
        }

        .hidden {
            display: none;
        }

        #rawResponseContainer {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: var(--border-radius);
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            margin-top: 1rem;
        }

        .status-reading {
            background-color: rgba(13, 110, 253, 0.1);
            color: #0d6efd;
            border-left: 4px solid #0d6efd;
        }

        .status-not-reading {
            background-color: #f8f9fa;
            border-left: 4px solid #6c757d;
        }

        /* Sección de Auto Monitor */
        /* Estilos para la sección Auto Monitor */
        .auto-monitor-section {
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            padding: 1.5rem;
            border-radius: var(--border-radius-lg);
            margin: 2rem 0;
            border: 1px solid #bae6fd;
            box-shadow: 0 4px 6px -1px rgba(14, 165, 233, 0.1), 0 2px 4px -1px rgba(14, 165, 233, 0.06);
        }

        .auto-monitor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .auto-monitor-header h2 {
            margin: 0;
            color: #0369a1;
            font-size: 1.4em;
            border: none;
            padding: 0;
        }

        .auto-monitor-description {
            color: #4b5563;
            font-size: 0.9em;
            margin: 0.5rem 0 0 0;
            line-height: 1.5;
        }

        /* Estilo para el toggle switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #0ea5e9;
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #0ea5e9;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .auto-monitor-toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .auto-monitor-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--success-color);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--success-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .form-grid {
                grid-template-columns: 1fr;
            }

            .antenna-controls-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .antenna-controls-row label.inline-label,
            .antenna-controls-row .checkbox-container {
                width: 100%;
                margin-bottom: 0.5rem;
            }

            .antenna-controls-row input[type="number"] {
                width: 100%;
            }

            .container {
                padding: 0 10px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 0;
            }

            .section-group {
                padding: 1rem;
                margin: 0.5rem 0;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.2rem;
            }

            h3 {
                font-size: 1rem;
            }

            button {
                padding: 0.5rem 0.8rem;
                font-size: 0.85rem;
            }
        }

        /* Animaciones */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .section-group {
            animation: fadeIn 0.3s ease-out forwards;
        }

        /* Scrollbar personalizada */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Configuración y Control RFID</h1>
        <div id="statusMessages" class="status-info">Conectando al servidor...</div>

        <div class="section-group">
            <h2>Estado y Control de Lectura RFID</h2>
            <div id="readerStatusDisplay" class="status-info">Consultando estado del lector...</div>
            <div class="button-group">
                <button id="rfidStartBtn" class="btn-start">Iniciar Lectura</button>
                <button id="rfidStopBtn" class="btn-stop">Detener Lectura</button>
                <button id="rfidStatusBtn" class="btn-status">Actualizar Estado Lector</button>
            </div>
        </div>

        <div class="section-group">
            <h2>Configuración de Antena</h2>
            <div class="button-group">
                <button id="getPowerBtn" class="btn-get">Obtener Config. Antena</button>
                <button id="setPowerBtn" class="btn-set-all">Establecer Config. Antena</button>

            </div>
            <div id="antennaDataContainer">
                </div>
        </div>

        <!-- Sección Auto Monitor -->
        <div class="section-group auto-monitor-section">
            <div class="auto-monitor-header">
                <h2>Auto Monitor</h2>
                <label class="switch">
                    <input type="checkbox" id="autoMonitorToggle" checked>
                    <span class="slider round"></span>
                </label>
            </div>
            <p class="auto-monitor-description">Activa/desactiva la actualización automática de la lectura de tags en la interfaz. El servicio de lectura continúa ejecutándose en el servidor.</p>
        </div>

        <!-- Sección Configuración MQTT -->
        <div class="section-group">
            <h2>Configuración Tarea MQTT del Lector</h2>
            <div class="button-group">
                <button id="getReaderMqttSettingsBtn" class="btn-get">Obtener Config. Tarea MQTT</button>
            </div>
            <form id="readerMqttConfigForm">
                <div class="form-group checkbox-container">
                    <input type="checkbox" id="readerMqttEnable">
                    <label for="readerMqttEnable" class="inline-label">Habilitar Tarea MQTT del Lector</label>
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="readerMqttHost">Host MQTT Lector:</label>
                        <input type="text" id="readerMqttHost" placeholder="Ej: 192.168.123.1">
                    </div>
                    <div class="form-group">
                        <label for="readerMqttPort">Puerto MQTT Lector:</label>
                        <input type="number" id="readerMqttPort" placeholder="Ej: 1883">
                    </div>
                    <div class="form-group">
                        <label for="readerMqttTopic">Topic Principal Lector:</label>
                        <input type="text" id="readerMqttTopic" placeholder="Ej: rfid1">
                    </div>
                    <div class="form-group">
                        <label for="readerMqttTopicCmd">Topic Comandos Lector:</label>
                        <input type="text" id="readerMqttTopicCmd" placeholder="Ej: rfid_comm">
                    </div>
                     <div class="form-group input-group">
                        <label for="readerMqttQos" class="inline-label">QoS (0,1,2):</label>
                        <input type="number" id="readerMqttQos" min="0" max="2" value="1">
                    </div>
                    <div class="form-group input-group">
                        <label for="readerMqttSsl" class="inline-label">Usar SSL (0=No, 1=Sí):</label>
                        <input type="number" id="readerMqttSsl" min="0" max="1" value="0">
                    </div>
                     <div class="form-group">
                        <label for="readerMqttUser">Usuario Lector (UID):</label>
                        <input type="text" id="readerMqttUser" placeholder="Opcional">
                    </div>
                    <div class="form-group">
                        <label for="readerMqttPass">Password Lector:</label>
                        <input type="password" id="readerMqttPass" placeholder="Opcional">
                    </div>
                    <div class="form-group">
                        <label for="readerMqttCaCrt">CA Cert (nombre archivo):</label>
                        <input type="text" id="readerMqttCaCrt" placeholder="Ej: ca.crt">
                    </div>
                    <div class="form-group">
                        <label for="readerMqttClientCrt">Client Cert (nombre archivo):</label>
                        <input type="text" id="readerMqttClientCrt" placeholder="Ej: client.crt">
                    </div>
                     <div class="form-group">
                        <label for="readerMqttClientKey">Client Key (nombre archivo):</label>
                        <input type="text" id="readerMqttClientKey" placeholder="Ej: client.key">
                    </div>
                     <div class="form-group">
                        <label for="readerMqttClientPwd">Client Cert Password:</label>
                        <input type="password" id="readerMqttClientPwd" placeholder="Opcional">
                    </div>
                    <div class="form-group input-group">
                        <label for="readerMqttInterval" class="inline-label">Intervalo (ms):</label>
                        <input type="number" id="readerMqttInterval" placeholder="Ej: 10">
                    </div>
                    <div class="form-group input-group">
                        <label for="readerMqttMask" class="inline-label">Mask (decimal):</label>
                        <input type="number" id="readerMqttMask" placeholder="Ej: 3303">
                    </div>
                     <div class="form-group input-group">
                        <label for="readerMqttMaxTags" class="inline-label">Max Tags:</label>
                        <input type="number" id="readerMqttMaxTags" placeholder="Ej: 999">
                    </div>
                     <div class="form-group checkbox-container">
                        <input type="checkbox" id="readerMqttCacheTags">
                        <label for="readerMqttCacheTags" class="inline-label">Cache Tags</label>
                    </div>
                    <div class="form-group checkbox-container">
                        <input type="checkbox" id="readerMqttMergeTags">
                        <label for="readerMqttMergeTags" class="inline-label">Merge Tags</label>
                    </div>
                     <div class="form-group">
                        <label for="readerMqttPath">Path (SSL):</label>
                        <input type="text" id="readerMqttPath" placeholder="Ej: SmartReader">
                    </div>
                </div>
                <div style="text-align: center;"> 
                    <button type="button" id="setReaderMqttSettingsBtn" class="btn-action">Establecer Config. Tarea MQTT</button>
                </div>
            </form>
        </div>
        
        <h3>Respuesta Cruda del Servidor (para depuración):</h3>
        <div id="rawResponseContainer" class="hidden"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const socket = io({
                reconnectionAttempts: 5,
                reconnectionDelay: 3000
            });

            const getPowerBtn = document.getElementById('getPowerBtn');
            const setAllPowerBtn = document.getElementById('setAllPowerBtn');
            const rfidStartBtn = document.getElementById('rfidStartBtn'); 
            const rfidStopBtn = document.getElementById('rfidStopBtn');   
            const rfidStatusBtn = document.getElementById('rfidStatusBtn'); 
            const statusMessagesDiv = document.getElementById('statusMessages');
            const antennaDataContainer = document.getElementById('antennaDataContainer');
            const rawResponseContainer = document.getElementById('rawResponseContainer');
            const readerStatusDisplay = document.getElementById('readerStatusDisplay');

            const getReaderMqttSettingsBtn = document.getElementById('getReaderMqttSettingsBtn');
            const setReaderMqttSettingsBtn = document.getElementById('setReaderMqttSettingsBtn');
            const readerMqttConfigForm = document.getElementById('readerMqttConfigForm');

            const readerMqttEnableCheckbox = document.getElementById('readerMqttEnable');
            const readerMqttHostInput = document.getElementById('readerMqttHost');
            const readerMqttPortInput = document.getElementById('readerMqttPort');
            const readerMqttTopicInput = document.getElementById('readerMqttTopic');
            const readerMqttTopicCmdInput = document.getElementById('readerMqttTopicCmd');
            const readerMqttQosInput = document.getElementById('readerMqttQos');
            const readerMqttSslInput = document.getElementById('readerMqttSsl');
            const readerMqttUserInput = document.getElementById('readerMqttUser'); 
            const readerMqttPassInput = document.getElementById('readerMqttPass'); 
            const readerMqttCaCrtInput = document.getElementById('readerMqttCaCrt');
            const readerMqttClientCrtInput = document.getElementById('readerMqttClientCrt');
            const readerMqttClientKeyInput = document.getElementById('readerMqttClientKey');
            const readerMqttClientPwdInput = document.getElementById('readerMqttClientPwd'); 
            const readerMqttIntervalInput = document.getElementById('readerMqttInterval');
            const readerMqttMaskInput = document.getElementById('readerMqttMask');
            const readerMqttMaxTagsInput = document.getElementById('readerMqttMaxTags');
            const readerMqttCacheTagsCheckbox = document.getElementById('readerMqttCacheTags');
            const readerMqttMergeTagsCheckbox = document.getElementById('readerMqttMergeTags');
            const readerMqttPathInput = document.getElementById('readerMqttPath');

            let originalReaderMqttParams = {}; 
            let originalReaderMqttName = "task.name.const.mqtt"; 

            function displayStatus(message, type = 'info') {
                statusMessagesDiv.textContent = message;
                statusMessagesDiv.className = `status-${type}`;
            }

            function displayRawResponse(data) {
                rawResponseContainer.textContent = JSON.stringify(data, null, 2);
                rawResponseContainer.classList.remove('hidden');
            }

            if (getPowerBtn) {
                getPowerBtn.addEventListener('click', () => {
                    displayStatus('Solicitando configuración de antenas...', 'info');
                    rawResponseContainer.classList.add('hidden');
                    if (socket.connected) socket.emit('getAntennaPower');
                    else displayStatus('No conectado al servidor.', 'error');
                });
            }

            // Manejador para el botón Establecer Config. Antena
            const setPowerBtn = document.getElementById('setPowerBtn');
            if (setPowerBtn) {
                setPowerBtn.addEventListener('click', () => {
                    const antennaBlocks = document.querySelectorAll('.antenna-block');
                    const allAntennaConfigs = [];
                    let isValid = true;

                    antennaBlocks.forEach(block => {
                        const index = parseInt(block.dataset.antennaIndex);
                        const powerInput = document.getElementById(`power_${index}`);
                        const enableCheckbox = document.getElementById(`enable_${index}`);
                        
                        if (!powerInput || !enableCheckbox) {
                            displayStatus(`Error: No se pudo encontrar la configuración de la antena ${index}`, 'error');
                            isValid = false;
                            return;
                        }
                        
                        const power = parseInt(powerInput.value);
                        const enable = enableCheckbox.checked;
                        
                        if (isNaN(power) || power < 0 || power > 35) {
                            displayStatus(`Potencia para Antena ${index} inválida (0-35).`, 'error');
                            powerInput.focus();
                            isValid = false;
                            return;
                        }
                        allAntennaConfigs.push({ index, power, enable });
                    });

                    if (!isValid || allAntennaConfigs.length === 0) {
                        displayStatus('Configuración de antenas inválida.', 'error');
                        return;
                    }

                    if (socket.connected) {
                        displayStatus(`Enviando configuración para ${allAntennaConfigs.length} antena(s)...`, 'info');
                        rawResponseContainer.classList.add('hidden');
                        socket.emit('setAntennaPower', allAntennaConfigs);
                    } else {
                        displayStatus('No conectado al servidor.', 'error');
                    }
                });
            }

            if (setAllPowerBtn) {
                setAllPowerBtn.addEventListener('click', () => {
                    const antennaBlocks = antennaDataContainer?.querySelectorAll('.antenna-block');
                    if (!antennaBlocks || antennaBlocks.length === 0) {
                        displayStatus('No hay antenas cargadas para configurar.', 'warning');
                        return;
                    }

                    const allAntennaConfigs = [];
                    let isValid = true;

                    antennaBlocks.forEach(block => {
                        const index = parseInt(block.getAttribute('data-antenna-index'));
                        const powerInput = block.querySelector(`#power_${index}`);
                        const enableCheckbox = block.querySelector(`#enable_${index}`);
                        if (!powerInput || !enableCheckbox) { isValid = false; return; }
                        const power = parseInt(powerInput.value);
                        const enable = enableCheckbox.checked;
                        if (isNaN(power) || power < 0 || power > 35) {
                            displayStatus(`Potencia para Antena ${index} inválida (0-35).`, 'error');
                            powerInput.focus(); isValid = false; return; 
                        }
                        allAntennaConfigs.push({ index, power, enable });
                    });
                    if (!isValid || allAntennaConfigs.length === 0) return;
                    if (socket.connected) {
                        displayStatus(`Enviando config. para ${allAntennaConfigs.length} antena(s)...`, 'info');
                        rawResponseContainer.classList.add('hidden');
                        socket.emit('setAntennaPower', allAntennaConfigs); 
                    } else displayStatus('No conectado al servidor.', 'error');
                });
            }

            rfidStartBtn.addEventListener('click', () => {
                displayStatus('Enviando Iniciar Lectura...', 'info');
                rawResponseContainer.classList.add('hidden');
                const antennaBlocks = antennaDataContainer.querySelectorAll('.antenna-block');
                let antsToUse = [];
                if (antennaBlocks.length > 0) {
                    antennaBlocks.forEach(block => {
                        const index = parseInt(block.getAttribute('data-antenna-index'));
                        const enableCheckbox = block.querySelector(`#enable_${index}`);
                        if (enableCheckbox && enableCheckbox.checked) antsToUse.push(index);
                    });
                }
                if (antsToUse.length === 0) {
                    displayStatus('Advertencia: No hay antenas habilitadas. Iniciando con antena 1 por defecto.', 'warning');
                    antsToUse = [1]; 
                }
                const payload = {"command": "RFID/start", "data": {"area": 3, "ants": antsToUse, "userOffset": 0, "userLength": 4, "once": false}};
                if (socket.connected) socket.emit('rfidStart', payload);
                else displayStatus('No conectado al servidor.', 'error');
            });

            rfidStopBtn.addEventListener('click', () => {
                displayStatus('Enviando Detener Lectura...', 'info');
                rawResponseContainer.classList.add('hidden');
                if (socket.connected) socket.emit('rfidStop', { "command": "RFID/stop" });
                else displayStatus('No conectado al servidor.', 'error');
            });

            rfidStatusBtn.addEventListener('click', () => {
                displayStatus('Consultando estado del lector...', 'info');
                rawResponseContainer.classList.add('hidden');
                if (socket.connected) socket.emit('rfidStatus', { "command": "RFID/status" });
                else displayStatus('No conectado al servidor.', 'error');
            });

            function createAntennaControlBlock(antenna) {
                const block = document.createElement('div');
                block.className = 'antenna-block';
                block.setAttribute('data-antenna-index', antenna.index); 
                block.innerHTML = `
                    <h3>Antena ${antenna.index}</h3>
                    <div class="antenna-controls-row">
                        <label for="power_${antenna.index}" class="inline-label">Potencia:</label>
                        <input type="number" id="power_${antenna.index}" value="${antenna.power}" min="0" max="35" title="Potencia (0-35 dBm)">
                        <div class="checkbox-container">
                            <input type="checkbox" id="enable_${antenna.index}" ${antenna.enable ? 'checked' : ''}>
                            <label for="enable_${antenna.index}" class="inline-label">Habilitada</label>
                        </div>
                    </div>`;
                return block;
            }

            getReaderMqttSettingsBtn.addEventListener('click', () => {
                displayStatus('Obteniendo config. MQTT del lector...', 'info');
                rawResponseContainer.classList.add('hidden');
                if (socket.connected) socket.emit('getReaderMqttSettings');
                else displayStatus('No conectado al servidor.', 'error');
            });

            setReaderMqttSettingsBtn.addEventListener('click', () => {
                displayStatus('Enviando config. MQTT al lector...', 'info');
                rawResponseContainer.classList.add('hidden');

                const updatedParams = { ...originalReaderMqttParams }; 

                updatedParams.host = readerMqttHostInput.value;
                updatedParams.port = parseInt(readerMqttPortInput.value) || 1883; 
                updatedParams.topic = readerMqttTopicInput.value;
                updatedParams.topic_cmd = readerMqttTopicCmdInput.value;
                updatedParams.qos = parseInt(readerMqttQosInput.value);
                updatedParams.ssl = parseInt(readerMqttSslInput.value);
                updatedParams.uid = readerMqttUserInput.value; 
                updatedParams.pwd = readerMqttPassInput.value;
                updatedParams.ca_crt = readerMqttCaCrtInput.value;
                updatedParams.client_crt = readerMqttClientCrtInput.value;
                updatedParams.client_key = readerMqttClientKeyInput.value;
                updatedParams.client_pwd = readerMqttClientPwdInput.value;
                updatedParams.interval = parseInt(readerMqttIntervalInput.value);
                updatedParams.mask = parseInt(readerMqttMaskInput.value);
                updatedParams.maxtags = parseInt(readerMqttMaxTagsInput.value);
                updatedParams.cachetags = readerMqttCacheTagsCheckbox.checked;
                updatedParams.mergetags = readerMqttMergeTagsCheckbox.checked;
                updatedParams.path = readerMqttPathInput.value;

                const settingsPayload = {
                    enable: readerMqttEnableCheckbox.checked,
                    name: originalReaderMqttName, 
                    param: updatedParams
                };

                if (socket.connected) socket.emit('setReaderMqttSettings', settingsPayload);
                else displayStatus('No conectado al servidor.', 'error');
            });

            socket.on('connect', () => {
                displayStatus('Conectado al servidor de control RFID.', 'success');
                console.log("Conectado al servidor Node.js vía Socket.IO. ID:", socket.id);
                socket.emit('rfidStatus');
                socket.emit('getAntennaPower');
                socket.emit('getReaderMqttSettings');
            });

            socket.on('connect_error', (err) => {
                displayStatus(`Error de conexión: ${err.message}. Verifica Node.js.`, 'error');
                console.error(`Error de conexión Socket.IO:`, err);
            });

            socket.on('disconnect', (reason) => {
                displayStatus(`Desconectado: ${reason}. Reintentando...`, 'warning');
                console.warn(`Socket.IO desconectado: ${reason}`);
            });
        
            socket.on('appStatus', (data) => {
                console.info('AppStatus:', data.message);
                if (data.message.includes("Comando") || data.message.includes("conectado") || data.message.includes("Broker") || data.message.includes("Enviando")) {
                     displayStatus(data.message, 'info');
                }
            });

            socket.on('antennaPowerData', (response) => {
                console.log('antennaPowerData:', response);
                displayRawResponse(response);
                antennaDataContainer.innerHTML = ''; 
                if (response.resultCode === 0 && Array.isArray(response.resultData)) {
                    displayStatus('Configuración de antenas recibida.', 'success');
                    if (response.resultData.length === 0) {
                        antennaDataContainer.innerHTML = '<p>No se devolvieron datos para ninguna antena.</p>';
                    } else {
                        response.resultData.forEach((antenna) => {
                            antennaDataContainer.appendChild(createAntennaControlBlock(antenna));
                        });
                    }
                } else {
                    displayStatus(`Error obteniendo config. antenas: ${response.resultMsg || 'Respuesta inválida.'}`, 'error');
                }
            });

            socket.on('antennaSetPowerStatus', (response) => { 
                console.log('antennaSetPowerStatus:', response);
                displayRawResponse(response.data || response);
                if (response.success && response.data && response.data.resultCode === 0) {
                    displayStatus(response.data.resultMsg || 'Configuración de antenas establecida.', 'success');
                    setTimeout(() => socket.emit('getAntennaPower'), 1200); 
                } else {
                    const errorMsg = (response.data && response.data.resultMsg) ? response.data.resultMsg : (response.message || 'Error desconocido.');
                    displayStatus(`Error al configurar antenas: ${errorMsg}`, 'error');
                }
            });

            socket.on('rfidInfo', (response) => { 
                console.log('rfidInfo:', response);
                displayRawResponse(response);
                
                const readerStatusDisplay = document.getElementById('readerStatusDisplay');
                
                if (response.status === 'error') {
                    const errorMsg = response.details || response.message || 'Error desconocido';
                    displayStatus(`Error: ${errorMsg}`, 'error');
                    if (readerStatusDisplay) {
                        readerStatusDisplay.textContent = `ERROR: ${errorMsg}`;
                        readerStatusDisplay.className = 'status-error';
                    }
                } else {
                     displayStatus(`Respuesta RFID inesperada: ${response.resultMsg || JSON.stringify(response)}`, 'warning');
                }
            });

            socket.on('rfidStatus', (response) => {
                console.log('rfidStatus:', response);
                displayRawResponse(response);
                
                const readerStatusDisplay = document.getElementById('readerStatusDisplay');
                const startBtn = document.getElementById('rfidStartBtn');
                const stopBtn = document.getElementById('rfidStopBtn');
                
                if (response.status === 'error' || response.success === false) {
                    const errorMsg = response.details || response.message || 'Error desconocido';
                    displayStatus(`Error: ${errorMsg}`, 'error');
                    if (readerStatusDisplay) {
                        readerStatusDisplay.textContent = 'ERROR';
                        readerStatusDisplay.className = 'status-error';
                    }
                    if (startBtn) startBtn.disabled = false;
                    if (stopBtn) stopBtn.disabled = false;
                    
                    // Si el estado es de error, intentar actualizar el estado del lector automáticamente
                    if (socket.connected) {
                        console.log('Estado de error detectado, actualizando estado del lector...');
                        socket.emit('rfidStatus', { command: 'RFID/status' });
                    }
                    return;
                }
                
                // Determine reading state - check multiple possible properties for backward compatibility
                const isReading = response.isReading === true || response.status === 'reading' || response.readerStatus === 'LEYENDO';
                const readerStatus = response.readerStatus || (isReading ? 'LEYENDO' : 'DETENIDO');
                const statusMessage = response.message || (isReading ? 'Leyendo etiquetas' : 'Lector detenido');
                
                // Update status display
                if (readerStatusDisplay) {
                    // Use the status directly from the response or fallback to isReading
                    const displayStatusText = response.readerStatus || (isReading ? 'LEYENDO' : 'DETENIDO');
                    readerStatusDisplay.textContent = displayStatusText;
                    readerStatusDisplay.className = isReading ? 'status-reading' : 'status-stopped';
                    
                    // Update status message if available
                    if (statusMessage) {
                        displayStatus(statusMessage, isReading ? 'success' : 'info');
                    }
                    
                    console.log('Updated reader status:', {
                        displayStatus: displayStatusText,
                        isReading: isReading,
                        response: response
                    });
                }
                
                // Update button states
                if (startBtn) startBtn.disabled = isReading;
                if (stopBtn) stopBtn.disabled = !isReading;
                
                // Only show status message if it's not from auto-refresh
                if (response.autoRefresh !== true) {
                    displayStatus(`Estado del lector: ${readerStatus}`, 'success');
                }
            });

            socket.on('readerMqttSettingsData', (response) => {
                console.log('ReaderMqttSettingsData:', response);
                displayRawResponse(response);
                
                // Mostrar el formulario independientemente del resultado
                readerMqttConfigForm.classList.remove('hidden');
                
                if (response.resultCode === 0) {
                    displayStatus('Configuración MQTT del lector recibida.', 'success');
                    
                    // Si hay datos en resultData.param, usarlos
                    if (response.resultData && response.resultData.param) {
                        const data = response.resultData;
                        const params = data.param;
                        
                        originalReaderMqttParams = { ...params }; 
                        originalReaderMqttName = data.name || "task.name.const.mqtt";
                        
                        readerMqttEnableCheckbox.checked = data.enable !== undefined ? data.enable : false;
                        readerMqttHostInput.value = params.host || '';
                        readerMqttPortInput.value = params.port || 1883;
                        readerMqttTopicInput.value = params.topic || '';
                        readerMqttTopicCmdInput.value = params.topic_cmd || '';
                        readerMqttQosInput.value = typeof params.qos !== 'undefined' ? params.qos : 1;
                        readerMqttSslInput.value = typeof params.ssl !== 'undefined' ? params.ssl : 0;
                        readerMqttUserInput.value = params.uid || params.username || ''; 
                        readerMqttPassInput.value = params.pwd || params.password || '';
                        readerMqttCaCrtInput.value = params.ca_crt || '';
                        readerMqttClientCrtInput.value = params.client_crt || '';
                        readerMqttClientKeyInput.value = params.client_key || '';
                        readerMqttClientPwdInput.value = params.client_pwd || '';
                        readerMqttIntervalInput.value = typeof params.interval !== 'undefined' ? params.interval : 10;
                        readerMqttMaskInput.value = typeof params.mask !== 'undefined' ? params.mask : 0;
                        readerMqttMaxTagsInput.value = typeof params.maxtags !== 'undefined' ? params.maxtags : 999;
                        readerMqttCacheTagsCheckbox.checked = typeof params.cachetags === 'boolean' ? params.cachetags : false;
                        readerMqttMergeTagsCheckbox.checked = typeof params.mergetags === 'boolean' ? params.mergetags : false;
                        readerMqttPathInput.value = params.path || '';
                    } 
                    // Si los datos vienen directamente en resultData
                    else if (response.resultData) {
                        const data = response.resultData;
                        
                        originalReaderMqttParams = { ...data };
                        
                        readerMqttEnableCheckbox.checked = data.enable !== undefined ? data.enable : false;
                        readerMqttHostInput.value = data.server || data.host || '';
                        readerMqttPortInput.value = data.port || 1883;
                        readerMqttTopicInput.value = data.topic || '';
                        readerMqttTopicCmdInput.value = data.topic_cmd || '';
                        readerMqttQosInput.value = typeof data.qos !== 'undefined' ? data.qos : 1;
                        readerMqttSslInput.value = typeof data.ssl !== 'undefined' ? data.ssl : 0;
                        readerMqttUserInput.value = data.username || data.uid || '';
                        readerMqttPassInput.value = data.password || data.pwd || '';
                        readerMqttCaCrtInput.value = data.ca_crt || '';
                        readerMqttClientCrtInput.value = data.client_crt || '';
                        readerMqttClientKeyInput.value = data.client_key || '';
                        readerMqttClientPwdInput.value = data.client_pwd || '';
                        readerMqttIntervalInput.value = typeof data.interval !== 'undefined' ? data.interval : 10;
                        readerMqttMaskInput.value = typeof data.mask !== 'undefined' ? data.mask : 0;
                        readerMqttMaxTagsInput.value = typeof data.maxtags !== 'undefined' ? data.maxtags : 999;
                        readerMqttCacheTagsCheckbox.checked = typeof data.cachetags === 'boolean' ? data.cachetags : false;
                        readerMqttMergeTagsCheckbox.checked = typeof data.mergetags === 'boolean' ? data.mergetags : false;
                        readerMqttPathInput.value = data.path || '';
                    }
                } else {
                    displayStatus(`Error obteniendo config. MQTT del lector: ${response.resultMsg || 'Respuesta inválida.'}`, 'error');
                    // Mostrar el formulario de todos modos, pero con valores por defecto
                    readerMqttEnableCheckbox.checked = true;
                    readerMqttHostInput.value = process.env.MQTT_SENSORICA_SERVER || 'localhost';
                    readerMqttPortInput.value = process.env.MQTT_SENSORICA_PORT || 1883;
                    readerMqttTopicInput.value = process.env.MQTT_TOPIC || 'rfid_reader';
                    readerMqttTopicCmdInput.value = process.env.MQTT_TOPIC_CMD || 'rfid_comm';
                    readerMqttQosInput.value = 1;
                    readerMqttSslInput.value = 0;
                    readerMqttUserInput.value = process.env.MQTT_USERNAME || '';
                    readerMqttPassInput.value = process.env.MQTT_PASSWORD ? '********' : '';
                    readerMqttCaCrtInput.value = '';
                    readerMqttClientCrtInput.value = '';
                    readerMqttClientKeyInput.value = '';
                    readerMqttClientPwdInput.value = '';
                    readerMqttIntervalInput.value = 10;
                    readerMqttMaskInput.value = 0;
                    readerMqttMaxTagsInput.value = 999;
                    readerMqttCacheTagsCheckbox.checked = true;
                    readerMqttMergeTagsCheckbox.checked = true;
                    readerMqttPathInput.value = '';
                }
            });

            socket.on('readerMqttSettingsStatus', (response) => {
                console.log('ReaderMqttSettingsStatus:', response);
                displayRawResponse(response);
                if (response.resultCode === 0) {
                    displayStatus('Configuración MQTT del lector establecida exitosamente.', 'success');
                } else {
                    const errorMsg = response.resultMsg || 'Fallo desconocido.';
                    displayStatus('Error al establecer config. MQTT del lector: ' + errorMsg, 'error');
                }
            });

            socket.on('rfidError', (response) => {
                console.error('rfidError:', response);
                displayRawResponse(response);
                displayStatus(`Error del dispositivo RFID: ${response.resultMsg || JSON.stringify(response)}`, 'error');
            });

            socket.on('appError', (error) => {
                console.error('appError:', error);
                displayRawResponse(error);
                displayStatus(`Error en la aplicación: ${error.message}`, 'error');
            });
        
        socket.on('appWarning', (warning) => {
            console.warn('appWarning:', warning);
            displayRawResponse(warning);
        });

        // Inicialización al cargar la página
        setTimeout(function() {
            // Consultar estado del lector
            displayStatus('Consultando estado del lector...', 'info');
            rawResponseContainer.classList.add('hidden');
            if (socket.connected) {
                socket.emit('rfidStatus', { "command": "RFID/status" });
            } else {
                displayStatus('No conectado al servidor.', 'error');
            }

            // Obtener configuración MQTT después de un breve retraso
            setTimeout(function() {
                displayStatus('Obteniendo configuración MQTT del lector...', 'info');
                rawResponseContainer.classList.add('hidden');
                if (socket.connected) {
                    socket.emit('getReaderMqttSettings');
                } else {
                    displayStatus('No conectado al servidor Node.js.', 'error');
                }
            }, 1000);
        }, 1000);
        
        // Configuración del monitoreo automático
        const autoMonitorToggle = document.getElementById('autoMonitorToggle');
        
        // Función para actualizar la interfaz según el estado del monitoreo
        function updateAutoMonitorUI(enabled) {
            if (autoMonitorToggle) {
                autoMonitorToggle.checked = enabled;
                // Actualizar el estado visual del slider
                const slider = document.querySelector('.slider');
                if (slider) {
                    if (enabled) {
                        slider.style.backgroundColor = '#0ea5e9';
                    } else {
                        slider.style.backgroundColor = '#ccc';
                    }
                }
            }
            displayStatus(
                `Monitorización ${enabled ? 'ACTIVADA' : 'DESACTIVADA'} (el servicio continúa ejecutándose en el servidor)`,
                enabled ? 'success' : 'warning'
            );
            console.log(`Monitorización ${enabled ? 'activada' : 'desactivada'} en la interfaz`);
        }
        
        // Manejar cambios en el toggle
        if (autoMonitorToggle) {
            autoMonitorToggle.addEventListener('change', function() {
                if (socket.connected) {
                    socket.emit('toggleAutoMonitor', this.checked);
                } else {
                    displayStatus('No conectado al servidor Node.js', 'error');
                    this.checked = !this.checked; // Revertir el cambio
                }
            });
        }
        
        // Escuchar actualizaciones del estado de la tarea MQTT
        if (socket) {
            socket.on('mqttTaskStatus', function(data) {
                const mqttEnableCheckbox = document.getElementById('readerMqttEnable');
                if (mqttEnableCheckbox) {
                    mqttEnableCheckbox.checked = data.enabled;
                    
                    // Actualizar la interfaz para reflejar el estado
                    const mqttForm = document.getElementById('readerMqttConfigForm');
                    if (mqttForm) {
                        // Actualizar los campos del formulario con la configuración MQTT
                        if (data.config) {
                            const fields = {
                                'readerMqttHost': data.config.host || '',
                                'readerMqttPort': data.config.port || 1883,
                                'readerMqttTopic': data.config.topic || '',
                                'readerMqttTopicCmd': data.config.topic_cmd || '',
                                'readerMqttQos': data.config.qos || 1,
                                'readerMqttSsl': data.config.ssl || 0,
                                'readerMqttUser': data.config.uid || '',
                                'readerMqttPass': data.config.pwd || '',
                                'readerMqttCaCrt': data.config.ca_crt || '',
                                'readerMqttClientCrt': data.config.client_crt || '',
                                'readerMqttClientKey': data.config.client_key || '',
                                'readerMqttClientPwd': data.config.client_pwd || '',
                                'readerMqttInterval': data.config.interval || 100,
                                'readerMqttMask': data.config.mask || 3303,
                                'readerMqttMaxTags': data.config.maxtags || 999,
                                'readerMqttPath': data.config.path || ''
                            };
                            
                            // Actualizar los checkboxes
                            const checkboxes = {
                                'readerMqttCacheTags': data.config.cachetags || false,
                                'readerMqttMergeTags': data.config.mergetags || false
                            };
                            
                            // Aplicar los valores a los campos del formulario
                            Object.entries(fields).forEach(([id, value]) => {
                                const element = document.getElementById(id);
                                if (element) element.value = value;
                            });
                            
                            // Aplicar los valores a los checkboxes
                            Object.entries(checkboxes).forEach(([id, checked]) => {
                                const element = document.getElementById(id);
                                if (element) element.checked = !!checked;
                            });
                        }
                    }
                }
            });
        }
        
        // Escuchar actualizaciones de estado del servidor
        if (socket) {
            socket.on('autoMonitorStatus', function(data) {
                updateAutoMonitorUI(data.enabled);
            });
            
            // Solicitar el estado actual al conectar
            socket.on('connect', function() {
                socket.emit('getAutoMonitorStatus');
            });
            
            // Manejar desconexión
            socket.on('disconnect', function() {
                displayStatus('Desconectado del servidor Node.js', 'error');
            });
        }
    }); // Cierre del DOMContentLoaded
</script>
</body>
</html>